{"ast":null,"code":"import { Path, Editor, Transforms } from 'slate';\nexport const getListStart = (editor, path) => {\n  let listStart = [];\n  let [node] = Editor.node(editor, path);\n\n  if (!isListNode(node)) {\n    return listStart;\n  }\n\n  let curPath = path;\n  let options = {\n    index: 0\n  };\n\n  while (isListNode(node) && options.index >= 0) {\n    computeListStart(listStart, node, options);\n    const pre = Editor.previous(editor, {\n      at: curPath\n    });\n\n    if (!pre) {\n      break;\n    }\n\n    [node, curPath] = pre;\n  }\n\n  return listStart;\n};\nexport const isListNode = node => {\n  if (!node || !node.type || !node.type.endsWith('-list')) {\n    return false;\n  }\n\n  return true;\n};\n\nconst computeListStart = (listStart, node, options = {\n  index: 0\n}) => {\n  let indent = node.indent || 0;\n  let start = node.start || 1;\n\n  if (listStart.length && indent > options.index) {\n    return;\n  }\n\n  if (!listStart.length) {\n    for (let i = 0; i <= indent; i++) {\n      listStart.push(1);\n    }\n  }\n\n  if (node.type === 'numbered-list') {\n    listStart[indent] = start + node.children.length;\n  }\n\n  options.index = indent - 1;\n};\n\nexport const fixList = (editor, path) => {\n  let entry;\n\n  if (!path) {\n    entry = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n)\n    });\n  } else {\n    entry = Editor.node(editor, path);\n  }\n\n  if (!entry) {\n    return;\n  }\n\n  console.log(\"fix:\", entry[0].type);\n\n  if (entry[0].type === 'list-item') {\n    const [node, path] = Editor.parent(editor, entry[1]);\n    const [preNode, prePath] = Editor.previous(editor, {\n      at: path\n    }) || [undefined, undefined]; // merge\n\n    if (isListNode(preNode) && preNode.type === node.type && preNode.indent === node.indent) {\n      Transforms.mergeNodes(editor, {\n        at: path\n      });\n    }\n\n    let listStart = prePath ? getListStart(editor, prePath) : [];\n    console.log(\"updateListStart:\", listStart);\n    updateListStart(editor, path, listStart);\n  } else {\n    const next = Editor.next(editor, {\n      at: entry[1]\n    });\n\n    if (next && isListNode(next[0])) {\n      console.log(\"updateListStart:\", []);\n      updateListStart(editor, next[1], []);\n    }\n  }\n};\n\nconst updateListStart = (editor, path, listStart) => {\n  let [node] = Editor.node(editor, path);\n\n  while (isListNode(node)) {\n    const indent = node.indent || 0;\n    const start = listStart[indent] || 1;\n\n    if (node.type === 'numbered-list') {\n      Transforms.setNodes(editor, {\n        start: listStart[indent]\n      }, {\n        at: path\n      });\n    }\n\n    listStart.splice(indent + 1);\n\n    if (node.type === 'numbered-list') {\n      listStart[indent] = start + node.children.length;\n    } else {\n      listStart[indent] = 1;\n    } // node.start = listStart[node.indent]\n\n\n    path = Path.next(path);\n    [node] = Editor.node(editor, path);\n  }\n};","map":{"version":3,"sources":["/Users/yonggu/WebstormProjects/gyedit/src/util.ts"],"names":["Path","Editor","Transforms","getListStart","editor","path","listStart","node","isListNode","curPath","options","index","computeListStart","pre","previous","at","type","endsWith","indent","start","length","i","push","children","fixList","entry","above","match","n","isBlock","console","log","parent","preNode","prePath","undefined","mergeNodes","updateListStart","next","setNodes","splice"],"mappings":"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","sourcesContent":["import {Path, Node, Editor, Transforms, NodeEntry, Ancestor} from 'slate'\nimport {ListNode} from \"./types\";\n\nexport const getListStart = (editor: Editor, path: Path): number[] => {\n    let listStart: number[] = []\n    let [node] = Editor.node(editor, path)\n    if (!isListNode(node)){\n        return listStart\n    }\n    let curPath: Path = path\n    let options = {\n        index: 0\n    }\n    while (isListNode(node) && options.index >= 0) {\n        computeListStart(listStart, node, options)\n        const pre: any = Editor.previous(editor, {at: curPath})\n        if (!pre) {\n            break\n        }\n        [node, curPath] = pre\n    }\n    return listStart\n}\n\nexport const isListNode = (node: Node | undefined): node is ListNode => {\n    if (!node || !node.type || !(node.type as string).endsWith('-list')) {\n        return false\n    }\n    return true\n}\n\nconst computeListStart = (listStart: number[], node: ListNode, options: { index: number } = {index: 0}): void => {\n    let indent = node.indent || 0\n    let start = node.start || 1\n    if (listStart.length && indent > options.index) {\n        return\n    }\n    if (!listStart.length) {\n        for (let i = 0; i <= indent; i++) {\n            listStart.push(1)\n        }\n    }\n    if (node.type === 'numbered-list') {\n        listStart[indent] = start + node.children.length\n    }\n    options.index = indent - 1\n}\n\nexport const fixList = (editor:Editor, path?:Path): void => {\n    let entry:NodeEntry | undefined\n    if (!path){\n        entry = Editor.above(editor, {\n            match: n => Editor.isBlock(editor,n)\n        })\n    }else{\n        entry = Editor.node(editor,path)\n    }\n    if (!entry){\n        return\n    }\n    console.log(\"fix:\",entry[0].type)\n    if (entry[0].type === 'list-item') {\n        const [node, path] = Editor.parent(editor,entry[1]) as NodeEntry<ListNode>\n        const [preNode, prePath] = Editor.previous(editor, {at: path}) || [undefined, undefined]\n\n        // merge\n        if (isListNode(preNode) && preNode.type === node.type && preNode.indent === node.indent) {\n            Transforms.mergeNodes(editor, {at: path})\n        }\n        let listStart: number[] = prePath ? getListStart(editor, prePath) : []\n        console.log(\"updateListStart:\", listStart)\n        updateListStart(editor, path, listStart)\n    }else {\n        const next = Editor.next(editor, {at:entry[1]})\n        if (next && isListNode(next[0])){\n            console.log(\"updateListStart:\", [])\n            updateListStart(editor, next[1], [])\n        }\n    }\n}\n\nconst updateListStart = (editor:Editor, path:Path, listStart:number[]):void => {\n    let [node] = Editor.node(editor, path)\n    while (isListNode(node)){\n        const indent = node.indent || 0\n        const start = listStart[indent] || 1\n\n        if (node.type === 'numbered-list') {\n            Transforms.setNodes(editor,{start:listStart[indent]}, {at:path})\n        }\n        listStart.splice(indent+1)\n\n        if (node.type === 'numbered-list'){\n            listStart[indent] = start + node.children.length\n        }else{\n            listStart[indent] = 1\n        }\n\n        // node.start = listStart[node.indent]\n\n        path = Path.next(path);\n        [node] = Editor.node(editor, path)\n    }\n}"]},"metadata":{},"sourceType":"module"}