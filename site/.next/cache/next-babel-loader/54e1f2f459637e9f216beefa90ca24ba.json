{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport Prism from 'prismjs';\nimport 'prismjs/components/prism-python';\nimport 'prismjs/components/prism-php';\nimport 'prismjs/components/prism-sql';\nimport 'prismjs/components/prism-java';\nimport React, { useState, useCallback, useMemo } from 'react';\nimport { Slate, Editable, withReact } from 'slate-react';\nimport { Text, createEditor } from 'slate';\nimport { withHistory } from 'slate-history';\nimport { css } from 'emotion';\n\nconst CodeHighlightingExample = () => {\n  const {\n    0: value,\n    1: setValue\n  } = useState(initialValue);\n  const {\n    0: language,\n    1: setLanguage\n  } = useState('html');\n  const renderLeaf = useCallback(props => __jsx(Leaf, props), []);\n  const editor = useMemo(() => withHistory(withReact(createEditor())), []); // decorate function depends on the language selected\n\n  const decorate = useCallback(([node, path]) => {\n    const ranges = [];\n\n    if (!Text.isText(node)) {\n      return ranges;\n    }\n\n    const tokens = Prism.tokenize(node.text, Prism.languages[language]);\n    let start = 0;\n\n    for (const token of tokens) {\n      const length = getLength(token);\n      const end = start + length;\n\n      if (typeof token !== 'string') {\n        ranges.push({\n          [token.type]: true,\n          anchor: {\n            path,\n            offset: start\n          },\n          focus: {\n            path,\n            offset: end\n          }\n        });\n      }\n\n      start = end;\n    }\n\n    return ranges;\n  }, [language]);\n  return __jsx(Slate, {\n    editor: editor,\n    value: value,\n    onChange: value => setValue(value)\n  }, __jsx(\"div\", {\n    contentEditable: false,\n    style: {\n      position: 'relative',\n      top: '5px',\n      right: '5px'\n    }\n  }, __jsx(\"h3\", null, \"Select a language\", __jsx(\"select\", {\n    value: language,\n    style: {\n      float: 'right'\n    },\n    onChange: e => setLanguage(e.target.value)\n  }, __jsx(\"option\", {\n    value: \"js\"\n  }, \"JavaScript\"), __jsx(\"option\", {\n    value: \"css\"\n  }, \"CSS\"), __jsx(\"option\", {\n    value: \"html\"\n  }, \"HTML\"), __jsx(\"option\", {\n    value: \"python\"\n  }, \"Python\"), __jsx(\"option\", {\n    value: \"sql\"\n  }, \"SQL\"), __jsx(\"option\", {\n    value: \"java\"\n  }, \"Java\"), __jsx(\"option\", {\n    value: \"php\"\n  }, \"PHP\")))), __jsx(Editable, {\n    decorate: decorate,\n    renderLeaf: renderLeaf,\n    placeholder: \"Write some code...\"\n  }));\n};\n\nconst getLength = token => {\n  if (typeof token === 'string') {\n    return token.length;\n  } else if (typeof token.content === 'string') {\n    return token.content.length;\n  } else {\n    return token.content.reduce((l, t) => l + getLength(t), 0);\n  }\n}; // different token types, styles found on Prismjs website\n\n\nconst Leaf = ({\n  attributes,\n  children,\n  leaf\n}) => {\n  return __jsx(\"span\", _extends({}, attributes, {\n    className: css`\n            font-family: monospace;\n            background: hsla(0, 0%, 100%, .5);\n\n        ${leaf.comment && css`\n            color: slategray;\n          `} \n\n        ${(leaf.operator || leaf.url) && css`\n            color: #9a6e3a;\n          `}\n        ${leaf.keyword && css`\n            color: #07a;\n          `}\n        ${(leaf.variable || leaf.regex) && css`\n            color: #e90;\n          `}\n        ${(leaf.number || leaf.boolean || leaf.tag || leaf.constant || leaf.symbol || leaf.attr - name || leaf.selector) && css`\n            color: #905;\n          `}\n        ${leaf.punctuation && css`\n            color: #999;\n          `}\n        ${(leaf.string || leaf.char) && css`\n            color: #690;\n          `}\n        ${(leaf.function || leaf.class - name) && css`\n            color: #dd4a68;\n          `}\n        `\n  }), children);\n};\n\nconst initialValue = [{\n  children: [{\n    text: '<h1>Hi!</h1>'\n  }]\n}]; // modifications and additions to prism library\n\nPrism.languages.python = Prism.languages.extend('python', {});\nPrism.languages.insertBefore('python', 'prolog', {\n  comment: {\n    pattern: /##[^\\n]*/,\n    alias: 'comment'\n  }\n});\nPrism.languages.javascript = Prism.languages.extend('javascript', {});\nPrism.languages.insertBefore('javascript', 'prolog', {\n  comment: {\n    pattern: /\\/\\/[^\\n]*/,\n    alias: 'comment'\n  }\n});\nPrism.languages.html = Prism.languages.extend('html', {});\nPrism.languages.insertBefore('html', 'prolog', {\n  comment: {\n    pattern: /<!--[^\\n]*-->/,\n    alias: 'comment'\n  }\n});\nPrism.languages.markdown = Prism.languages.extend('markup', {});\nPrism.languages.insertBefore('markdown', 'prolog', {\n  blockquote: {\n    pattern: /^>(?:[\\t ]*>)*/m,\n    alias: 'punctuation'\n  },\n  code: [{\n    pattern: /^(?: {4}|\\t).+/m,\n    alias: 'keyword'\n  }, {\n    pattern: /``.+?``|`[^`\\n]+`/,\n    alias: 'keyword'\n  }],\n  title: [{\n    pattern: /\\w+.*(?:\\r?\\n|\\r)(?:==+|--+)/,\n    alias: 'important',\n    inside: {\n      punctuation: /==+$|--+$/\n    }\n  }, {\n    pattern: /(^\\s*)#+.+/m,\n    lookbehind: !0,\n    alias: 'important',\n    inside: {\n      punctuation: /^#+|#+$/\n    }\n  }],\n  hr: {\n    pattern: /(^\\s*)([*-])([\\t ]*\\2){2,}(?=\\s*$)/m,\n    lookbehind: !0,\n    alias: 'punctuation'\n  },\n  list: {\n    pattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n    lookbehind: !0,\n    alias: 'punctuation'\n  },\n  'url-reference': {\n    pattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n    inside: {\n      variable: {\n        pattern: /^(!?\\[)[^\\]]+/,\n        lookbehind: !0\n      },\n      string: /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n      punctuation: /^[\\[\\]!:]|[<>]/\n    },\n    alias: 'url'\n  },\n  bold: {\n    pattern: /(^|[^\\\\])(\\*\\*|__)(?:(?:\\r?\\n|\\r)(?!\\r?\\n|\\r)|.)+?\\2/,\n    lookbehind: !0,\n    inside: {\n      punctuation: /^\\*\\*|^__|\\*\\*$|__$/\n    }\n  },\n  italic: {\n    pattern: /(^|[^\\\\])([*_])(?:(?:\\r?\\n|\\r)(?!\\r?\\n|\\r)|.)+?\\2/,\n    lookbehind: !0,\n    inside: {\n      punctuation: /^[*_]|[*_]$/\n    }\n  },\n  url: {\n    pattern: /!?\\[[^\\]]+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)| ?\\[[^\\]\\n]*\\])/,\n    inside: {\n      variable: {\n        pattern: /(!?\\[)[^\\]]+(?=\\]$)/,\n        lookbehind: !0\n      },\n      string: {\n        pattern: /\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/\n      }\n    }\n  }\n});\nPrism.languages.markdown.bold.inside.url = Prism.util.clone(Prism.languages.markdown.url);\nPrism.languages.markdown.italic.inside.url = Prism.util.clone(Prism.languages.markdown.url);\nPrism.languages.markdown.bold.inside.italic = Prism.util.clone(Prism.languages.markdown.italic);\nPrism.languages.markdown.italic.inside.bold = Prism.util.clone(Prism.languages.markdown.bold); // prettier-ignore\n\nexport default CodeHighlightingExample;","map":null,"metadata":{},"sourceType":"module"}