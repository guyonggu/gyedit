{"ast":null,"code":"import { Editor, Path, Point, Range, Transforms } from \"slate\";\nconst SHORTCUTS = {\n  '*': 'ul-item',\n  '-': 'ul-item',\n  '+': 'ul-item',\n  '>': 'block-quote',\n  '#': 'heading-one',\n  '##': 'heading-two',\n  '###': 'heading-three',\n  '####': 'heading-four',\n  '#####': 'heading-five',\n  '######': 'heading-six'\n};\nexport const withMarkdown = editor => {\n  const {\n    deleteBackward,\n    insertText\n  } = editor;\n\n  editor.insertText = text => {\n    const {\n      selection\n    } = editor;\n\n    if (text !== ' ' || !selection || !Range.isCollapsed(selection)) {\n      insertText(text);\n      return;\n    }\n\n    const {\n      anchor\n    } = selection;\n    const block = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n)\n    });\n    const path = block ? block[1] : [];\n    const start = Editor.start(editor, path);\n    const range = {\n      anchor,\n      focus: start\n    };\n    let beforeText = Editor.string(editor, range);\n    let tabs = 0;\n\n    for (let c of beforeText) {\n      if (c === '\\t') {\n        tabs++;\n      }\n    }\n\n    beforeText = beforeText.substr(tabs);\n    const blockType = block[0].type;\n    let inList = typeof blockType === 'string' ? blockType === 'list-item' : false;\n\n    if (text === ' ') {\n      let type = SHORTCUTS[beforeText];\n\n      if (!type && /^[1-9]\\d*\\./.test(beforeText)) {\n        type = 'ol-item';\n      }\n\n      let list;\n\n      switch (type) {\n        case 'ul-item':\n          if (inList) break;\n          Transforms.select(editor, range);\n          Transforms.delete(editor);\n          Transforms.setNodes(editor, {\n            type: 'list-item'\n          }, {\n            match: n => Editor.isBlock(editor, n)\n          });\n          list = {\n            type: 'bulleted-list',\n            indent: tabs + 1,\n            children: []\n          };\n          Transforms.wrapNodes(editor, list, {\n            match: n => n.type === 'list-item'\n          });\n          break;\n\n        case 'ol-item':\n          if (inList) break;\n          const found = beforeText.match(/^([\\t]*)\\d+\\./);\n          Transforms.select(editor, range);\n          Transforms.delete(editor);\n          Transforms.setNodes(editor, {\n            type: 'list-item'\n          }, {\n            match: n => Editor.isBlock(editor, n)\n          });\n          list = {\n            type: 'numbered-list',\n            indent: tabs + 1,\n            children: []\n          };\n          Transforms.wrapNodes(editor, list, {\n            match: n => n.type === 'list-item'\n          });\n          break;\n\n        default:\n          insertText(text);\n      }\n\n      return;\n    } else if (text === '\\t' && inList && beforeText === '') {\n      const [listNode] = Editor.parent(editor, path);\n      console.log(listNode.type);\n\n      if (listNode.type === 'bulleted-list' || listNode.type === 'numbered-list') {\n        listNode.indent++;\n      }\n\n      Transforms.select(editor, path);\n      return;\n    }\n\n    insertText(text);\n  };\n\n  editor.deleteBackward = (...args) => {\n    const {\n      selection\n    } = editor;\n\n    if (selection && Range.isCollapsed(selection)) {\n      const match = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n)\n      });\n\n      if (match) {\n        const [block, path] = match;\n        const start = Editor.start(editor, path);\n\n        if (block.type !== 'paragraph' && Point.equals(selection.anchor, start)) {\n          Transforms.setNodes(editor, {\n            type: 'paragraph'\n          });\n\n          if (block.type === 'list-item') {\n            Transforms.unwrapNodes(editor, {\n              match: n => n.type === 'bulleted-list',\n              split: true\n            });\n          }\n\n          return;\n        }\n      }\n\n      deleteBackward(...args);\n    }\n  };\n\n  return editor;\n};\n\nfunction moveListItemUp(editor, path) {\n  let entry = Editor.parent(editor, path);\n  let node = entry[0];\n\n  if (node.type.endsWith('-list')) {\n    if (!node.indent || node.indent <= 1) {\n      Transforms.setNodes(editor, {\n        type: 'paragraph'\n      }, {\n        at: path\n      });\n      Transforms.liftNodes(editor, {\n        at: path\n      });\n    }\n\n    let ref = Editor.pathRef(editor, path);\n    let pre = Editor.previous(editor, {\n      at: path\n    });\n    let next = Editor.next(editor, {\n      at: path\n    });\n\n    if (pre) {\n      Transforms.splitNodes(editor, {\n        at: path\n      });\n    }\n\n    if (next) {\n      Transforms.splitNodes(editor, {\n        at: Path.next(ref.current)\n      });\n    }\n\n    path = ref.unref();\n    Transforms.setNodes(editor, {\n      indent: node.indent + 1\n    }, {\n      at: Path.parent(path)\n    });\n  }\n}","map":{"version":3,"sources":["/Users/yonggu/WebstormProjects/gyedit/src/withMarkdown.ts"],"names":["Editor","Path","Point","Range","Transforms","SHORTCUTS","withMarkdown","editor","deleteBackward","insertText","text","selection","isCollapsed","anchor","block","above","match","n","isBlock","path","start","range","focus","beforeText","string","tabs","c","substr","blockType","type","inList","test","list","select","delete","setNodes","indent","children","wrapNodes","found","listNode","parent","console","log","args","equals","unwrapNodes","split","moveListItemUp","entry","node","endsWith","at","liftNodes","ref","pathRef","pre","previous","next","splitNodes","current","unref"],"mappings":"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","sourcesContent":["import {Editor, Path, Point, Range, Transforms} from \"slate\";\nimport {ListNode, ListNodeEntry} from './types'\nconst SHORTCUTS = {\n    '*': 'ul-item',\n    '-': 'ul-item',\n    '+': 'ul-item',\n    '>': 'block-quote',\n    '#': 'heading-one',\n    '##': 'heading-two',\n    '###': 'heading-three',\n    '####': 'heading-four',\n    '#####': 'heading-five',\n    '######': 'heading-six',\n}\n\nexport const withMarkdown = (editor: Editor) => {\n    const {deleteBackward, insertText} = editor\n\n    editor.insertText = (text: string) => {\n        const {selection} = editor\n        if ((text !== ' ') || !selection || !Range.isCollapsed(selection)) {\n            insertText(text)\n            return\n        }\n\n        const {anchor} = selection\n        const block = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n        })\n        const path = block ? block[1] : []\n        const start = Editor.start(editor, path)\n        const range = {anchor, focus: start}\n        let beforeText = Editor.string(editor, range)\n        let tabs = 0\n        for (let c of beforeText) {\n            if (c === '\\t') {\n                tabs++\n            }\n        }\n        beforeText = beforeText.substr(tabs)\n        const blockType = block![0].type\n        let inList = typeof blockType === 'string' ? blockType === 'list-item' : false\n\n        if (text === ' ') {\n\n            let type = SHORTCUTS[beforeText]\n\n            if (!type && /^[1-9]\\d*\\./.test(beforeText)) {\n                type = 'ol-item'\n            }\n            let list:ListNode\n            switch (type) {\n                case 'ul-item':\n                    if (inList) break\n                    Transforms.select(editor, range)\n                    Transforms.delete(editor)\n                    Transforms.setNodes(\n                        editor,\n                        {type: 'list-item'},\n                        {match: n => Editor.isBlock(editor, n)}\n                    )\n                    list = {type: 'bulleted-list', indent: tabs+1, children: []}\n                    Transforms.wrapNodes(editor, list, {\n                        match: n => n.type === 'list-item',\n                    })\n                    break\n                case 'ol-item':\n                    if (inList) break\n                    const found = beforeText.match(/^([\\t]*)\\d+\\./)\n                    Transforms.select(editor, range)\n                    Transforms.delete(editor)\n                    Transforms.setNodes(\n                        editor,\n                        {type: 'list-item'},\n                        {match: n => Editor.isBlock(editor, n)}\n                    )\n                    list = {type: 'numbered-list', indent: tabs+1, children: []}\n                    Transforms.wrapNodes(editor, list, {\n                        match: n => n.type === 'list-item',\n                    })\n                    break\n                default:\n                    insertText(text)\n            }\n            return\n        } else if (text === '\\t' && inList && beforeText === '') {\n            const [listNode] = Editor.parent(editor, path) as ListNodeEntry\n            console.log(listNode.type)\n            if (listNode.type === 'bulleted-list' || listNode.type === 'numbered-list') {\n                listNode.indent++\n            }\n            Transforms.select(editor, path)\n            return\n        }\n\n        insertText(text)\n    }\n\n    editor.deleteBackward = (...args) => {\n        const {selection} = editor\n\n        if (selection && Range.isCollapsed(selection)) {\n            const match = Editor.above(editor, {\n                match: n => Editor.isBlock(editor, n),\n            })\n\n            if (match) {\n                const [block, path] = match\n                const start = Editor.start(editor, path)\n\n                if (\n                    block.type !== 'paragraph' &&\n                    Point.equals(selection.anchor, start)\n                ) {\n                    Transforms.setNodes(editor, {type: 'paragraph'})\n\n                    if (block.type === 'list-item') {\n                        Transforms.unwrapNodes(editor, {\n                            match: n => n.type === 'bulleted-list',\n                            split: true,\n                        })\n                    }\n\n                    return\n                }\n            }\n\n            deleteBackward(...args)\n        }\n    }\n\n    return editor\n}\n\nfunction moveListItemUp(editor: Editor, path: Path) {\n    let entry = Editor.parent(editor, path)\n    let node: ListNode = entry[0] as ListNode\n    if (node.type.endsWith('-list')) {\n        if (!node.indent || node.indent <= 1){\n            Transforms.setNodes(editor, {type:'paragraph'}, {at:path})\n            Transforms.liftNodes(editor,{at:path})\n        }\n        let ref = Editor.pathRef(editor,path)\n        let pre = Editor.previous(editor, {at: path})\n        let next = Editor.next(editor,{at:path})\n        if (pre) {\n            Transforms.splitNodes(editor, {at: path})\n        }\n        if (next) {\n            Transforms.splitNodes(editor, {at: Path.next(ref.current!)})\n        }\n        path = ref.unref()!\n        Transforms.setNodes(editor, {indent: node.indent + 1}, {at: Path.parent(path)})\n\n    }\n}"]},"metadata":{},"sourceType":"module"}