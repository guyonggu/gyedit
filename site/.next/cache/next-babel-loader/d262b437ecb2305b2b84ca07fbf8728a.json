{"ast":null,"code":"import { Editor, Point, Range, Element, Transforms } from \"slate\";\nimport { fixList, isListNode } from \"./util\";\nconst SHORTCUTS = {\n  '*': 'ul-item',\n  '-': 'ul-item',\n  '+': 'ul-item',\n  '>': 'block-quote',\n  '#': 'heading-one',\n  '##': 'heading-two',\n  '###': 'heading-three',\n  '####': 'heading-four',\n  '#####': 'heading-five',\n  '######': 'heading-six'\n};\nexport const withMarkdown = editor => {\n  const {\n    deleteBackward,\n    insertText,\n    insertBreak,\n    deleteFragment,\n    normalizeNode\n  } = editor;\n\n  const insertBreak2 = () => {\n    let handled = false;\n    const {\n      selection\n    } = editor;\n\n    if (!selection || Range.isExpanded(selection)) {\n      insertBreak();\n      return;\n    }\n\n    const block = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n)\n    });\n\n    if (!block || Editor.isEditor(block[0])) {\n      insertBreak();\n      return;\n    }\n\n    const parent = Editor.parent(editor, block[1]);\n\n    if (!parent || Editor.isEditor(parent[0])) {\n      insertBreak();\n      return;\n    }\n\n    const text = Editor.string(editor, block[1]);\n\n    if (text) {\n      insertBreak();\n      return;\n    }\n\n    const blockPath = block[1];\n    let indent = 0;\n\n    if (typeof parent[0].indent === \"number\") {\n      indent = parent[0].indent > 1 ? parent[0].indent - 1 : 0;\n    }\n\n    Transforms.setNodes(editor, {\n      type: 'paragraph',\n      indent\n    }, {\n      at: blockPath\n    }); // if it is the last child\n\n    if (blockPath[blockPath.length - 1] === parent[0].children.length - 1) {\n      Transforms.liftNodes(editor, {\n        at: blockPath\n      });\n      return;\n    }\n  };\n\n  editor.insertBreak = () => {\n    Editor.withoutNormalizing(editor, () => {\n      insertBreak2();\n      fixList(editor);\n    });\n  };\n\n  editor.insertText = text => {\n    const {\n      selection\n    } = editor;\n\n    if (text !== ' ' || !selection || !Range.isCollapsed(selection)) {\n      insertText(text);\n      return;\n    }\n\n    const {\n      anchor\n    } = selection;\n    const block = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n)\n    });\n    const path = block ? block[1] : [];\n    const start = Editor.start(editor, path);\n    const range = {\n      anchor,\n      focus: start\n    };\n    let beforeText = Editor.string(editor, range);\n    let tabs = 0;\n\n    for (let c of beforeText) {\n      if (c === '\\t') {\n        tabs++;\n      }\n    }\n\n    beforeText = beforeText.substr(tabs);\n    const blockType = block[0].type;\n    let inList = typeof blockType === 'string' ? blockType === 'list-item' : false;\n    let type = SHORTCUTS[beforeText];\n\n    if (!type && /^[1-9]\\d*\\./.test(beforeText)) {\n      type = 'ol-item';\n    }\n\n    let list;\n\n    switch (type) {\n      case 'ul-item':\n        if (inList) {\n          insertText(text);\n          break;\n        }\n\n        Transforms.select(editor, range);\n        Transforms.delete(editor);\n        Transforms.setNodes(editor, {\n          type: 'list-item'\n        }, {\n          match: n => Editor.isBlock(editor, n)\n        });\n        list = {\n          type: 'bulleted-list',\n          indent: tabs,\n          children: []\n        };\n        Transforms.wrapNodes(editor, list, {\n          match: n => n.type === 'list-item'\n        });\n        fixList(editor);\n        break;\n\n      case 'ol-item':\n        if (inList) {\n          insertText(text);\n          break;\n        }\n\n        const found = beforeText.match(/^([\\t]*)\\d+\\./);\n        Transforms.select(editor, range);\n        Transforms.delete(editor);\n        Transforms.setNodes(editor, {\n          type: 'list-item'\n        }, {\n          match: n => Editor.isBlock(editor, n)\n        });\n        list = {\n          type: 'numbered-list',\n          indent: tabs,\n          children: []\n        };\n        Transforms.wrapNodes(editor, list, {\n          match: n => n.type === 'list-item'\n        });\n        fixList(editor);\n        break;\n\n      case 'block-quote':\n        if (inList || blockType !== 'paragraph') {\n          insertText(text);\n          break;\n        }\n\n        let parent = Editor.above(editor, {\n          match: n => n.type === 'block-quote'\n        });\n\n        if (parent) {\n          insertText(text);\n          break;\n        }\n\n        Transforms.select(editor, range);\n        Transforms.delete(editor);\n        Transforms.wrapNodes(editor, {\n          type: 'block-quote',\n          children: []\n        }, {\n          match: n => n.type === 'paragraph'\n        });\n        break;\n\n      default:\n        insertText(text);\n    }\n\n    return;\n  };\n\n  const deleteBackward2 = unit => {\n    console.log(\"editor.deleteBackward:\", unit);\n    const {\n      selection\n    } = editor;\n\n    if (!selection || Range.isExpanded(selection)) {\n      deleteBackward(unit);\n      return;\n    }\n\n    const match = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n)\n    });\n\n    if (!match || Editor.isEditor(match[0])) {\n      deleteBackward(unit);\n      return;\n    }\n\n    const [block, path] = match;\n    const start = Editor.start(editor, path);\n\n    if (Point.equals(selection.anchor, start)) {\n      if (block.type === 'list-item') {\n        const [listNode] = Editor.parent(editor, path);\n\n        if (listNode && listNode.indent > 0) {\n          Editor.withoutNormalizing(editor, () => {\n            Transforms.wrapNodes(editor, {\n              type: listNode.type,\n              indent: listNode.indent - 1,\n              children: []\n            }, {\n              at: path\n            });\n            Transforms.liftNodes(editor, {\n              at: path\n            });\n          });\n        } else {\n          Transforms.setNodes(editor, {\n            type: 'paragraph'\n          });\n          Transforms.unwrapNodes(editor, {\n            match: n => typeof n.type === 'string' && n.type.endsWith('-list'),\n            split: true\n          }); // deleteBackward(unit)\n        }\n      } else if (block.type === 'paragraph') {\n        if (block.indent && block.indent > 0) {\n          Transforms.setNodes(editor, {\n            indent: block.indent - 1\n          }, {\n            at: path\n          });\n          return;\n        } else {\n          deleteBackward(unit);\n        }\n      } else {\n        Transforms.setNodes(editor, {\n          type: 'paragraph'\n        });\n      }\n\n      return;\n    } // end if at start\n\n\n    deleteBackward(unit);\n  };\n\n  editor.deleteBackward = unit => {\n    Editor.withoutNormalizing(editor, () => {\n      deleteBackward2(unit);\n      fixList(editor);\n    });\n  };\n\n  editor.deleteFragment = () => {\n    // console.log(\"editor.deleteFragment:\")\n    deleteFragment();\n  };\n\n  editor.normalizeNode = entry => {\n    if (Element.isElement(entry[0]) && entry[0].type !== 'list-item') {\n      const [pNode] = Editor.parent(editor, entry[1]);\n\n      if (isListNode(pNode)) {\n        Transforms.setNodes(editor, {\n          type: 'list-item'\n        }, {\n          at: entry[1]\n        });\n      }\n    }\n\n    normalizeNode(entry);\n  };\n\n  return editor;\n};\n\nconst beforeTextInBlock = editor => {\n  const {\n    selection\n  } = editor;\n\n  if (!selection) {\n    return '';\n  }\n\n  const block = Editor.above(editor, {\n    match: n => Editor.isBlock(editor, n)\n  });\n  const path = block ? block[1] : [];\n  const start = Editor.start(editor, path);\n  const range = {\n    anchor: Range.start(editor.selection),\n    focus: start\n  };\n  let beforeText = Editor.string(editor, range);\n  return beforeText;\n}; //\n// Transforms.delete =(\n//     editor: Editor,\n//     options: {\n//     at?: Location\n//     distance?: number\n//     unit?: 'character' | 'word' | 'line' | 'block'\n//     reverse?: boolean\n//     hanging?: boolean\n//     voids?: boolean\n// } = {}\n// ):void => {\n//     Editor.withoutNormalizing(editor, () => {\n//         const {\n//             reverse = false,\n//             unit = 'character',\n//             distance = 1,\n//             voids = false,\n//         } = options\n//         let { at = editor.selection, hanging = false } = options\n//\n//         if (!at) {\n//             return\n//         }\n//\n//         if (Range.isRange(at) && Range.isCollapsed(at)) {\n//             at = at.anchor\n//         }\n//\n//         if (Point.isPoint(at)) {\n//             const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n//\n//             if (!voids && furthestVoid) {\n//                 const [, voidPath] = furthestVoid\n//                 at = voidPath\n//             } else {\n//                 const opts = { unit, distance }\n//                 const target = reverse\n//                     ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n//                     : Editor.after(editor, at, opts) || Editor.end(editor, [])\n//                 at = { anchor: at, focus: target }\n//                 hanging = true\n//             }\n//         }\n//\n//         if (Path.isPath(at)) {\n//             Transforms.removeNodes(editor, { at, voids })\n//             return\n//         }\n//\n//         if (Range.isCollapsed(at)) {\n//             return\n//         }\n//\n//         if (!hanging) {\n//             at = Editor.unhangRange(editor, at, { voids })\n//         }\n//\n//         let [start, end] = Range.edges(at)\n//         const startBlock = Editor.above(editor, {\n//             match: n => Editor.isBlock(editor, n),\n//             at: start,\n//             voids,\n//         })\n//         const endBlock = Editor.above(editor, {\n//             match: n => Editor.isBlock(editor, n),\n//             at: end,\n//             voids,\n//         })\n//         const isAcrossBlocks =\n//             startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n//         const isSingleText = Path.equals(start.path, end.path)\n//         const startVoid = voids\n//             ? null\n//             : Editor.void(editor, { at: start, mode: 'highest' })\n//         const endVoid = voids\n//             ? null\n//             : Editor.void(editor, { at: end, mode: 'highest' })\n//\n//         // If the start or end points are inside an inline void, nudge them out.\n//         if (startVoid) {\n//             const before = Editor.before(editor, start)\n//\n//             if (\n//                 before &&\n//                 startBlock &&\n//                 Path.isAncestor(startBlock[1], before.path)\n//             ) {\n//                 start = before\n//             }\n//         }\n//\n//         if (endVoid) {\n//             const after = Editor.after(editor, end)\n//\n//             if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n//                 end = after\n//             }\n//         }\n//\n//         // Get the highest nodes that are completely inside the range, as well as\n//         // the start and end nodes.\n//         const matches: NodeEntry[] = []\n//         let lastPath: Path | undefined\n//\n//         for (const entry of Editor.nodes(editor, { at, voids })) {\n//             const [node, path] = entry\n//\n//             if (lastPath && Path.compare(path, lastPath) === 0) {\n//                 continue\n//             }\n//\n//             if (\n//                 (!voids && Editor.isVoid(editor, node)) ||\n//                 (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n//             ) {\n//                 matches.push(entry)\n//                 lastPath = path\n//             }\n//         }\n//\n//         const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n//         const startRef = Editor.pointRef(editor, start)\n//         const endRef = Editor.pointRef(editor, end)\n//\n//         if (!isSingleText && !startVoid) {\n//             const point = startRef.current!\n//             const [node] = Editor.leaf(editor, point)\n//             const { path } = point\n//             const { offset } = start\n//             const text = node.text.slice(offset)\n//             editor.apply({ type: 'remove_text', path, offset, text })\n//         }\n//\n//         for (const pathRef of pathRefs) {\n//             const path = pathRef.unref()!\n//             console.log(\"remove not at:\", path)\n//             Transforms.removeNodes(editor, { at: path, voids })\n//         }\n//\n//         if (!endVoid) {\n//             const point = endRef.current!\n//             const [node] = Editor.leaf(editor, point)\n//             const { path } = point\n//             const offset = isSingleText ? start.offset : 0\n//             const text = node.text.slice(offset, end.offset)\n//             editor.apply({ type: 'remove_text', path, offset, text })\n//         }\n//\n//         if (\n//             !isSingleText &&\n//             isAcrossBlocks &&\n//             endRef.current &&\n//             startRef.current\n//         ) {\n//             console.log(\"merge node at:\", endRef.current)\n//             Transforms.mergeNodes(editor, {\n//                 at: endRef.current,\n//                 hanging: true,\n//                 voids,\n//             })\n//         }\n//\n//         const point = endRef.unref() || startRef.unref()\n//\n//         if (options.at == null && point) {\n//             Transforms.select(editor, point)\n//         }\n//     })\n// }\n//\n// Transforms.mergeNodes = (\n//     editor: Editor,\n//     options: {\n//     at?: Location\n//     match?: (node: Node) => boolean\n//     mode?: 'highest' | 'lowest'\n//     hanging?: boolean\n//     voids?: boolean\n// } = {}\n// ) => {\n//     Editor.withoutNormalizing(editor, () => {\n//         let { match, at = editor.selection } = options\n//         const { hanging = false, voids = false, mode = 'lowest' } = options\n//\n//         if (!at) {\n//             return\n//         }\n//\n//         if (match == null) {\n//             if (Path.isPath(at)) {\n//                 const [parent] = Editor.parent(editor, at)\n//                 match = n => parent.children.includes(n)\n//             } else {\n//                 match = n => Editor.isBlock(editor, n)\n//             }\n//         }\n//\n//         if (!hanging && Range.isRange(at)) {\n//             at = Editor.unhangRange(editor, at)\n//         }\n//\n//         if (Range.isRange(at)) {\n//             if (Range.isCollapsed(at)) {\n//                 at = at.anchor\n//             } else {\n//                 const [, end] = Range.edges(at)\n//                 const pointRef = Editor.pointRef(editor, end)\n//                 Transforms.delete(editor, { at })\n//                 at = pointRef.unref()!\n//\n//                 if (options.at == null) {\n//                     Transforms.select(editor, at)\n//                 }\n//             }\n//         }\n//\n//         const [current] = Editor.nodes(editor, { at, match, voids, mode })\n//         const prev = Editor.previous(editor, { at, match, voids, mode })\n//\n//         if (!current || !prev) {\n//             return\n//         }\n//\n//         const [node, path] = current\n//         const [prevNode, prevPath] = prev\n//\n//         if (path.length === 0 || prevPath.length === 0) {\n//             return\n//         }\n//\n//         const newPath = Path.next(prevPath)\n//         const commonPath = Path.common(path, prevPath)\n//         const isPreviousSibling = Path.isSibling(path, prevPath)\n//         const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\n//             .slice(commonPath.length)\n//             .slice(0, -1)\n//\n//         // Determine if the merge will leave an ancestor of the path empty as a\n//         // result, in which case we'll want to remove it after merging.\n//         const emptyAncestor = Editor.above(editor, {\n//             at: path,\n//             mode: 'highest',\n//             match: n =>\n//                 levels.includes(n) && Element.isElement(n) && n.children.length === 1,\n//         })\n//\n//         const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n//         let properties\n//         let position\n//\n//         // Ensure that the nodes are equivalent, and figure out what the position\n//         // and extra properties of the merge will be.\n//         if (Text.isText(node) && Text.isText(prevNode)) {\n//             const { text, ...rest } = node\n//             position = prevNode.text.length\n//             properties = rest as Partial<Text>\n//         } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n//             const { children, ...rest } = node\n//             position = prevNode.children.length\n//             properties = rest as Partial<Element>\n//         } else {\n//             throw new Error(\n//                 `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n//                     node\n//                 )} ${JSON.stringify(prevNode)}`\n//             )\n//         }\n//\n//         // If the node isn't already the next sibling of the previous node, move\n//         // it so that it is before merging.\n//         if (!isPreviousSibling) {\n//             console.log(\"In merge, movNodes from \", path, \"to\", newPath)\n//             Transforms.moveNodes(editor, { at: path, to: newPath, voids })\n//         }\n//\n//         // If there was going to be an empty ancestor of the node that was merged,\n//         // we remove it from the tree.\n//         if (emptyRef) {\n//             console.log(\"In merge, remove node at:\", emptyRef.current)\n//             Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\n//         }\n//\n//         // If the target node that we're merging with is empty, remove it instead\n//         // of merging the two. This is a common rich text editor behavior to\n//         // prevent losing formatting when deleting entire nodes when you have a\n//         // hanging selection.\n//         if (\n//             (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n//             (Text.isText(prevNode) && prevNode.text === '')\n//         ) {\n//             console.log(\"In merge, remove2\", prevNode.type, \"node at:\", prevPath)\n//             Transforms.removeNodes(editor, { at: prevPath, voids })\n//         } else {\n//             editor.apply({\n//                 type: 'merge_node',\n//                 path: newPath,\n//                 position,\n//                 properties,\n//             })\n//         }\n//\n//         if (emptyRef) {\n//             emptyRef.unref()\n//         }\n//     })\n// }","map":{"version":3,"sources":["/Users/yonggu/WebstormProjects/gyedit/src/withMarkdown.ts"],"names":["Editor","Point","Range","Element","Transforms","fixList","isListNode","SHORTCUTS","withMarkdown","editor","deleteBackward","insertText","insertBreak","deleteFragment","normalizeNode","insertBreak2","handled","selection","isExpanded","block","above","match","n","isBlock","isEditor","parent","text","string","blockPath","indent","setNodes","type","at","length","children","liftNodes","withoutNormalizing","isCollapsed","anchor","path","start","range","focus","beforeText","tabs","c","substr","blockType","inList","test","list","select","delete","wrapNodes","found","deleteBackward2","unit","console","log","equals","listNode","unwrapNodes","endsWith","split","entry","isElement","pNode","beforeTextInBlock"],"mappings":"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MAAM,CAACuB,OAAP,CAAed,MAAf,EAAuBa,CAAvB;AADmB,GAArB,CAAd;AAGA,QAAMiB,IAAI,GAAGpB,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAR,GAAc,EAAhC;AACA,QAAMqB,KAAK,GAAGxC,MAAM,CAACwC,KAAP,CAAa/B,MAAb,EAAqB8B,IAArB,CAAd;AACA,QAAME,KAAK,GAAG;AAACH,IAAAA,MAAM,EAAEpC,KAAK,CAACsC,KAAN,CAAY/B,MAAM,CAACQ,SAAnB,CAAT;AAAyCyB,IAAAA,KAAK,EAAEF;AAAhD,GAAd;AACA,MAAIG,UAAU,GAAG3C,MAAM,CAAC2B,MAAP,CAAclB,MAAd,EAAsBgC,KAAtB,CAAjB;AACA,SAAOE,UAAP;AACH,CAbD,C,CAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import {Editor, Path, Point, Range, Element, Text, Transforms, NodeEntry} from \"slate\";\nimport {ListNode} from './types'\nimport {fixList, isListNode} from \"./util\";\n\nconst SHORTCUTS = {\n    '*': 'ul-item',\n    '-': 'ul-item',\n    '+': 'ul-item',\n    '>': 'block-quote',\n    '#': 'heading-one',\n    '##': 'heading-two',\n    '###': 'heading-three',\n    '####': 'heading-four',\n    '#####': 'heading-five',\n    '######': 'heading-six',\n}\n\nexport const withMarkdown = (editor: Editor) => {\n    const {deleteBackward, insertText, insertBreak, deleteFragment, normalizeNode} = editor\n\n    const insertBreak2 = () => {\n        let handled = false\n        const {selection} = editor\n\n        if (!selection || Range.isExpanded(selection)) {\n            insertBreak()\n            return\n        }\n        const block = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n        })\n        if (!block || Editor.isEditor(block[0])) {\n            insertBreak()\n            return\n        }\n        const parent = Editor.parent(editor, block[1])\n        if (!parent || Editor.isEditor(parent[0])) {\n            insertBreak()\n            return\n        }\n        const text = Editor.string(editor, block[1])\n        if (text) {\n            insertBreak()\n            return\n        }\n        const blockPath: Path = block[1]\n        let indent = 0\n        if (typeof parent[0].indent === \"number\") {\n            indent = parent[0].indent > 1 ? parent[0].indent - 1 : 0\n        }\n        Transforms.setNodes(editor, {type: 'paragraph', indent}, {at: blockPath})\n        // if it is the last child\n        if (blockPath[blockPath.length - 1] === parent[0].children.length - 1) {\n            Transforms.liftNodes(editor, {at: blockPath})\n            return\n        }\n    }\n    editor.insertBreak = () => {\n        Editor.withoutNormalizing(editor, () => {\n            insertBreak2()\n            fixList(editor)\n        })\n    }\n    editor.insertText = (text: string) => {\n        const {selection} = editor\n        if ((text !== ' ') || !selection || !Range.isCollapsed(selection)) {\n            insertText(text)\n            return\n        }\n\n        const {anchor} = selection\n        const block = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n        })\n        const path = block ? block[1] : []\n        const start = Editor.start(editor, path)\n        const range = {anchor, focus: start}\n        let beforeText = Editor.string(editor, range)\n        let tabs = 0\n        for (let c of beforeText) {\n            if (c === '\\t') {\n                tabs++\n            }\n        }\n        beforeText = beforeText.substr(tabs)\n        const blockType = block![0].type as string\n        let inList = typeof blockType === 'string' ? blockType === 'list-item' : false\n\n\n        let type = SHORTCUTS[beforeText]\n\n        if (!type && /^[1-9]\\d*\\./.test(beforeText)) {\n            type = 'ol-item'\n        }\n        let list\n        switch (type) {\n            case 'ul-item':\n                if (inList) {\n                    insertText(text)\n                    break\n                }\n                Transforms.select(editor, range)\n                Transforms.delete(editor)\n                Transforms.setNodes(\n                    editor,\n                    {type: 'list-item'},\n                    {match: n => Editor.isBlock(editor, n)}\n                )\n                list = {type: 'bulleted-list', indent: tabs, children: []}\n                Transforms.wrapNodes(editor, list, {\n                    match: n => n.type === 'list-item',\n                })\n                fixList(editor)\n                break\n            case 'ol-item':\n                if (inList) {\n                    insertText(text)\n                    break\n                }\n                const found = beforeText.match(/^([\\t]*)\\d+\\./)\n                Transforms.select(editor, range)\n                Transforms.delete(editor)\n                Transforms.setNodes(\n                    editor,\n                    {type: 'list-item'},\n                    {match: n => Editor.isBlock(editor, n)}\n                )\n                list = {type: 'numbered-list', indent: tabs, children: []}\n                Transforms.wrapNodes(editor, list, {\n                    match: n => n.type === 'list-item',\n                })\n                fixList(editor)\n                break\n            case 'block-quote':\n                if (inList || blockType !== 'paragraph') {\n                    insertText(text)\n                    break\n                }\n                let parent = Editor.above(editor, {match: n => n.type === 'block-quote'})\n                if (parent) {\n                    insertText(text)\n                    break\n                }\n                Transforms.select(editor, range)\n                Transforms.delete(editor)\n                Transforms.wrapNodes(editor, {type: 'block-quote', children: []}, {\n                    match: n => n.type === 'paragraph'\n                })\n                break\n            default:\n                insertText(text)\n        }\n        return\n    }\n\n    const deleteBackward2 = (unit: 'character' | 'word' | 'line' | 'block') => {\n        console.log(\"editor.deleteBackward:\", unit)\n        const {selection} = editor\n\n        if (!selection || Range.isExpanded(selection)) {\n            deleteBackward(unit)\n            return\n        }\n        const match = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n        })\n\n        if (!match || Editor.isEditor(match[0])) {\n            deleteBackward(unit)\n            return\n        }\n        const [block, path] = match as NodeEntry<ListNode>\n        const start = Editor.start(editor, path)\n\n        if (Point.equals(selection.anchor, start)) {\n            if (block.type === 'list-item') {\n                const [listNode] = Editor.parent(editor, path) as NodeEntry<ListNode>\n                if (listNode && (listNode.indent as number > 0)) {\n                    Editor.withoutNormalizing(editor, () => {\n                        Transforms.wrapNodes(editor, {\n                            type: listNode.type,\n                            indent: listNode.indent! - 1,\n                            children: []\n                        }, {at: path})\n                        Transforms.liftNodes(editor, {at: path})\n                    })\n                } else {\n                    Transforms.setNodes(editor, {type: 'paragraph'})\n                    Transforms.unwrapNodes(editor, {\n                        match: n => (typeof n.type === 'string' && n.type.endsWith('-list')),\n                        split: true,\n                    })\n                    // deleteBackward(unit)\n                }\n            } else if (block.type === 'paragraph') {\n                if (block.indent && block.indent > 0) {\n                    Transforms.setNodes(editor, {indent: block.indent - 1}, {at: path})\n                    return\n                } else {\n                    deleteBackward(unit)\n                }\n            } else {\n                Transforms.setNodes(editor, {type: 'paragraph'})\n            }\n            return\n        } // end if at start\n        deleteBackward(unit)\n    }\n\n    editor.deleteBackward = (unit: 'character' | 'word' | 'line' | 'block') => {\n        Editor.withoutNormalizing(editor, () => {\n            deleteBackward2(unit)\n            fixList(editor)\n        })\n    }\n\n    editor.deleteFragment = () => {\n        // console.log(\"editor.deleteFragment:\")\n        deleteFragment()\n    }\n    editor.normalizeNode = (entry: NodeEntry) => {\n        if (Element.isElement(entry[0]) && entry[0].type !== 'list-item') {\n            const [pNode] = Editor.parent(editor, entry[1])!\n            if (isListNode(pNode)) {\n                Transforms.setNodes(editor, {type: 'list-item'}, {at: entry[1]})\n            }\n        }\n        normalizeNode(entry)\n    }\n\n    return editor\n}\n\nconst beforeTextInBlock = (editor: Editor): string => {\n    const {selection} = editor\n    if (!selection) {\n        return ''\n    }\n    const block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n    })\n    const path = block ? block[1] : []\n    const start = Editor.start(editor, path)\n    const range = {anchor: Range.start(editor.selection!), focus: start}\n    let beforeText = Editor.string(editor, range)\n    return beforeText\n}\n//\n// Transforms.delete =(\n//     editor: Editor,\n//     options: {\n//     at?: Location\n//     distance?: number\n//     unit?: 'character' | 'word' | 'line' | 'block'\n//     reverse?: boolean\n//     hanging?: boolean\n//     voids?: boolean\n// } = {}\n// ):void => {\n//     Editor.withoutNormalizing(editor, () => {\n//         const {\n//             reverse = false,\n//             unit = 'character',\n//             distance = 1,\n//             voids = false,\n//         } = options\n//         let { at = editor.selection, hanging = false } = options\n//\n//         if (!at) {\n//             return\n//         }\n//\n//         if (Range.isRange(at) && Range.isCollapsed(at)) {\n//             at = at.anchor\n//         }\n//\n//         if (Point.isPoint(at)) {\n//             const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n//\n//             if (!voids && furthestVoid) {\n//                 const [, voidPath] = furthestVoid\n//                 at = voidPath\n//             } else {\n//                 const opts = { unit, distance }\n//                 const target = reverse\n//                     ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n//                     : Editor.after(editor, at, opts) || Editor.end(editor, [])\n//                 at = { anchor: at, focus: target }\n//                 hanging = true\n//             }\n//         }\n//\n//         if (Path.isPath(at)) {\n//             Transforms.removeNodes(editor, { at, voids })\n//             return\n//         }\n//\n//         if (Range.isCollapsed(at)) {\n//             return\n//         }\n//\n//         if (!hanging) {\n//             at = Editor.unhangRange(editor, at, { voids })\n//         }\n//\n//         let [start, end] = Range.edges(at)\n//         const startBlock = Editor.above(editor, {\n//             match: n => Editor.isBlock(editor, n),\n//             at: start,\n//             voids,\n//         })\n//         const endBlock = Editor.above(editor, {\n//             match: n => Editor.isBlock(editor, n),\n//             at: end,\n//             voids,\n//         })\n//         const isAcrossBlocks =\n//             startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n//         const isSingleText = Path.equals(start.path, end.path)\n//         const startVoid = voids\n//             ? null\n//             : Editor.void(editor, { at: start, mode: 'highest' })\n//         const endVoid = voids\n//             ? null\n//             : Editor.void(editor, { at: end, mode: 'highest' })\n//\n//         // If the start or end points are inside an inline void, nudge them out.\n//         if (startVoid) {\n//             const before = Editor.before(editor, start)\n//\n//             if (\n//                 before &&\n//                 startBlock &&\n//                 Path.isAncestor(startBlock[1], before.path)\n//             ) {\n//                 start = before\n//             }\n//         }\n//\n//         if (endVoid) {\n//             const after = Editor.after(editor, end)\n//\n//             if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n//                 end = after\n//             }\n//         }\n//\n//         // Get the highest nodes that are completely inside the range, as well as\n//         // the start and end nodes.\n//         const matches: NodeEntry[] = []\n//         let lastPath: Path | undefined\n//\n//         for (const entry of Editor.nodes(editor, { at, voids })) {\n//             const [node, path] = entry\n//\n//             if (lastPath && Path.compare(path, lastPath) === 0) {\n//                 continue\n//             }\n//\n//             if (\n//                 (!voids && Editor.isVoid(editor, node)) ||\n//                 (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n//             ) {\n//                 matches.push(entry)\n//                 lastPath = path\n//             }\n//         }\n//\n//         const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n//         const startRef = Editor.pointRef(editor, start)\n//         const endRef = Editor.pointRef(editor, end)\n//\n//         if (!isSingleText && !startVoid) {\n//             const point = startRef.current!\n//             const [node] = Editor.leaf(editor, point)\n//             const { path } = point\n//             const { offset } = start\n//             const text = node.text.slice(offset)\n//             editor.apply({ type: 'remove_text', path, offset, text })\n//         }\n//\n//         for (const pathRef of pathRefs) {\n//             const path = pathRef.unref()!\n//             console.log(\"remove not at:\", path)\n//             Transforms.removeNodes(editor, { at: path, voids })\n//         }\n//\n//         if (!endVoid) {\n//             const point = endRef.current!\n//             const [node] = Editor.leaf(editor, point)\n//             const { path } = point\n//             const offset = isSingleText ? start.offset : 0\n//             const text = node.text.slice(offset, end.offset)\n//             editor.apply({ type: 'remove_text', path, offset, text })\n//         }\n//\n//         if (\n//             !isSingleText &&\n//             isAcrossBlocks &&\n//             endRef.current &&\n//             startRef.current\n//         ) {\n//             console.log(\"merge node at:\", endRef.current)\n//             Transforms.mergeNodes(editor, {\n//                 at: endRef.current,\n//                 hanging: true,\n//                 voids,\n//             })\n//         }\n//\n//         const point = endRef.unref() || startRef.unref()\n//\n//         if (options.at == null && point) {\n//             Transforms.select(editor, point)\n//         }\n//     })\n// }\n//\n// Transforms.mergeNodes = (\n//     editor: Editor,\n//     options: {\n//     at?: Location\n//     match?: (node: Node) => boolean\n//     mode?: 'highest' | 'lowest'\n//     hanging?: boolean\n//     voids?: boolean\n// } = {}\n// ) => {\n//     Editor.withoutNormalizing(editor, () => {\n//         let { match, at = editor.selection } = options\n//         const { hanging = false, voids = false, mode = 'lowest' } = options\n//\n//         if (!at) {\n//             return\n//         }\n//\n//         if (match == null) {\n//             if (Path.isPath(at)) {\n//                 const [parent] = Editor.parent(editor, at)\n//                 match = n => parent.children.includes(n)\n//             } else {\n//                 match = n => Editor.isBlock(editor, n)\n//             }\n//         }\n//\n//         if (!hanging && Range.isRange(at)) {\n//             at = Editor.unhangRange(editor, at)\n//         }\n//\n//         if (Range.isRange(at)) {\n//             if (Range.isCollapsed(at)) {\n//                 at = at.anchor\n//             } else {\n//                 const [, end] = Range.edges(at)\n//                 const pointRef = Editor.pointRef(editor, end)\n//                 Transforms.delete(editor, { at })\n//                 at = pointRef.unref()!\n//\n//                 if (options.at == null) {\n//                     Transforms.select(editor, at)\n//                 }\n//             }\n//         }\n//\n//         const [current] = Editor.nodes(editor, { at, match, voids, mode })\n//         const prev = Editor.previous(editor, { at, match, voids, mode })\n//\n//         if (!current || !prev) {\n//             return\n//         }\n//\n//         const [node, path] = current\n//         const [prevNode, prevPath] = prev\n//\n//         if (path.length === 0 || prevPath.length === 0) {\n//             return\n//         }\n//\n//         const newPath = Path.next(prevPath)\n//         const commonPath = Path.common(path, prevPath)\n//         const isPreviousSibling = Path.isSibling(path, prevPath)\n//         const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\n//             .slice(commonPath.length)\n//             .slice(0, -1)\n//\n//         // Determine if the merge will leave an ancestor of the path empty as a\n//         // result, in which case we'll want to remove it after merging.\n//         const emptyAncestor = Editor.above(editor, {\n//             at: path,\n//             mode: 'highest',\n//             match: n =>\n//                 levels.includes(n) && Element.isElement(n) && n.children.length === 1,\n//         })\n//\n//         const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n//         let properties\n//         let position\n//\n//         // Ensure that the nodes are equivalent, and figure out what the position\n//         // and extra properties of the merge will be.\n//         if (Text.isText(node) && Text.isText(prevNode)) {\n//             const { text, ...rest } = node\n//             position = prevNode.text.length\n//             properties = rest as Partial<Text>\n//         } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n//             const { children, ...rest } = node\n//             position = prevNode.children.length\n//             properties = rest as Partial<Element>\n//         } else {\n//             throw new Error(\n//                 `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n//                     node\n//                 )} ${JSON.stringify(prevNode)}`\n//             )\n//         }\n//\n//         // If the node isn't already the next sibling of the previous node, move\n//         // it so that it is before merging.\n//         if (!isPreviousSibling) {\n//             console.log(\"In merge, movNodes from \", path, \"to\", newPath)\n//             Transforms.moveNodes(editor, { at: path, to: newPath, voids })\n//         }\n//\n//         // If there was going to be an empty ancestor of the node that was merged,\n//         // we remove it from the tree.\n//         if (emptyRef) {\n//             console.log(\"In merge, remove node at:\", emptyRef.current)\n//             Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\n//         }\n//\n//         // If the target node that we're merging with is empty, remove it instead\n//         // of merging the two. This is a common rich text editor behavior to\n//         // prevent losing formatting when deleting entire nodes when you have a\n//         // hanging selection.\n//         if (\n//             (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n//             (Text.isText(prevNode) && prevNode.text === '')\n//         ) {\n//             console.log(\"In merge, remove2\", prevNode.type, \"node at:\", prevPath)\n//             Transforms.removeNodes(editor, { at: prevPath, voids })\n//         } else {\n//             editor.apply({\n//                 type: 'merge_node',\n//                 path: newPath,\n//                 position,\n//                 properties,\n//             })\n//         }\n//\n//         if (emptyRef) {\n//             emptyRef.unref()\n//         }\n//     })\n// }"]},"metadata":{},"sourceType":"module"}