{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nvar __jsx = React.createElement;\nimport React, { useState, useCallback, useMemo } from 'react';\nimport { Slate, Editable, withReact } from 'slate-react';\nimport { Editor, Transforms, Range, Point, createEditor } from 'slate';\nimport { withHistory } from 'slate-history';\nvar SHORTCUTS = {\n  '*': 'list-item',\n  '-': 'list-item',\n  '+': 'list-item',\n  '>': 'block-quote',\n  '#': 'heading-one',\n  '##': 'heading-two',\n  '###': 'heading-three',\n  '####': 'heading-four',\n  '#####': 'heading-five',\n  '######': 'heading-six'\n};\n\nvar MarkdownShortcutsExample = function MarkdownShortcutsExample() {\n  var _useState = useState(initialValue),\n      value = _useState[0],\n      setValue = _useState[1];\n\n  var renderElement = useCallback(function (props) {\n    return __jsx(Element, props);\n  }, []);\n  var editor = useMemo(function () {\n    return withShortcuts(withReact(withHistory(createEditor())));\n  }, []);\n  return __jsx(Slate, {\n    editor: editor,\n    value: value,\n    onChange: function onChange(value) {\n      return setValue(value);\n    }\n  }, __jsx(Editable, {\n    renderElement: renderElement,\n    placeholder: \"Write some markdown...\",\n    spellCheck: true,\n    autoFocus: true\n  }));\n};\n\nvar withShortcuts = function withShortcuts(editor) {\n  var deleteBackward = editor.deleteBackward,\n      insertText = editor.insertText;\n\n  editor.insertText = function (text) {\n    var selection = editor.selection;\n\n    if (text === ' ' && selection && Range.isCollapsed(selection)) {\n      var anchor = selection.anchor;\n      var block = Editor.above(editor, {\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        }\n      });\n      var path = block ? block[1] : [];\n      var start = Editor.start(editor, path);\n      var range = {\n        anchor: anchor,\n        focus: start\n      };\n      var beforeText = Editor.string(editor, range);\n      var type = SHORTCUTS[beforeText];\n\n      if (type) {\n        Transforms.select(editor, range);\n        Transforms[\"delete\"](editor);\n        Transforms.setNodes(editor, {\n          type: type\n        }, {\n          match: function match(n) {\n            return Editor.isBlock(editor, n);\n          }\n        });\n\n        if (type === 'list-item') {\n          var list = {\n            type: 'bulleted-list',\n            children: []\n          };\n          Transforms.wrapNodes(editor, list, {\n            match: function match(n) {\n              return n.type === 'list-item';\n            }\n          });\n        }\n\n        return;\n      }\n    }\n\n    insertText(text);\n  };\n\n  editor.deleteBackward = function () {\n    var selection = editor.selection;\n\n    if (selection && Range.isCollapsed(selection)) {\n      var match = Editor.above(editor, {\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        }\n      });\n\n      if (match) {\n        var _match = _slicedToArray(match, 2),\n            block = _match[0],\n            path = _match[1];\n\n        var start = Editor.start(editor, path);\n\n        if (block.type !== 'paragraph' && Point.equals(selection.anchor, start)) {\n          Transforms.setNodes(editor, {\n            type: 'paragraph'\n          });\n\n          if (block.type === 'list-item') {\n            Transforms.unwrapNodes(editor, {\n              match: function match(n) {\n                return n.type === 'bulleted-list';\n              },\n              split: true\n            });\n          }\n\n          return;\n        }\n      }\n\n      deleteBackward.apply(void 0, arguments);\n    }\n  };\n\n  return editor;\n};\n\nvar Element = function Element(_ref) {\n  var attributes = _ref.attributes,\n      children = _ref.children,\n      element = _ref.element;\n\n  switch (element.type) {\n    case 'block-quote':\n      return __jsx(\"blockquote\", attributes, children);\n\n    case 'bulleted-list':\n      return __jsx(\"ul\", attributes, children);\n\n    case 'heading-one':\n      return __jsx(\"h1\", attributes, children);\n\n    case 'heading-two':\n      return __jsx(\"h2\", attributes, children);\n\n    case 'heading-three':\n      return __jsx(\"h3\", attributes, children);\n\n    case 'heading-four':\n      return __jsx(\"h4\", attributes, children);\n\n    case 'heading-five':\n      return __jsx(\"h5\", attributes, children);\n\n    case 'heading-six':\n      return __jsx(\"h6\", attributes, children);\n\n    case 'list-item':\n      return __jsx(\"li\", attributes, children);\n\n    default:\n      return __jsx(\"p\", attributes, children);\n  }\n};\n\nvar initialValue = [{\n  type: 'paragraph',\n  children: [{\n    text: 'The editor gives you full control over the logic you can add. For example, it\\'s fairly common to want to add markdown-like shortcuts to editors. So that, when you start a line with \"> \" you get a blockquote that looks like this:'\n  }]\n}, {\n  type: 'block-quote',\n  children: [{\n    text: 'A wise quote.'\n  }]\n}, {\n  type: 'paragraph',\n  children: [{\n    text: 'Order when you start a line with \"## \" you get a level-two heading, like this:'\n  }]\n}, {\n  type: 'heading-two',\n  children: [{\n    text: 'Try it out!'\n  }]\n}, {\n  type: 'paragraph',\n  children: [{\n    text: 'Try it out for yourself! Try starting a new line with \">\", \"-\", or \"#\"s.'\n  }]\n}];\nexport default MarkdownShortcutsExample;","map":null,"metadata":{},"sourceType":"module"}