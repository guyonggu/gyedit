{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React, { useState, useCallback, useMemo } from 'react';\nimport { Slate, Editable, withReact } from 'slate-react';\nimport { Text, createEditor } from 'slate';\nimport { css } from 'emotion';\nimport { withHistory } from 'slate-history';\nimport { Icon, Toolbar } from '../components';\n\nconst SearchHighlightingExample = () => {\n  const {\n    0: value,\n    1: setValue\n  } = useState(initialValue);\n  const {\n    0: search,\n    1: setSearch\n  } = useState();\n  const editor = useMemo(() => withHistory(withReact(createEditor())), []);\n  const decorate = useCallback(([node, path]) => {\n    const ranges = [];\n\n    if (search && Text.isText(node)) {\n      const {\n        text\n      } = node;\n      const parts = text.split(search);\n      let offset = 0;\n      parts.forEach((part, i) => {\n        if (i !== 0) {\n          ranges.push({\n            anchor: {\n              path,\n              offset: offset - search.length\n            },\n            focus: {\n              path,\n              offset\n            },\n            highlight: true\n          });\n        }\n\n        offset = offset + part.length + search.length;\n      });\n    }\n\n    return ranges;\n  }, [search]);\n  return __jsx(Slate, {\n    editor: editor,\n    value: value,\n    onChange: value => setValue(value)\n  }, __jsx(Toolbar, null, __jsx(\"div\", {\n    className: css`\n            position: relative;\n          `\n  }, __jsx(Icon, {\n    className: css`\n              position: absolute;\n              top: 0.5em;\n              left: 0.5em;\n              color: #ccc;\n            `\n  }, \"search\"), __jsx(\"input\", {\n    type: \"search\",\n    placeholder: \"Search the text...\",\n    onChange: e => setSearch(e.target.value),\n    className: css`\n              padding-left: 2em;\n              width: 100%;\n            `\n  }))), __jsx(Editable, {\n    decorate: decorate,\n    renderLeaf: props => __jsx(Leaf, props)\n  }));\n};\n\nconst Leaf = ({\n  attributes,\n  children,\n  leaf\n}) => {\n  return __jsx(\"span\", _extends({}, attributes, {\n    className: css`\n        font-weight: ${leaf.bold && 'bold'};\n        background-color: ${leaf.highlight && '#ffeeba'};\n      `\n  }), children);\n};\n\nconst initialValue = [{\n  children: [{\n    text: 'This is editable text that you can search. As you search, it looks for matching strings of text, and adds '\n  }, {\n    text: 'decorations',\n    bold: true\n  }, {\n    text: ' to them in realtime.'\n  }]\n}, {\n  children: [{\n    text: 'Try it out for yourself by typing in the search box above!'\n  }]\n}];\nexport default SearchHighlightingExample;","map":null,"metadata":{},"sourceType":"module"}