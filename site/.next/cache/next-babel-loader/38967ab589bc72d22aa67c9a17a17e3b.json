{"ast":null,"code":"var _jsxFileName = \"/Users/yonggu/WebstormProjects/slate/site/examples/search-highlighting.tsx\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React, { useState, useCallback, useMemo } from 'react';\nimport { Slate, Editable, withReact } from 'slate-react';\nimport { Text, createEditor } from 'slate';\nimport { css } from 'emotion';\nimport { withHistory } from 'slate-history';\nimport { Icon, Toolbar } from '../components';\n\nconst SearchHighlightingExample = () => {\n  const {\n    0: value,\n    1: setValue\n  } = useState(initialValue);\n  const {\n    0: search,\n    1: setSearch\n  } = useState();\n  const editor = useMemo(() => withHistory(withReact(createEditor())), []);\n  const decorate = useCallback(([node, path]) => {\n    const ranges = [];\n\n    if (search && Text.isText(node)) {\n      const {\n        text\n      } = node;\n      const parts = text.split(search);\n      let offset = 0;\n      parts.forEach((part, i) => {\n        if (i !== 0) {\n          ranges.push({\n            anchor: {\n              path,\n              offset: offset - search.length\n            },\n            focus: {\n              path,\n              offset\n            },\n            highlight: true\n          });\n        }\n\n        offset = offset + part.length + search.length;\n      });\n    }\n\n    return ranges;\n  }, [search]);\n  return __jsx(Slate, {\n    editor: editor,\n    value: value,\n    onChange: value => setValue(value),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 41,\n      columnNumber: 5\n    }\n  }, __jsx(Toolbar, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 42,\n      columnNumber: 7\n    }\n  }, __jsx(\"div\", {\n    className: css`\n            position: relative;\n          `,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 43,\n      columnNumber: 9\n    }\n  }, __jsx(Icon, {\n    className: css`\n              position: absolute;\n              top: 0.5em;\n              left: 0.5em;\n              color: #ccc;\n            `,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 48,\n      columnNumber: 11\n    }\n  }, \"search\"), __jsx(\"input\", {\n    type: \"search\",\n    placeholder: \"Search the text...\",\n    onChange: e => setSearch(e.target.value),\n    className: css`\n              padding-left: 2em;\n              width: 100%;\n            `,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 58,\n      columnNumber: 11\n    }\n  }))), __jsx(Editable, {\n    decorate: decorate,\n    renderLeaf: props => __jsx(Leaf, _extends({}, props, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 69,\n        columnNumber: 58\n      }\n    })),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 69,\n      columnNumber: 7\n    }\n  }));\n};\n\nconst Leaf = ({\n  attributes,\n  children,\n  leaf\n}) => {\n  return __jsx(\"span\", _extends({}, attributes, {\n    className: css`\n        font-weight: ${leaf.bold && 'bold'};\n        background-color: ${leaf.highlight && '#ffeeba'};\n      `,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 76,\n      columnNumber: 5\n    }\n  }), children);\n};\n\nconst initialValue = [{\n  children: [{\n    text: 'This is editable text that you can search. As you search, it looks for matching strings of text, and adds '\n  }, {\n    text: 'decorations',\n    bold: true\n  }, {\n    text: ' to them in realtime.'\n  }]\n}, {\n  children: [{\n    text: 'Try it out for yourself by typing in the search box above!'\n  }]\n}];\nexport default SearchHighlightingExample;","map":{"version":3,"sources":["/Users/yonggu/WebstormProjects/slate/site/examples/search-highlighting.tsx"],"names":["React","useState","useCallback","useMemo","Slate","Editable","withReact","Text","createEditor","css","withHistory","Icon","Toolbar","SearchHighlightingExample","value","setValue","initialValue","search","setSearch","editor","decorate","node","path","ranges","isText","text","parts","split","offset","forEach","part","i","push","anchor","length","focus","highlight","e","target","props","Leaf","attributes","children","leaf","bold"],"mappings":"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","sourcesContent":["import React, { useState, useCallback, useMemo } from 'react'\nimport { Slate, Editable, withReact } from 'slate-react'\nimport { Text, Node, createEditor } from 'slate'\nimport { css } from 'emotion'\nimport { withHistory } from 'slate-history'\n\nimport { Icon, Toolbar } from '../components'\n\nconst SearchHighlightingExample = () => {\n  const [value, setValue] = useState<Node[]>(initialValue)\n  const [search, setSearch] = useState<string | undefined>()\n  const editor = useMemo(() => withHistory(withReact(createEditor())), [])\n  const decorate = useCallback(\n    ([node, path]) => {\n      const ranges = []\n\n      if (search && Text.isText(node)) {\n        const { text } = node\n        const parts = text.split(search)\n        let offset = 0\n\n        parts.forEach((part, i) => {\n          if (i !== 0) {\n            ranges.push({\n              anchor: { path, offset: offset - search.length },\n              focus: { path, offset },\n              highlight: true,\n            })\n          }\n\n          offset = offset + part.length + search.length\n        })\n      }\n\n      return ranges\n    },\n    [search]\n  )\n\n  return (\n    <Slate editor={editor} value={value} onChange={value => setValue(value)}>\n      <Toolbar>\n        <div\n          className={css`\n            position: relative;\n          `}\n        >\n          <Icon\n            className={css`\n              position: absolute;\n              top: 0.5em;\n              left: 0.5em;\n              color: #ccc;\n            `}\n          >\n            search\n          </Icon>\n          <input\n            type=\"search\"\n            placeholder=\"Search the text...\"\n            onChange={e => setSearch(e.target.value)}\n            className={css`\n              padding-left: 2em;\n              width: 100%;\n            `}\n          />\n        </div>\n      </Toolbar>\n      <Editable decorate={decorate} renderLeaf={props => <Leaf {...props} />} />\n    </Slate>\n  )\n}\n\nconst Leaf = ({ attributes, children, leaf }) => {\n  return (\n    <span\n      {...attributes}\n      className={css`\n        font-weight: ${leaf.bold && 'bold'};\n        background-color: ${leaf.highlight && '#ffeeba'};\n      `}\n    >\n      {children}\n    </span>\n  )\n}\n\nconst initialValue = [\n  {\n    children: [\n      {\n        text:\n          'This is editable text that you can search. As you search, it looks for matching strings of text, and adds ',\n      },\n      { text: 'decorations', bold: true },\n      { text: ' to them in realtime.' },\n    ],\n  },\n  {\n    children: [\n      { text: 'Try it out for yourself by typing in the search box above!' },\n    ],\n  },\n]\n\nexport default SearchHighlightingExample\n"]},"metadata":{},"sourceType":"module"}