{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React, { useState, useCallback, useMemo } from 'react';\nimport { jsx } from 'slate-hyperscript';\nimport { Transforms, createEditor } from 'slate';\nimport { withHistory } from 'slate-history';\nimport { css } from 'emotion';\nimport { Slate, Editable, withReact, useSelected, useFocused } from 'slate-react';\nconst ELEMENT_TAGS = {\n  A: el => ({\n    type: 'link',\n    url: el.getAttribute('href')\n  }),\n  BLOCKQUOTE: () => ({\n    type: 'quote'\n  }),\n  H1: () => ({\n    type: 'heading-one'\n  }),\n  H2: () => ({\n    type: 'heading-two'\n  }),\n  H3: () => ({\n    type: 'heading-three'\n  }),\n  H4: () => ({\n    type: 'heading-four'\n  }),\n  H5: () => ({\n    type: 'heading-five'\n  }),\n  H6: () => ({\n    type: 'heading-six'\n  }),\n  IMG: el => ({\n    type: 'image',\n    url: el.getAttribute('src')\n  }),\n  LI: () => ({\n    type: 'list-item'\n  }),\n  OL: () => ({\n    type: 'numbered-list'\n  }),\n  P: () => ({\n    type: 'paragraph'\n  }),\n  PRE: () => ({\n    type: 'code'\n  }),\n  UL: () => ({\n    type: 'bulleted-list'\n  })\n}; // COMPAT: `B` is omitted here because Google Docs uses `<b>` in weird ways.\n\nconst TEXT_TAGS = {\n  CODE: () => ({\n    code: true\n  }),\n  DEL: () => ({\n    strikethrough: true\n  }),\n  EM: () => ({\n    italic: true\n  }),\n  I: () => ({\n    italic: true\n  }),\n  S: () => ({\n    strikethrough: true\n  }),\n  STRONG: () => ({\n    bold: true\n  }),\n  U: () => ({\n    underline: true\n  })\n};\nexport const deserialize = el => {\n  if (el.nodeType === 3) {\n    return el.textContent;\n  } else if (el.nodeType !== 1) {\n    return null;\n  } else if (el.nodeName === 'BR') {\n    return '\\n';\n  }\n\n  const {\n    nodeName\n  } = el;\n  let parent = el;\n\n  if (nodeName === 'PRE' && el.childNodes[0] && el.childNodes[0].nodeName === 'CODE') {\n    parent = el.childNodes[0];\n  }\n\n  const children = Array.from(parent.childNodes).map(deserialize).flat();\n\n  if (el.nodeName === 'BODY') {\n    return jsx('fragment', {}, children);\n  }\n\n  if (ELEMENT_TAGS[nodeName]) {\n    const attrs = ELEMENT_TAGS[nodeName](el);\n    return jsx('element', attrs, children);\n  }\n\n  if (TEXT_TAGS[nodeName]) {\n    const attrs = TEXT_TAGS[nodeName](el);\n    return children.map(child => jsx('text', attrs, child));\n  }\n\n  return children;\n};\n\nconst PasteHtmlExample = () => {\n  const {\n    0: value,\n    1: setValue\n  } = useState(initialValue);\n  const renderElement = useCallback(props => __jsx(Element, props), []);\n  const renderLeaf = useCallback(props => __jsx(Leaf, props), []);\n  const editor = useMemo(() => withHtml(withReact(withHistory(createEditor()))), []);\n  return __jsx(Slate, {\n    editor: editor,\n    value: value,\n    onChange: value => setValue(value)\n  }, __jsx(Editable, {\n    renderElement: renderElement,\n    renderLeaf: renderLeaf,\n    placeholder: \"Paste in some HTML...\"\n  }));\n};\n\nconst withHtml = editor => {\n  const {\n    insertData,\n    isInline,\n    isVoid\n  } = editor;\n\n  editor.isInline = element => {\n    return element.type === 'link' ? true : isInline(element);\n  };\n\n  editor.isVoid = element => {\n    return element.type === 'image' ? true : isVoid(element);\n  };\n\n  editor.insertData = data => {\n    const html = data.getData('text/html');\n\n    if (html) {\n      const parsed = new DOMParser().parseFromString(html, 'text/html');\n      const fragment = deserialize(parsed.body);\n      Transforms.insertFragment(editor, fragment);\n      return;\n    }\n\n    insertData(data);\n  };\n\n  return editor;\n};\n\nconst Element = props => {\n  const {\n    attributes,\n    children,\n    element\n  } = props;\n\n  switch (element.type) {\n    default:\n      return __jsx(\"p\", attributes, children);\n\n    case 'quote':\n      return __jsx(\"blockquote\", attributes, children);\n\n    case 'code':\n      return __jsx(\"pre\", null, __jsx(\"code\", attributes, children));\n\n    case 'bulleted-list':\n      return __jsx(\"ul\", attributes, children);\n\n    case 'heading-one':\n      return __jsx(\"h1\", attributes, children);\n\n    case 'heading-two':\n      return __jsx(\"h2\", attributes, children);\n\n    case 'heading-three':\n      return __jsx(\"h3\", attributes, children);\n\n    case 'heading-four':\n      return __jsx(\"h4\", attributes, children);\n\n    case 'heading-five':\n      return __jsx(\"h5\", attributes, children);\n\n    case 'heading-six':\n      return __jsx(\"h6\", attributes, children);\n\n    case 'list-item':\n      return __jsx(\"li\", attributes, children);\n\n    case 'numbered-list':\n      return __jsx(\"ol\", attributes, children);\n\n    case 'link':\n      return __jsx(\"a\", _extends({\n        href: element.url\n      }, attributes), children);\n\n    case 'image':\n      return __jsx(ImageElement, props);\n  }\n};\n\nconst ImageElement = ({\n  attributes,\n  children,\n  element\n}) => {\n  const selected = useSelected();\n  const focused = useFocused();\n  return __jsx(\"div\", attributes, children, __jsx(\"img\", {\n    src: element.url,\n    className: css`\n          display: block;\n          max-width: 100%;\n          max-height: 20em;\n          box-shadow: ${selected && focused ? '0 0 0 2px blue;' : 'none'};\n        `\n  }));\n};\n\nconst Leaf = ({\n  attributes,\n  children,\n  leaf\n}) => {\n  if (leaf.bold) {\n    children = __jsx(\"strong\", null, children);\n  }\n\n  if (leaf.code) {\n    children = __jsx(\"code\", null, children);\n  }\n\n  if (leaf.italic) {\n    children = __jsx(\"em\", null, children);\n  }\n\n  if (leaf.underline) {\n    children = __jsx(\"u\", null, children);\n  }\n\n  if (leaf.strikethrough) {\n    children = __jsx(\"del\", null, children);\n  }\n\n  return __jsx(\"span\", attributes, children);\n};\n\nconst initialValue = [{\n  children: [{\n    text: \"By default, pasting content into a Slate editor will use the clipboard's \"\n  }, {\n    text: \"'text/plain'\",\n    code: true\n  }, {\n    text: \" data. That's okay for some use cases, but sometimes you want users to be able to paste in content and have it maintaing its formatting. To do this, your editor needs to handle \"\n  }, {\n    text: \"'text/html'\",\n    code: true\n  }, {\n    text: ' data. '\n  }]\n}, {\n  children: [{\n    text: 'This is an example of doing exactly that!'\n  }]\n}, {\n  children: [{\n    text: \"Try it out for yourself! Copy and paste some rendered HTML rich text content (not the source code) from another site into this editor and it's formatting should be preserved.\"\n  }]\n}];\nexport default PasteHtmlExample;","map":null,"metadata":{},"sourceType":"module"}