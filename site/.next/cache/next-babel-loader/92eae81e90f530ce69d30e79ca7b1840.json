{"ast":null,"code":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { Editor, Path, Point, Range, Element, Transforms } from \"slate\";\nimport { fixList } from \"./util\";\nconst SHORTCUTS = {\n  '*': 'ul-item',\n  '-': 'ul-item',\n  '+': 'ul-item',\n  '>': 'block-quote',\n  '#': 'heading-one',\n  '##': 'heading-two',\n  '###': 'heading-three',\n  '####': 'heading-four',\n  '#####': 'heading-five',\n  '######': 'heading-six'\n};\nexport const withMarkdown = editor => {\n  const {\n    deleteBackward,\n    insertText,\n    insertBreak,\n    deleteFragment\n  } = editor;\n\n  const insertBreak2 = () => {\n    let handled = false;\n    const {\n      selection\n    } = editor;\n\n    if (!selection || Range.isExpanded(selection)) {\n      insertBreak();\n      return;\n    }\n\n    const block = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n)\n    });\n\n    if (!block || Editor.isEditor(block[0])) {\n      insertBreak();\n      return;\n    }\n\n    const parent = Editor.parent(editor, block[1]);\n\n    if (!parent || Editor.isEditor(parent[0])) {\n      insertBreak();\n      return;\n    }\n\n    const text = Editor.string(editor, block[1]);\n\n    if (text) {\n      insertBreak();\n      return;\n    }\n\n    const blockPath = block[1];\n    let indent = 0;\n\n    if (typeof parent[0].indent === \"number\") {\n      indent = parent[0].indent > 1 ? parent[0].indent - 1 : 0;\n    }\n\n    Transforms.setNodes(editor, {\n      type: 'paragraph',\n      indent\n    }, {\n      at: blockPath\n    }); // if it is the last child\n\n    if (blockPath[blockPath.length - 1] === parent[0].children.length - 1) {\n      Transforms.liftNodes(editor, {\n        at: blockPath\n      });\n      return;\n    }\n  };\n\n  editor.insertBreak = () => {\n    insertBreak2();\n    fixList(editor);\n  };\n\n  editor.insertText = text => {\n    const {\n      selection\n    } = editor;\n\n    if (text !== ' ' || !selection || !Range.isCollapsed(selection)) {\n      insertText(text);\n      return;\n    }\n\n    const {\n      anchor\n    } = selection;\n    const block = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n)\n    });\n    const path = block ? block[1] : [];\n    const start = Editor.start(editor, path);\n    const range = {\n      anchor,\n      focus: start\n    };\n    let beforeText = Editor.string(editor, range);\n    let tabs = 0;\n\n    for (let c of beforeText) {\n      if (c === '\\t') {\n        tabs++;\n      }\n    }\n\n    beforeText = beforeText.substr(tabs);\n    const blockType = block[0].type;\n    let inList = typeof blockType === 'string' ? blockType === 'list-item' : false;\n    let type = SHORTCUTS[beforeText];\n\n    if (!type && /^[1-9]\\d*\\./.test(beforeText)) {\n      type = 'ol-item';\n    }\n\n    let list;\n\n    switch (type) {\n      case 'ul-item':\n        if (inList) {\n          insertText(text);\n          break;\n        }\n\n        Transforms.select(editor, range);\n        Transforms.delete(editor);\n        Transforms.setNodes(editor, {\n          type: 'list-item'\n        }, {\n          match: n => Editor.isBlock(editor, n)\n        });\n        list = {\n          type: 'bulleted-list',\n          indent: tabs,\n          children: []\n        };\n        Transforms.wrapNodes(editor, list, {\n          match: n => n.type === 'list-item'\n        });\n        fixList(editor);\n        break;\n\n      case 'ol-item':\n        if (inList) {\n          insertText(text);\n          break;\n        }\n\n        const found = beforeText.match(/^([\\t]*)\\d+\\./);\n        Transforms.select(editor, range);\n        Transforms.delete(editor);\n        Transforms.setNodes(editor, {\n          type: 'list-item'\n        }, {\n          match: n => Editor.isBlock(editor, n)\n        });\n        list = {\n          type: 'numbered-list',\n          indent: tabs,\n          children: []\n        };\n        Transforms.wrapNodes(editor, list, {\n          match: n => n.type === 'list-item'\n        });\n        fixList(editor);\n        break;\n\n      case 'block-quote':\n        if (inList || blockType !== 'paragraph') {\n          insertText(text);\n          break;\n        }\n\n        let parent = Editor.above(editor, {\n          match: n => n.type === 'block-quote'\n        });\n\n        if (parent) {\n          insertText(text);\n          break;\n        }\n\n        Transforms.select(editor, range);\n        Transforms.delete(editor);\n        Transforms.wrapNodes(editor, {\n          type: 'block-quote',\n          children: []\n        }, {\n          match: n => n.type === 'paragraph'\n        });\n        break;\n\n      default:\n        insertText(text);\n    }\n\n    return;\n  };\n\n  const deleteBackward2 = unit => {\n    console.log(\"editor.deleteBackward:\", unit);\n    const {\n      selection\n    } = editor;\n\n    if (!selection || Range.isExpanded(selection)) {\n      deleteBackward(unit);\n      return;\n    }\n\n    const match = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n)\n    });\n\n    if (!match || Editor.isEditor(match[0])) {\n      deleteBackward(unit);\n      return;\n    }\n\n    const [block, path] = match;\n    const start = Editor.start(editor, path);\n\n    if (Point.equals(selection.anchor, start)) {\n      if (block.type === 'list-item') {\n        const [listNode] = Editor.parent(editor, path);\n\n        if (listNode && listNode.indent > 0) {\n          Editor.withoutNormalizing(editor, () => {\n            Transforms.wrapNodes(editor, {\n              type: listNode.type,\n              indent: listNode.indent - 1,\n              children: []\n            }, {\n              at: path\n            });\n            Transforms.liftNodes(editor, {\n              at: path\n            });\n          });\n        } else {\n          Transforms.setNodes(editor, {\n            type: 'paragraph'\n          });\n          Transforms.unwrapNodes(editor, {\n            match: n => typeof n.type === 'string' && n.type.endsWith('-list'),\n            split: true\n          }); // deleteBackward(unit)\n        }\n      } else if (block.type === 'paragraph') {\n        if (block.indent && block.indent > 0) {\n          Transforms.setNodes(editor, {\n            indent: block.indent - 1\n          }, {\n            at: path\n          });\n          return;\n        } else {\n          deleteBackward(unit);\n        }\n      } else {\n        Transforms.setNodes(editor, {\n          type: 'paragraph'\n        });\n      }\n\n      return;\n    } // end if at start\n\n\n    deleteBackward(unit);\n  };\n\n  editor.deleteBackward = unit => {\n    console.log(\"editor.deleteBackward:\", unit);\n    deleteBackward2(unit);\n    fixList(editor);\n  };\n\n  editor.deleteFragment = () => {\n    console.log(\"editor.deleteFragment:\");\n    deleteFragment();\n  };\n\n  return editor;\n};\n\nconst beforeTextInBlock = editor => {\n  const {\n    selection\n  } = editor;\n\n  if (!selection) {\n    return '';\n  }\n\n  const block = Editor.above(editor, {\n    match: n => Editor.isBlock(editor, n)\n  });\n  const path = block ? block[1] : [];\n  const start = Editor.start(editor, path);\n  const range = {\n    anchor: Range.start(editor.selection),\n    focus: start\n  };\n  let beforeText = Editor.string(editor, range);\n  return beforeText;\n};\n\nTransforms.delete = (editor, options = {}) => {\n  Editor.withoutNormalizing(editor, () => {\n    const {\n      reverse = false,\n      unit = 'character',\n      distance = 1,\n      voids = false\n    } = options;\n    let {\n      at = editor.selection,\n      hanging = false\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    if (Range.isRange(at) && Range.isCollapsed(at)) {\n      at = at.anchor;\n    }\n\n    if (Point.isPoint(at)) {\n      const furthestVoid = Editor.void(editor, {\n        at,\n        mode: 'highest'\n      });\n\n      if (!voids && furthestVoid) {\n        const [, voidPath] = furthestVoid;\n        at = voidPath;\n      } else {\n        const opts = {\n          unit,\n          distance\n        };\n        const target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n        at = {\n          anchor: at,\n          focus: target\n        };\n        hanging = true;\n      }\n    }\n\n    if (Path.isPath(at)) {\n      Transforms.removeNodes(editor, {\n        at,\n        voids\n      });\n      return;\n    }\n\n    if (Range.isCollapsed(at)) {\n      return;\n    }\n\n    if (!hanging) {\n      at = Editor.unhangRange(editor, at, {\n        voids\n      });\n    }\n\n    let [start, end] = Range.edges(at);\n    const startBlock = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n),\n      at: start,\n      voids\n    });\n    const endBlock = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n),\n      at: end,\n      voids\n    });\n    const isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n    const isSingleText = Path.equals(start.path, end.path);\n    const startVoid = voids ? null : Editor.void(editor, {\n      at: start,\n      mode: 'highest'\n    });\n    const endVoid = voids ? null : Editor.void(editor, {\n      at: end,\n      mode: 'highest'\n    }); // If the start or end points are inside an inline void, nudge them out.\n\n    if (startVoid) {\n      const before = Editor.before(editor, start);\n\n      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n        start = before;\n      }\n    }\n\n    if (endVoid) {\n      const after = Editor.after(editor, end);\n\n      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    } // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n\n\n    const matches = [];\n    let lastPath;\n\n    for (const entry of Editor.nodes(editor, {\n      at,\n      voids\n    })) {\n      const [node, path] = entry;\n\n      if (lastPath && Path.compare(path, lastPath) === 0) {\n        continue;\n      }\n\n      if (!voids && Editor.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n        matches.push(entry);\n        lastPath = path;\n      }\n    }\n\n    const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p));\n    const startRef = Editor.pointRef(editor, start);\n    const endRef = Editor.pointRef(editor, end);\n\n    if (!isSingleText && !startVoid) {\n      const point = startRef.current;\n      const [node] = Editor.leaf(editor, point);\n      const {\n        path\n      } = point;\n      const {\n        offset\n      } = start;\n      const text = node.text.slice(offset);\n      editor.apply({\n        type: 'remove_text',\n        path,\n        offset,\n        text\n      });\n    }\n\n    for (const pathRef of pathRefs) {\n      const path = pathRef.unref();\n      console.log(\"remove not at:\", path);\n      Transforms.removeNodes(editor, {\n        at: path,\n        voids\n      });\n    }\n\n    if (!endVoid) {\n      const point = endRef.current;\n      const [node] = Editor.leaf(editor, point);\n      const {\n        path\n      } = point;\n      const offset = isSingleText ? start.offset : 0;\n      const text = node.text.slice(offset, end.offset);\n      editor.apply({\n        type: 'remove_text',\n        path,\n        offset,\n        text\n      });\n    }\n\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      console.log(\"merge node at:\", at);\n      Transforms.mergeNodes(editor, {\n        at: endRef.current,\n        hanging: true,\n        voids\n      });\n    }\n\n    const point = endRef.unref() || startRef.unref();\n\n    if (options.at == null && point) {\n      Transforms.select(editor, point);\n    }\n  });\n};\n\nTransforms.mergeNodes = (editor, options = {}) => {\n  Editor.withoutNormalizing(editor, () => {\n    let {\n      match,\n      at = editor.selection\n    } = options;\n    const {\n      hanging = false,\n      voids = false,\n      mode = 'lowest'\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at);\n\n        match = n => parent.children.includes(n);\n      } else {\n        match = n => Editor.isBlock(editor, n);\n      }\n    }\n\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at);\n    }\n\n    if (Range.isRange(at)) {\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        const [, end] = Range.edges(at);\n        const pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n          at\n        });\n        at = pointRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n    }\n\n    const [current] = Editor.nodes(editor, {\n      at,\n      match,\n      voids,\n      mode\n    });\n    const prev = Editor.previous(editor, {\n      at,\n      match,\n      voids,\n      mode\n    });\n\n    if (!current || !prev) {\n      return;\n    }\n\n    const [node, path] = current;\n    const [prevNode, prevPath] = prev;\n\n    if (path.length === 0 || prevPath.length === 0) {\n      return;\n    }\n\n    const newPath = Path.next(prevPath);\n    const commonPath = Path.common(path, prevPath);\n    const isPreviousSibling = Path.isSibling(path, prevPath);\n    const levels = Array.from(Editor.levels(editor, {\n      at: path\n    }), ([n]) => n).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n    // result, in which case we'll want to remove it after merging.\n\n    const emptyAncestor = Editor.above(editor, {\n      at: path,\n      mode: 'highest',\n      match: n => levels.includes(n) && Element.isElement(n) && n.children.length === 1\n    });\n    const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n    let properties;\n    let position; // Ensure that the nodes are equivalent, and figure out what the position\n    // and extra properties of the merge will be.\n\n    if (Text.isText(node) && Text.isText(prevNode)) {\n      const {\n        text\n      } = node,\n            rest = _objectWithoutProperties(node, [\"text\"]);\n\n      position = prevNode.text.length;\n      properties = rest;\n    } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n      const {\n        children\n      } = node,\n            rest = _objectWithoutProperties(node, [\"children\"]);\n\n      position = prevNode.children.length;\n      properties = rest;\n    } else {\n      throw new Error(`Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(node)} ${JSON.stringify(prevNode)}`);\n    } // If the node isn't already the next sibling of the previous node, move\n    // it so that it is before merging.\n\n\n    if (!isPreviousSibling) {\n      console.log(\"In merge, movNodes from \", at, \"to\", newPath);\n      Transforms.moveNodes(editor, {\n        at: path,\n        to: newPath,\n        voids\n      });\n    } // If there was going to be an empty ancestor of the node that was merged,\n    // we remove it from the tree.\n\n\n    if (emptyRef) {\n      console.log(\"In merge, remove node at:\", emptyRef.current);\n      Transforms.removeNodes(editor, {\n        at: emptyRef.current,\n        voids\n      });\n    } // If the target node that we're merging with is empty, remove it instead\n    // of merging the two. This is a common rich text editor behavior to\n    // prevent losing formatting when deleting entire nodes when you have a\n    // hanging selection.\n\n\n    if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '') {\n      console.log(\"In merge, remove2 node at:\", emptyRef.current);\n      Transforms.removeNodes(editor, {\n        at: prevPath,\n        voids\n      });\n    } else {\n      editor.apply({\n        type: 'merge_node',\n        path: newPath,\n        position,\n        properties\n      });\n    }\n\n    if (emptyRef) {\n      emptyRef.unref();\n    }\n  });\n};","map":{"version":3,"sources":["/Users/yonggu/WebstormProjects/gyedit/src/withMarkdown.ts"],"names":["Editor","Path","Point","Range","Element","Transforms","fixList","SHORTCUTS","withMarkdown","editor","deleteBackward","insertText","insertBreak","deleteFragment","insertBreak2","handled","selection","isExpanded","block","above","match","n","isBlock","isEditor","parent","text","string","blockPath","indent","setNodes","type","at","length","children","liftNodes","isCollapsed","anchor","path","start","range","focus","beforeText","tabs","c","substr","blockType","inList","test","list","select","delete","wrapNodes","found","deleteBackward2","unit","console","log","equals","listNode","withoutNormalizing","unwrapNodes","endsWith","split","beforeTextInBlock","options","reverse","distance","voids","hanging","isRange","isPoint","furthestVoid","void","mode","voidPath","opts","target","before","after","end","isPath","removeNodes","unhangRange","edges","startBlock","endBlock","isAcrossBlocks","isSingleText","startVoid","endVoid","isAncestor","matches","lastPath","entry","nodes","node","compare","isVoid","isCommon","push","pathRefs","Array","from","p","pathRef","startRef","pointRef","endRef","point","current","leaf","offset","slice","apply","unref","mergeNodes","includes","prev","previous","prevNode","prevPath","newPath","next","commonPath","common","isPreviousSibling","isSibling","levels","emptyAncestor","isElement","emptyRef","properties","position","Text","isText","rest","Error","JSON","stringify","moveNodes","to","isEmpty"],"mappings":"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","sourcesContent":["import {Editor, Path, Point, Range, Element, Transforms, NodeEntry} from \"slate\";\nimport {ListNode} from './types'\nimport {fixList} from \"./util\";\n\nconst SHORTCUTS = {\n    '*': 'ul-item',\n    '-': 'ul-item',\n    '+': 'ul-item',\n    '>': 'block-quote',\n    '#': 'heading-one',\n    '##': 'heading-two',\n    '###': 'heading-three',\n    '####': 'heading-four',\n    '#####': 'heading-five',\n    '######': 'heading-six',\n}\n\nexport const withMarkdown = (editor: Editor) => {\n    const {deleteBackward, insertText, insertBreak, deleteFragment} = editor\n\n    const insertBreak2 = () => {\n        let handled = false\n        const {selection} = editor\n\n        if (!selection || Range.isExpanded(selection)) {\n            insertBreak()\n            return\n        }\n        const block = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n        })\n        if (!block || Editor.isEditor(block[0])) {\n            insertBreak()\n            return\n        }\n        const parent = Editor.parent(editor, block[1])\n        if (!parent || Editor.isEditor(parent[0])) {\n            insertBreak()\n            return\n        }\n        const text = Editor.string(editor, block[1])\n        if (text) {\n            insertBreak()\n            return\n        }\n        const blockPath: Path = block[1]\n        let indent = 0\n        if (typeof parent[0].indent === \"number\") {\n            indent = parent[0].indent > 1 ? parent[0].indent - 1 : 0\n        }\n        Transforms.setNodes(editor, {type: 'paragraph', indent}, {at: blockPath})\n        // if it is the last child\n        if (blockPath[blockPath.length - 1] === parent[0].children.length - 1) {\n            Transforms.liftNodes(editor, {at: blockPath})\n            return\n        }\n    }\n    editor.insertBreak = () => {\n        insertBreak2()\n        fixList(editor)\n    }\n    editor.insertText = (text: string) => {\n        const {selection} = editor\n        if ((text !== ' ') || !selection || !Range.isCollapsed(selection)) {\n            insertText(text)\n            return\n        }\n\n        const {anchor} = selection\n        const block = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n        })\n        const path = block ? block[1] : []\n        const start = Editor.start(editor, path)\n        const range = {anchor, focus: start}\n        let beforeText = Editor.string(editor, range)\n        let tabs = 0\n        for (let c of beforeText) {\n            if (c === '\\t') {\n                tabs++\n            }\n        }\n        beforeText = beforeText.substr(tabs)\n        const blockType = block![0].type as string\n        let inList = typeof blockType === 'string' ? blockType === 'list-item' : false\n\n\n        let type = SHORTCUTS[beforeText]\n\n        if (!type && /^[1-9]\\d*\\./.test(beforeText)) {\n            type = 'ol-item'\n        }\n        let list\n        switch (type) {\n            case 'ul-item':\n                if (inList) {\n                    insertText(text)\n                    break\n                }\n                Transforms.select(editor, range)\n                Transforms.delete(editor)\n                Transforms.setNodes(\n                    editor,\n                    {type: 'list-item'},\n                    {match: n => Editor.isBlock(editor, n)}\n                )\n                list = {type: 'bulleted-list', indent: tabs, children: []}\n                Transforms.wrapNodes(editor, list, {\n                    match: n => n.type === 'list-item',\n                })\n                fixList(editor)\n                break\n            case 'ol-item':\n                if (inList) {\n                    insertText(text)\n                    break\n                }\n                const found = beforeText.match(/^([\\t]*)\\d+\\./)\n                Transforms.select(editor, range)\n                Transforms.delete(editor)\n                Transforms.setNodes(\n                    editor,\n                    {type: 'list-item'},\n                    {match: n => Editor.isBlock(editor, n)}\n                )\n                list = {type: 'numbered-list', indent: tabs, children: []}\n                Transforms.wrapNodes(editor, list, {\n                    match: n => n.type === 'list-item',\n                })\n                fixList(editor)\n                break\n            case 'block-quote':\n                if (inList || blockType !== 'paragraph') {\n                    insertText(text)\n                    break\n                }\n                let parent = Editor.above(editor, {match: n => n.type === 'block-quote'})\n                if (parent) {\n                    insertText(text)\n                    break\n                }\n                Transforms.select(editor, range)\n                Transforms.delete(editor)\n                Transforms.wrapNodes(editor, {type: 'block-quote', children: []}, {\n                    match: n => n.type === 'paragraph'\n                })\n                break\n            default:\n                insertText(text)\n        }\n        return\n    }\n\n    const deleteBackward2 = (unit: 'character' | 'word' | 'line' | 'block') => {\n        console.log(\"editor.deleteBackward:\", unit)\n        const {selection} = editor\n\n        if (!selection || Range.isExpanded(selection)) {\n            deleteBackward(unit)\n            return\n        }\n        const match = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n        })\n\n        if (!match || Editor.isEditor(match[0])) {\n            deleteBackward(unit)\n            return\n        }\n        const [block, path] = match as NodeEntry<ListNode>\n        const start = Editor.start(editor, path)\n\n        if (Point.equals(selection.anchor, start)) {\n            if (block.type === 'list-item') {\n                const [listNode] = Editor.parent(editor, path) as NodeEntry<ListNode>\n                if (listNode && (listNode.indent as number > 0)) {\n                    Editor.withoutNormalizing(editor, () => {\n                        Transforms.wrapNodes(editor, {\n                            type: listNode.type,\n                            indent: listNode.indent! - 1,\n                            children: []\n                        }, {at: path})\n                        Transforms.liftNodes(editor, {at: path})\n                    })\n                } else {\n                    Transforms.setNodes(editor, {type: 'paragraph'})\n                    Transforms.unwrapNodes(editor, {\n                        match: n => (typeof n.type === 'string' && n.type.endsWith('-list')),\n                        split: true,\n                    })\n                    // deleteBackward(unit)\n                }\n            } else if (block.type === 'paragraph') {\n                if (block.indent && block.indent > 0) {\n                    Transforms.setNodes(editor, {indent: block.indent - 1}, {at: path})\n                    return\n                } else {\n                    deleteBackward(unit)\n                }\n            } else {\n                Transforms.setNodes(editor, {type: 'paragraph'})\n            }\n            return\n        } // end if at start\n        deleteBackward(unit)\n    }\n\n    editor.deleteBackward = (unit: 'character' | 'word' | 'line' | 'block') => {\n        console.log(\"editor.deleteBackward:\", unit)\n        deleteBackward2(unit)\n        fixList(editor)\n    }\n\n    editor.deleteFragment = ()=>{\n        console.log(\"editor.deleteFragment:\")\n        deleteFragment()\n    }\n\n    return editor\n}\n\nconst beforeTextInBlock = (editor: Editor): string => {\n    const {selection} = editor\n    if (!selection) {\n        return ''\n    }\n    const block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n    })\n    const path = block ? block[1] : []\n    const start = Editor.start(editor, path)\n    const range = {anchor: Range.start(editor.selection!), focus: start}\n    let beforeText = Editor.string(editor, range)\n    return beforeText\n}\n\nTransforms.delete =(\n    editor: Editor,\n    options: {\n    at?: Location\n    distance?: number\n    unit?: 'character' | 'word' | 'line' | 'block'\n    reverse?: boolean\n    hanging?: boolean\n    voids?: boolean\n} = {}\n):void => {\n    Editor.withoutNormalizing(editor, () => {\n        const {\n            reverse = false,\n            unit = 'character',\n            distance = 1,\n            voids = false,\n        } = options\n        let { at = editor.selection, hanging = false } = options\n\n        if (!at) {\n            return\n        }\n\n        if (Range.isRange(at) && Range.isCollapsed(at)) {\n            at = at.anchor\n        }\n\n        if (Point.isPoint(at)) {\n            const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n\n            if (!voids && furthestVoid) {\n                const [, voidPath] = furthestVoid\n                at = voidPath\n            } else {\n                const opts = { unit, distance }\n                const target = reverse\n                    ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n                    : Editor.after(editor, at, opts) || Editor.end(editor, [])\n                at = { anchor: at, focus: target }\n                hanging = true\n            }\n        }\n\n        if (Path.isPath(at)) {\n            Transforms.removeNodes(editor, { at, voids })\n            return\n        }\n\n        if (Range.isCollapsed(at)) {\n            return\n        }\n\n        if (!hanging) {\n            at = Editor.unhangRange(editor, at, { voids })\n        }\n\n        let [start, end] = Range.edges(at)\n        const startBlock = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n            at: start,\n            voids,\n        })\n        const endBlock = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n            at: end,\n            voids,\n        })\n        const isAcrossBlocks =\n            startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n        const isSingleText = Path.equals(start.path, end.path)\n        const startVoid = voids\n            ? null\n            : Editor.void(editor, { at: start, mode: 'highest' })\n        const endVoid = voids\n            ? null\n            : Editor.void(editor, { at: end, mode: 'highest' })\n\n        // If the start or end points are inside an inline void, nudge them out.\n        if (startVoid) {\n            const before = Editor.before(editor, start)\n\n            if (\n                before &&\n                startBlock &&\n                Path.isAncestor(startBlock[1], before.path)\n            ) {\n                start = before\n            }\n        }\n\n        if (endVoid) {\n            const after = Editor.after(editor, end)\n\n            if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n                end = after\n            }\n        }\n\n        // Get the highest nodes that are completely inside the range, as well as\n        // the start and end nodes.\n        const matches: NodeEntry[] = []\n        let lastPath: Path | undefined\n\n        for (const entry of Editor.nodes(editor, { at, voids })) {\n            const [node, path] = entry\n\n            if (lastPath && Path.compare(path, lastPath) === 0) {\n                continue\n            }\n\n            if (\n                (!voids && Editor.isVoid(editor, node)) ||\n                (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n            ) {\n                matches.push(entry)\n                lastPath = path\n            }\n        }\n\n        const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n        const startRef = Editor.pointRef(editor, start)\n        const endRef = Editor.pointRef(editor, end)\n\n        if (!isSingleText && !startVoid) {\n            const point = startRef.current!\n            const [node] = Editor.leaf(editor, point)\n            const { path } = point\n            const { offset } = start\n            const text = node.text.slice(offset)\n            editor.apply({ type: 'remove_text', path, offset, text })\n        }\n\n        for (const pathRef of pathRefs) {\n            const path = pathRef.unref()!\n            console.log(\"remove not at:\", path)\n            Transforms.removeNodes(editor, { at: path, voids })\n        }\n\n        if (!endVoid) {\n            const point = endRef.current!\n            const [node] = Editor.leaf(editor, point)\n            const { path } = point\n            const offset = isSingleText ? start.offset : 0\n            const text = node.text.slice(offset, end.offset)\n            editor.apply({ type: 'remove_text', path, offset, text })\n        }\n\n        if (\n            !isSingleText &&\n            isAcrossBlocks &&\n            endRef.current &&\n            startRef.current\n        ) {\n            console.log(\"merge node at:\", at)\n            Transforms.mergeNodes(editor, {\n                at: endRef.current,\n                hanging: true,\n                voids,\n            })\n        }\n\n        const point = endRef.unref() || startRef.unref()\n\n        if (options.at == null && point) {\n            Transforms.select(editor, point)\n        }\n    })\n}\n\nTransforms.mergeNodes = (\n    editor: Editor,\n    options: {\n    at?: Location\n    match?: (node: Node) => boolean\n    mode?: 'highest' | 'lowest'\n    hanging?: boolean\n    voids?: boolean\n} = {}\n) => {\n    Editor.withoutNormalizing(editor, () => {\n        let { match, at = editor.selection } = options\n        const { hanging = false, voids = false, mode = 'lowest' } = options\n\n        if (!at) {\n            return\n        }\n\n        if (match == null) {\n            if (Path.isPath(at)) {\n                const [parent] = Editor.parent(editor, at)\n                match = n => parent.children.includes(n)\n            } else {\n                match = n => Editor.isBlock(editor, n)\n            }\n        }\n\n        if (!hanging && Range.isRange(at)) {\n            at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isRange(at)) {\n            if (Range.isCollapsed(at)) {\n                at = at.anchor\n            } else {\n                const [, end] = Range.edges(at)\n                const pointRef = Editor.pointRef(editor, end)\n                Transforms.delete(editor, { at })\n                at = pointRef.unref()!\n\n                if (options.at == null) {\n                    Transforms.select(editor, at)\n                }\n            }\n        }\n\n        const [current] = Editor.nodes(editor, { at, match, voids, mode })\n        const prev = Editor.previous(editor, { at, match, voids, mode })\n\n        if (!current || !prev) {\n            return\n        }\n\n        const [node, path] = current\n        const [prevNode, prevPath] = prev\n\n        if (path.length === 0 || prevPath.length === 0) {\n            return\n        }\n\n        const newPath = Path.next(prevPath)\n        const commonPath = Path.common(path, prevPath)\n        const isPreviousSibling = Path.isSibling(path, prevPath)\n        const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\n            .slice(commonPath.length)\n            .slice(0, -1)\n\n        // Determine if the merge will leave an ancestor of the path empty as a\n        // result, in which case we'll want to remove it after merging.\n        const emptyAncestor = Editor.above(editor, {\n            at: path,\n            mode: 'highest',\n            match: n =>\n                levels.includes(n) && Element.isElement(n) && n.children.length === 1,\n        })\n\n        const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n        let properties\n        let position\n\n        // Ensure that the nodes are equivalent, and figure out what the position\n        // and extra properties of the merge will be.\n        if (Text.isText(node) && Text.isText(prevNode)) {\n            const { text, ...rest } = node\n            position = prevNode.text.length\n            properties = rest as Partial<Text>\n        } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n            const { children, ...rest } = node\n            position = prevNode.children.length\n            properties = rest as Partial<Element>\n        } else {\n            throw new Error(\n                `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n                    node\n                )} ${JSON.stringify(prevNode)}`\n            )\n        }\n\n        // If the node isn't already the next sibling of the previous node, move\n        // it so that it is before merging.\n        if (!isPreviousSibling) {\n            console.log(\"In merge, movNodes from \", at, \"to\", newPath)\n            Transforms.moveNodes(editor, { at: path, to: newPath, voids })\n        }\n\n        // If there was going to be an empty ancestor of the node that was merged,\n        // we remove it from the tree.\n        if (emptyRef) {\n            console.log(\"In merge, remove node at:\", emptyRef.current)\n            Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\n        }\n\n        // If the target node that we're merging with is empty, remove it instead\n        // of merging the two. This is a common rich text editor behavior to\n        // prevent losing formatting when deleting entire nodes when you have a\n        // hanging selection.\n        if (\n            (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n            (Text.isText(prevNode) && prevNode.text === '')\n        ) {\n            console.log(\"In merge, remove2 node at:\", emptyRef.current)\n            Transforms.removeNodes(editor, { at: prevPath, voids })\n        } else {\n            editor.apply({\n                type: 'merge_node',\n                path: newPath,\n                position,\n                properties,\n            })\n        }\n\n        if (emptyRef) {\n            emptyRef.unref()\n        }\n    })\n}"]},"metadata":{},"sourceType":"module"}