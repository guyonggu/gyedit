{"ast":null,"code":"import { Editor, Point, Range, Transforms } from \"slate\";\nimport { BlockType } from './types';\nconst SHORTCUTS = {\n  '*': 'ul-item',\n  '-': 'ul-item',\n  '+': 'ul-item',\n  '>': 'block-quote',\n  '#': 'heading-one',\n  '##': 'heading-two',\n  '###': 'heading-three',\n  '####': 'heading-four',\n  '#####': 'heading-five',\n  '######': 'heading-six'\n};\nexport const withMarkdown = editor => {\n  const {\n    deleteBackward,\n    insertText,\n    insertBreak\n  } = editor;\n\n  editor.insertBreak = () => {\n    let handled = false;\n    const {\n      selection\n    } = editor;\n\n    if (!selection || Range.isExpanded(selection)) {\n      insertBreak();\n      return;\n    }\n\n    const block = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n)\n    });\n\n    if (!block || Editor.isEditor(block[0])) {\n      insertBreak();\n      return;\n    }\n\n    const parent = Editor.parent(editor, block[1]);\n\n    if (!parent) {\n      insertBreak();\n      return;\n    }\n\n    const beforeText = beforeTextInBlock(editor);\n\n    if (beforeText) {\n      insertBreak();\n      return;\n    }\n\n    const blockPath = block[1];\n    Transforms.setNodes(editor, {\n      type: 'paragraph'\n    }, {\n      at: blockPath\n    }); // if it is the last child\n\n    if (blockPath[blockPath.length - 1] === parent[0].children.length - 1) {\n      Transforms.liftNodes(editor, {\n        at: blockPath\n      });\n      return;\n    }\n  };\n\n  editor.insertText = text => {\n    const {\n      selection\n    } = editor;\n\n    if (text !== ' ' || !selection || !Range.isCollapsed(selection)) {\n      insertText(text);\n      return;\n    }\n\n    const {\n      anchor\n    } = selection;\n    const block = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n)\n    });\n    const path = block ? block[1] : [];\n    const start = Editor.start(editor, path);\n    const range = {\n      anchor,\n      focus: start\n    };\n    let beforeText = Editor.string(editor, range);\n    let tabs = 0;\n\n    for (let c of beforeText) {\n      if (c === '\\t') {\n        tabs++;\n      }\n    }\n\n    beforeText = beforeText.substr(tabs);\n    const blockType = block[0].type;\n    let inList = typeof blockType === 'string' ? blockType === 'list-item' : false;\n\n    if (text === ' ') {\n      let type = SHORTCUTS[beforeText];\n\n      if (!type && /^[1-9]\\d*\\./.test(beforeText)) {\n        type = 'ol-item';\n      }\n\n      let list;\n\n      switch (type) {\n        case 'ul-item':\n          if (inList) break;\n          Transforms.select(editor, range);\n          Transforms.delete(editor);\n          Transforms.setNodes(editor, {\n            type: 'list-item'\n          }, {\n            match: n => Editor.isBlock(editor, n)\n          });\n          list = {\n            type: BlockType[\"bulleted-list\"],\n            indent: tabs + 1,\n            children: []\n          };\n          Transforms.wrapNodes(editor, list, {\n            match: n => n.type === 'list-item'\n          });\n          break;\n\n        case 'ol-item':\n          if (inList) break;\n          const found = beforeText.match(/^([\\t]*)\\d+\\./);\n          Transforms.select(editor, range);\n          Transforms.delete(editor);\n          Transforms.setNodes(editor, {\n            type: 'list-item'\n          }, {\n            match: n => Editor.isBlock(editor, n)\n          });\n          list = {\n            type: 'numbered-list',\n            indent: tabs + 1,\n            children: []\n          };\n          Transforms.wrapNodes(editor, list, {\n            match: n => n.type === 'list-item'\n          });\n          break;\n\n        default:\n          insertText(text);\n      }\n\n      return;\n    } else if (text === '\\t' && inList && beforeText === '') {\n      const [listNode] = Editor.parent(editor, path);\n      console.log(listNode.type);\n\n      if (listNode.type === 'bulleted-list' || listNode.type === 'numbered-list') {\n        listNode.indent++;\n      }\n\n      Transforms.select(editor, path);\n      return;\n    }\n\n    insertText(text);\n  };\n\n  editor.deleteBackward = (...args) => {\n    const {\n      selection\n    } = editor;\n\n    if (selection && Range.isCollapsed(selection)) {\n      const match = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n)\n      });\n\n      if (match) {\n        const [block, path] = match;\n        const start = Editor.start(editor, path);\n\n        if (block.type !== 'paragraph' && Point.equals(selection.anchor, start)) {\n          if (block.type === 'list-item') {\n            const parent = Editor.parent(editor, path);\n            const listNode = parent[0];\n\n            if (listNode && listNode.indent > 1) {\n              Transforms.setNodes(editor, {\n                indent: listNode.indent - 1\n              }, {\n                at: parent[1]\n              });\n            } else {\n              Transforms.setNodes(editor, {\n                type: 'paragraph'\n              });\n              Transforms.unwrapNodes(editor, {\n                match: n => n.type === 'bulleted-list',\n                split: true\n              });\n            }\n          } else {\n            Transforms.setNodes(editor, {\n              type: 'paragraph'\n            });\n          }\n\n          return;\n        }\n      }\n\n      deleteBackward(...args);\n    }\n  };\n\n  return editor;\n};\n\nconst beforeTextInBlock = editor => {\n  const {\n    selection\n  } = editor;\n\n  if (!selection) {\n    return '';\n  }\n\n  const block = Editor.above(editor, {\n    match: n => Editor.isBlock(editor, n)\n  });\n  const path = block ? block[1] : [];\n  const start = Editor.start(editor, path);\n  const range = {\n    anchor: Range.start(editor.selection),\n    focus: start\n  };\n  let beforeText = Editor.string(editor, range);\n  return beforeText;\n};","map":{"version":3,"sources":["/Users/yonggu/WebstormProjects/gyedit/src/withMarkdown.ts"],"names":["Editor","Point","Range","Transforms","BlockType","SHORTCUTS","withMarkdown","editor","deleteBackward","insertText","insertBreak","handled","selection","isExpanded","block","above","match","n","isBlock","isEditor","parent","beforeText","beforeTextInBlock","blockPath","setNodes","type","at","length","children","liftNodes","text","isCollapsed","anchor","path","start","range","focus","string","tabs","c","substr","blockType","inList","test","list","select","delete","indent","wrapNodes","found","listNode","console","log","args","equals","unwrapNodes","split"],"mappings":"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","sourcesContent":["import {Editor, Path, Point, Range, Transforms} from \"slate\";\nimport { BlockType } from './types'\n\nconst SHORTCUTS = {\n    '*': 'ul-item',\n    '-': 'ul-item',\n    '+': 'ul-item',\n    '>': 'block-quote',\n    '#': 'heading-one',\n    '##': 'heading-two',\n    '###': 'heading-three',\n    '####': 'heading-four',\n    '#####': 'heading-five',\n    '######': 'heading-six',\n}\n\nexport const withMarkdown = (editor: Editor) => {\n    const {deleteBackward, insertText, insertBreak} = editor\n\n    editor.insertBreak = () => {\n        let handled = false\n        const {selection} = editor\n\n        if (!selection || Range.isExpanded(selection)) {\n            insertBreak()\n            return\n        }\n        const block = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n        })\n        if (!block || Editor.isEditor(block[0])) {\n            insertBreak()\n            return\n        }\n        const parent = Editor.parent(editor, block[1])\n        if (!parent){\n            insertBreak()\n            return\n        }\n        const beforeText = beforeTextInBlock(editor)\n        if (beforeText) {\n            insertBreak()\n            return\n        }\n        const blockPath:Path = block[1]\n\n        Transforms.setNodes(editor, {type: 'paragraph'}, {at:blockPath})\n        // if it is the last child\n        if (blockPath[blockPath.length - 1] === parent[0].children.length - 1){\n            Transforms.liftNodes(editor, {at:blockPath})\n            return\n        }\n    }\n\n    editor.insertText = (text: string) => {\n        const {selection} = editor\n        if ((text !== ' ') || !selection || !Range.isCollapsed(selection)) {\n            insertText(text)\n            return\n        }\n\n        const {anchor} = selection\n        const block = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n        })\n        const path = block ? block[1] : []\n        const start = Editor.start(editor, path)\n        const range = {anchor, focus: start}\n        let beforeText = Editor.string(editor, range)\n        let tabs = 0\n        for (let c of beforeText) {\n            if (c === '\\t') {\n                tabs++\n            }\n        }\n        beforeText = beforeText.substr(tabs)\n        const blockType = block![0].type\n        let inList = typeof blockType === 'string' ? blockType === 'list-item' : false\n\n        if (text === ' ') {\n\n            let type = SHORTCUTS[beforeText]\n\n            if (!type && /^[1-9]\\d*\\./.test(beforeText)) {\n                type = 'ol-item'\n            }\n            let list\n            switch (type) {\n                case 'ul-item':\n                    if (inList) break\n                    Transforms.select(editor, range)\n                    Transforms.delete(editor)\n                    Transforms.setNodes(\n                        editor,\n                        {type: 'list-item'},\n                        {match: n => Editor.isBlock(editor, n)}\n                    )\n                    list = {type: BlockType[\"bulleted-list\"], indent: tabs + 1, children: []}\n                    Transforms.wrapNodes(editor, list, {\n                        match: n => n.type === 'list-item',\n                    })\n                    break\n                case 'ol-item':\n                    if (inList) break\n                    const found = beforeText.match(/^([\\t]*)\\d+\\./)\n                    Transforms.select(editor, range)\n                    Transforms.delete(editor)\n                    Transforms.setNodes(\n                        editor,\n                        {type: 'list-item'},\n                        {match: n => Editor.isBlock(editor, n)}\n                    )\n                    list = {type: 'numbered-list', indent: tabs + 1, children: []}\n                    Transforms.wrapNodes(editor, list, {\n                        match: n => n.type === 'list-item',\n                    })\n                    break\n                default:\n                    insertText(text)\n            }\n            return\n        } else if (text === '\\t' && inList && beforeText === '') {\n            const [listNode] = Editor.parent(editor, path) as ListNodeEntry\n            console.log(listNode.type)\n            if (listNode.type === 'bulleted-list' || listNode.type === 'numbered-list') {\n                listNode.indent++\n            }\n            Transforms.select(editor, path)\n            return\n        }\n\n        insertText(text)\n    }\n\n    editor.deleteBackward = (...args) => {\n        const {selection} = editor\n\n        if (selection && Range.isCollapsed(selection)) {\n            const match = Editor.above(editor, {\n                match: n => Editor.isBlock(editor, n),\n            })\n\n            if (match) {\n                const [block, path] = match\n                const start = Editor.start(editor, path)\n\n                if (\n                    block.type !== 'paragraph' &&\n                    Point.equals(selection.anchor, start)\n                ) {\n                    if (block.type === 'list-item') {\n                        const parent = Editor.parent(editor, path)\n                        const listNode = parent[0] as ListNode\n                        if (listNode && (listNode.indent > 1)) {\n                            Transforms.setNodes(editor, {indent: listNode.indent - 1}, {at: parent[1]})\n                        } else {\n                            Transforms.setNodes(editor, {type: 'paragraph'})\n                            Transforms.unwrapNodes(editor, {\n                                match: n => n.type === 'bulleted-list',\n                                split: true,\n                            })\n                        }\n                    } else {\n                        Transforms.setNodes(editor, {type: 'paragraph'})\n                    }\n\n                    return\n                }\n            }\n\n            deleteBackward(...args)\n        }\n    }\n\n    return editor\n}\n\nconst beforeTextInBlock = (editor: Editor): string => {\n    const {selection} = editor\n    if (!selection) {\n        return ''\n    }\n    const block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n    })\n    const path = block ? block[1] : []\n    const start = Editor.start(editor, path)\n    const range = {anchor: Range.start(editor.selection!), focus: start}\n    let beforeText = Editor.string(editor, range)\n    return beforeText\n}"]},"metadata":{},"sourceType":"module"}