{"ast":null,"code":"import _taggedTemplateLiteral from \"@babel/runtime/helpers/esm/taggedTemplateLiteral\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nvar __jsx = React.createElement;\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n          display: block;\\n          max-width: 100%;\\n          max-height: 20em;\\n          box-shadow: \", \";\\n        \"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nimport React, { useState, useCallback, useMemo } from 'react';\nimport { jsx } from 'slate-hyperscript';\nimport { Transforms, createEditor } from 'slate';\nimport { withHistory } from 'slate-history';\nimport { css } from 'emotion';\nimport { Slate, Editable, withReact, useSelected, useFocused } from 'slate-react';\nvar ELEMENT_TAGS = {\n  A: function A(el) {\n    return {\n      type: 'link',\n      url: el.getAttribute('href')\n    };\n  },\n  BLOCKQUOTE: function BLOCKQUOTE() {\n    return {\n      type: 'quote'\n    };\n  },\n  H1: function H1() {\n    return {\n      type: 'heading-one'\n    };\n  },\n  H2: function H2() {\n    return {\n      type: 'heading-two'\n    };\n  },\n  H3: function H3() {\n    return {\n      type: 'heading-three'\n    };\n  },\n  H4: function H4() {\n    return {\n      type: 'heading-four'\n    };\n  },\n  H5: function H5() {\n    return {\n      type: 'heading-five'\n    };\n  },\n  H6: function H6() {\n    return {\n      type: 'heading-six'\n    };\n  },\n  IMG: function IMG(el) {\n    return {\n      type: 'image',\n      url: el.getAttribute('src')\n    };\n  },\n  LI: function LI() {\n    return {\n      type: 'list-item'\n    };\n  },\n  OL: function OL() {\n    return {\n      type: 'numbered-list'\n    };\n  },\n  P: function P() {\n    return {\n      type: 'paragraph'\n    };\n  },\n  PRE: function PRE() {\n    return {\n      type: 'code'\n    };\n  },\n  UL: function UL() {\n    return {\n      type: 'bulleted-list'\n    };\n  }\n}; // COMPAT: `B` is omitted here because Google Docs uses `<b>` in weird ways.\n\nvar TEXT_TAGS = {\n  CODE: function CODE() {\n    return {\n      code: true\n    };\n  },\n  DEL: function DEL() {\n    return {\n      strikethrough: true\n    };\n  },\n  EM: function EM() {\n    return {\n      italic: true\n    };\n  },\n  I: function I() {\n    return {\n      italic: true\n    };\n  },\n  S: function S() {\n    return {\n      strikethrough: true\n    };\n  },\n  STRONG: function STRONG() {\n    return {\n      bold: true\n    };\n  },\n  U: function U() {\n    return {\n      underline: true\n    };\n  }\n};\nexport var deserialize = function deserialize(el) {\n  if (el.nodeType === 3) {\n    return el.textContent;\n  } else if (el.nodeType !== 1) {\n    return null;\n  } else if (el.nodeName === 'BR') {\n    return '\\n';\n  }\n\n  var nodeName = el.nodeName;\n  var parent = el;\n\n  if (nodeName === 'PRE' && el.childNodes[0] && el.childNodes[0].nodeName === 'CODE') {\n    parent = el.childNodes[0];\n  }\n\n  var children = Array.from(parent.childNodes).map(deserialize).flat();\n\n  if (el.nodeName === 'BODY') {\n    return jsx('fragment', {}, children);\n  }\n\n  if (ELEMENT_TAGS[nodeName]) {\n    var attrs = ELEMENT_TAGS[nodeName](el);\n    return jsx('element', attrs, children);\n  }\n\n  if (TEXT_TAGS[nodeName]) {\n    var _attrs = TEXT_TAGS[nodeName](el);\n\n    return children.map(function (child) {\n      return jsx('text', _attrs, child);\n    });\n  }\n\n  return children;\n};\n\nvar PasteHtmlExample = function PasteHtmlExample() {\n  var _useState = useState(initialValue),\n      value = _useState[0],\n      setValue = _useState[1];\n\n  var renderElement = useCallback(function (props) {\n    return __jsx(Element, props);\n  }, []);\n  var renderLeaf = useCallback(function (props) {\n    return __jsx(Leaf, props);\n  }, []);\n  var editor = useMemo(function () {\n    return withHtml(withReact(withHistory(createEditor())));\n  }, []);\n  return __jsx(Slate, {\n    editor: editor,\n    value: value,\n    onChange: function onChange(value) {\n      return setValue(value);\n    }\n  }, __jsx(Editable, {\n    renderElement: renderElement,\n    renderLeaf: renderLeaf,\n    placeholder: \"Paste in some HTML...\"\n  }));\n};\n\nvar withHtml = function withHtml(editor) {\n  var insertData = editor.insertData,\n      isInline = editor.isInline,\n      isVoid = editor.isVoid;\n\n  editor.isInline = function (element) {\n    return element.type === 'link' ? true : isInline(element);\n  };\n\n  editor.isVoid = function (element) {\n    return element.type === 'image' ? true : isVoid(element);\n  };\n\n  editor.insertData = function (data) {\n    var html = data.getData('text/html');\n\n    if (html) {\n      var parsed = new DOMParser().parseFromString(html, 'text/html');\n      var fragment = deserialize(parsed.body);\n      Transforms.insertFragment(editor, fragment);\n      return;\n    }\n\n    insertData(data);\n  };\n\n  return editor;\n};\n\nvar Element = function Element(props) {\n  var attributes = props.attributes,\n      children = props.children,\n      element = props.element;\n\n  switch (element.type) {\n    default:\n      return __jsx(\"p\", attributes, children);\n\n    case 'quote':\n      return __jsx(\"blockquote\", attributes, children);\n\n    case 'code':\n      return __jsx(\"pre\", null, __jsx(\"code\", attributes, children));\n\n    case 'bulleted-list':\n      return __jsx(\"ul\", attributes, children);\n\n    case 'heading-one':\n      return __jsx(\"h1\", attributes, children);\n\n    case 'heading-two':\n      return __jsx(\"h2\", attributes, children);\n\n    case 'heading-three':\n      return __jsx(\"h3\", attributes, children);\n\n    case 'heading-four':\n      return __jsx(\"h4\", attributes, children);\n\n    case 'heading-five':\n      return __jsx(\"h5\", attributes, children);\n\n    case 'heading-six':\n      return __jsx(\"h6\", attributes, children);\n\n    case 'list-item':\n      return __jsx(\"li\", attributes, children);\n\n    case 'numbered-list':\n      return __jsx(\"ol\", attributes, children);\n\n    case 'link':\n      return __jsx(\"a\", _extends({\n        href: element.url\n      }, attributes), children);\n\n    case 'image':\n      return __jsx(ImageElement, props);\n  }\n};\n\nvar ImageElement = function ImageElement(_ref) {\n  var attributes = _ref.attributes,\n      children = _ref.children,\n      element = _ref.element;\n  var selected = useSelected();\n  var focused = useFocused();\n  return __jsx(\"div\", attributes, children, __jsx(\"img\", {\n    src: element.url,\n    className: css(_templateObject(), selected && focused ? '0 0 0 2px blue;' : 'none')\n  }));\n};\n\nvar Leaf = function Leaf(_ref2) {\n  var attributes = _ref2.attributes,\n      children = _ref2.children,\n      leaf = _ref2.leaf;\n\n  if (leaf.bold) {\n    children = __jsx(\"strong\", null, children);\n  }\n\n  if (leaf.code) {\n    children = __jsx(\"code\", null, children);\n  }\n\n  if (leaf.italic) {\n    children = __jsx(\"em\", null, children);\n  }\n\n  if (leaf.underline) {\n    children = __jsx(\"u\", null, children);\n  }\n\n  if (leaf.strikethrough) {\n    children = __jsx(\"del\", null, children);\n  }\n\n  return __jsx(\"span\", attributes, children);\n};\n\nvar initialValue = [{\n  children: [{\n    text: \"By default, pasting content into a Slate editor will use the clipboard's \"\n  }, {\n    text: \"'text/plain'\",\n    code: true\n  }, {\n    text: \" data. That's okay for some use cases, but sometimes you want users to be able to paste in content and have it maintaing its formatting. To do this, your editor needs to handle \"\n  }, {\n    text: \"'text/html'\",\n    code: true\n  }, {\n    text: ' data. '\n  }]\n}, {\n  children: [{\n    text: 'This is an example of doing exactly that!'\n  }]\n}, {\n  children: [{\n    text: \"Try it out for yourself! Copy and paste some rendered HTML rich text content (not the source code) from another site into this editor and it's formatting should be preserved.\"\n  }]\n}];\nexport default PasteHtmlExample;","map":null,"metadata":{},"sourceType":"module"}