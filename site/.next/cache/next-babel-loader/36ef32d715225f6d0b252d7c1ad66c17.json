{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nvar __jsx = React.createElement;\nimport React, { useState, useCallback, useMemo } from 'react';\nimport { Slate, Editable, withReact } from 'slate-react';\nimport { Transforms, createEditor, Node } from 'slate';\nimport { withHistory } from 'slate-history';\n\nvar withLayout = function withLayout(editor) {\n  var normalizeNode = editor.normalizeNode;\n\n  editor.normalizeNode = function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        node = _ref2[0],\n        path = _ref2[1];\n\n    if (path.length === 0) {\n      if (editor.children.length < 1) {\n        var title = {\n          type: 'title',\n          children: [{\n            text: 'Untitled'\n          }]\n        };\n        Transforms.insertNodes(editor, title, {\n          at: path.concat(0)\n        });\n      }\n\n      if (editor.children.length < 2) {\n        var paragraph = {\n          type: 'paragraph',\n          children: [{\n            text: ''\n          }]\n        };\n        Transforms.insertNodes(editor, paragraph, {\n          at: path.concat(1)\n        });\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = Node.children(editor, path)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              child = _step$value[0],\n              childPath = _step$value[1];\n\n          var type = childPath[0] === 0 ? 'title' : 'paragraph';\n\n          if (child.type !== type) {\n            Transforms.setNodes(editor, {\n              type: type\n            }, {\n              at: childPath\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    return normalizeNode([node, path]);\n  };\n\n  return editor;\n};\n\nvar ForcedLayoutExample = function ForcedLayoutExample() {\n  var _useState = useState(initialValue),\n      value = _useState[0],\n      setValue = _useState[1];\n\n  var renderElement = useCallback(function (props) {\n    return __jsx(Element, props);\n  }, []);\n  var editor = useMemo(function () {\n    return withLayout(withHistory(withReact(createEditor())));\n  }, []);\n  return __jsx(Slate, {\n    editor: editor,\n    value: value,\n    onChange: function onChange(value) {\n      return setValue(value);\n    }\n  }, __jsx(Editable, {\n    renderElement: renderElement,\n    placeholder: \"Enter a title\\u2026\",\n    spellCheck: true,\n    autoFocus: true\n  }));\n};\n\nvar Element = function Element(_ref3) {\n  var attributes = _ref3.attributes,\n      children = _ref3.children,\n      element = _ref3.element;\n\n  switch (element.type) {\n    case 'title':\n      return __jsx(\"h2\", attributes, children);\n\n    case 'paragraph':\n      return __jsx(\"p\", attributes, children);\n  }\n};\n\nvar initialValue = [{\n  type: 'title',\n  children: [{\n    text: 'Enforce Your Layout!'\n  }]\n}, {\n  type: 'paragraph',\n  children: [{\n    text: 'This example shows how to enforce your layout with domain-specific constraints. This document will always have a title block at the top and at least one paragraph in the body. Try deleting them and see what happens!'\n  }]\n}];\nexport default ForcedLayoutExample;","map":null,"metadata":{},"sourceType":"module"}