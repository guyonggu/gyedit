{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { Editor, Point, Range, Transforms } from \"slate\";\nimport { fixList } from \"./util\";\nvar SHORTCUTS = {\n  '*': 'ul-item',\n  '-': 'ul-item',\n  '+': 'ul-item',\n  '>': 'block-quote',\n  '#': 'heading-one',\n  '##': 'heading-two',\n  '###': 'heading-three',\n  '####': 'heading-four',\n  '#####': 'heading-five',\n  '######': 'heading-six'\n};\nexport var withMarkdown = function withMarkdown(editor) {\n  var deleteBackward = editor.deleteBackward,\n      insertText = editor.insertText,\n      insertBreak = editor.insertBreak;\n\n  var insertBreak2 = function insertBreak2() {\n    var handled = false;\n    var selection = editor.selection;\n\n    if (!selection || Range.isExpanded(selection)) {\n      insertBreak();\n      return;\n    }\n\n    var block = Editor.above(editor, {\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      }\n    });\n\n    if (!block || Editor.isEditor(block[0])) {\n      insertBreak();\n      return;\n    }\n\n    var parent = Editor.parent(editor, block[1]);\n\n    if (!parent || Editor.isEditor(parent[0])) {\n      insertBreak();\n      return;\n    }\n\n    var text = Editor.string(editor, block[1]);\n\n    if (text) {\n      insertBreak();\n      return;\n    }\n\n    var blockPath = block[1];\n    var indent = 0;\n\n    if (typeof parent[0].indent === \"number\") {\n      indent = parent[0].indent > 1 ? parent[0].indent - 1 : 0;\n    }\n\n    Transforms.setNodes(editor, {\n      type: 'paragraph',\n      indent: indent\n    }, {\n      at: blockPath\n    }); // if it is the last child\n\n    if (blockPath[blockPath.length - 1] === parent[0].children.length - 1) {\n      Transforms.liftNodes(editor, {\n        at: blockPath\n      });\n      return;\n    }\n  };\n\n  editor.insertBreak = function () {\n    insertBreak2();\n    fixList(editor);\n  };\n\n  editor.insertText = function (text) {\n    var selection = editor.selection;\n\n    if (text !== ' ' || !selection || !Range.isCollapsed(selection)) {\n      insertText(text);\n      return;\n    }\n\n    var anchor = selection.anchor;\n    var block = Editor.above(editor, {\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      }\n    });\n    var path = block ? block[1] : [];\n    var start = Editor.start(editor, path);\n    var range = {\n      anchor: anchor,\n      focus: start\n    };\n    var beforeText = Editor.string(editor, range);\n    var tabs = 0;\n\n    var _iterator = _createForOfIteratorHelper(beforeText),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var c = _step.value;\n\n        if (c === '\\t') {\n          tabs++;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    beforeText = beforeText.substr(tabs);\n    var blockType = block[0].type;\n    var inList = typeof blockType === 'string' ? blockType === 'list-item' : false;\n\n    if (text === ' ') {\n      var type = SHORTCUTS[beforeText];\n\n      if (!type && /^[1-9]\\d*\\./.test(beforeText)) {\n        type = 'ol-item';\n      }\n\n      var list;\n\n      switch (type) {\n        case 'ul-item':\n          if (inList) break;\n          Transforms.select(editor, range);\n          Transforms[\"delete\"](editor);\n          Transforms.setNodes(editor, {\n            type: 'list-item'\n          }, {\n            match: function match(n) {\n              return Editor.isBlock(editor, n);\n            }\n          });\n          list = {\n            type: 'bulleted-list',\n            indent: tabs,\n            children: []\n          };\n          Transforms.wrapNodes(editor, list, {\n            match: function match(n) {\n              return n.type === 'list-item';\n            }\n          });\n          break;\n\n        case 'ol-item':\n          if (inList) break;\n          var found = beforeText.match(/^([\\t]*)\\d+\\./);\n          Transforms.select(editor, range);\n          Transforms[\"delete\"](editor);\n          Transforms.setNodes(editor, {\n            type: 'list-item'\n          }, {\n            match: function match(n) {\n              return Editor.isBlock(editor, n);\n            }\n          });\n          list = {\n            type: 'numbered-list',\n            indent: tabs,\n            children: []\n          };\n          Transforms.wrapNodes(editor, list, {\n            match: function match(n) {\n              return n.type === 'list-item';\n            }\n          });\n          break;\n\n        case 'block-quote':\n          if (inList || blockType !== 'paragraph') {\n            insertText(text);\n            break;\n          }\n\n          var parent = Editor.above(editor, {\n            match: function match(n) {\n              return n.type === 'block-quote';\n            }\n          });\n\n          if (parent) {\n            insertText(text);\n            break;\n          }\n\n          Transforms.select(editor, range);\n          Transforms[\"delete\"](editor);\n          Transforms.wrapNodes(editor, {\n            type: 'block-quote',\n            children: []\n          }, {\n            match: function match(n) {\n              return n.type === 'paragraph';\n            }\n          });\n          break;\n\n        default:\n          insertText(text);\n      }\n\n      return;\n    }\n\n    insertText(text);\n  };\n\n  var deleteBackward2 = function deleteBackward2(unit) {\n    console.log(\"editor.deleteBackward:\", unit);\n    var selection = editor.selection;\n\n    if (!selection || Range.isExpanded(selection)) {\n      deleteBackward(unit);\n      return;\n    }\n\n    var match = Editor.above(editor, {\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      }\n    });\n\n    if (!match || Editor.isEditor(match[0])) {\n      deleteBackward(unit);\n      return;\n    }\n\n    var _ref = match,\n        _ref2 = _slicedToArray(_ref, 2),\n        block = _ref2[0],\n        path = _ref2[1];\n\n    var start = Editor.start(editor, path);\n\n    if (Point.equals(selection.anchor, start)) {\n      if (block.type === 'list-item') {\n        var _ref3 = Editor.parent(editor, path),\n            _ref4 = _slicedToArray(_ref3, 1),\n            listNode = _ref4[0];\n\n        if (listNode && listNode.indent > 0) {\n          Editor.withoutNormalizing(editor, function () {\n            Transforms.wrapNodes(editor, {\n              type: listNode.type,\n              indent: listNode.indent - 1,\n              children: []\n            }, {\n              at: path\n            });\n            Transforms.liftNodes(editor, {\n              at: path\n            });\n          });\n        } else {\n          Transforms.setNodes(editor, {\n            type: 'paragraph'\n          });\n          Transforms.unwrapNodes(editor, {\n            match: function match(n) {\n              return typeof n.type === 'string' && n.type.endsWith('-list');\n            },\n            split: true\n          }); // deleteBackward(unit)\n        }\n      } else if (block.type === 'paragraph') {\n        if (block.indent && block.indent > 0) {\n          Transforms.setNodes(editor, {\n            indent: block.indent - 1\n          }, {\n            at: path\n          });\n          return;\n        } else {\n          deleteBackward(unit);\n        }\n      } else {\n        Transforms.setNodes(editor, {\n          type: 'paragraph'\n        });\n      }\n\n      return;\n    } // end if at start\n\n\n    deleteBackward(unit);\n  };\n\n  editor.deleteBackward = function (unit) {\n    deleteBackward2(unit);\n    fixList(editor);\n  };\n\n  return editor;\n};\n\nvar beforeTextInBlock = function beforeTextInBlock(editor) {\n  var selection = editor.selection;\n\n  if (!selection) {\n    return '';\n  }\n\n  var block = Editor.above(editor, {\n    match: function match(n) {\n      return Editor.isBlock(editor, n);\n    }\n  });\n  var path = block ? block[1] : [];\n  var start = Editor.start(editor, path);\n  var range = {\n    anchor: Range.start(editor.selection),\n    focus: start\n  };\n  var beforeText = Editor.string(editor, range);\n  return beforeText;\n};","map":{"version":3,"sources":["/Users/yonggu/WebstormProjects/gyedit/src/withMarkdown.ts"],"names":["Editor","Point","Range","Transforms","fixList","SHORTCUTS","withMarkdown","editor","deleteBackward","insertText","insertBreak","insertBreak2","handled","selection","isExpanded","block","above","match","n","isBlock","isEditor","parent","text","string","blockPath","indent","setNodes","type","at","length","children","liftNodes","isCollapsed","anchor","path","start","range","focus","beforeText","tabs","c","substr","blockType","inList","test","list","select","wrapNodes","found","deleteBackward2","unit","console","log","equals","listNode","withoutNormalizing","unwrapNodes","endsWith","split","beforeTextInBlock"],"mappings":"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","sourcesContent":["import {Editor, Path, Point, Range, Transforms, NodeEntry} from \"slate\";\nimport { ListNode } from './types'\nimport { fixList } from \"./util\";\n\nconst SHORTCUTS = {\n    '*': 'ul-item',\n    '-': 'ul-item',\n    '+': 'ul-item',\n    '>': 'block-quote',\n    '#': 'heading-one',\n    '##': 'heading-two',\n    '###': 'heading-three',\n    '####': 'heading-four',\n    '#####': 'heading-five',\n    '######': 'heading-six',\n}\n\nexport const withMarkdown = (editor: Editor) => {\n    const {deleteBackward, insertText, insertBreak} = editor\n\n    const insertBreak2 = () => {\n        let handled = false\n        const {selection} = editor\n\n        if (!selection || Range.isExpanded(selection)) {\n            insertBreak()\n            return\n        }\n        const block = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n        })\n        if (!block || Editor.isEditor(block[0])) {\n            insertBreak()\n            return\n        }\n        const parent = Editor.parent(editor, block[1])\n        if (!parent || Editor.isEditor(parent[0])) {\n            insertBreak()\n            return\n        }\n        const text = Editor.string(editor, block[1])\n        if (text) {\n            insertBreak()\n            return\n        }\n        const blockPath: Path = block[1]\n        let indent = 0\n        if (typeof parent[0].indent === \"number\") {\n            indent = parent[0].indent > 1 ? parent[0].indent - 1 : 0\n        }\n        Transforms.setNodes(editor, {type: 'paragraph', indent}, {at: blockPath})\n        // if it is the last child\n        if (blockPath[blockPath.length - 1] === parent[0].children.length - 1) {\n            Transforms.liftNodes(editor, {at: blockPath})\n            return\n        }\n    }\n    editor.insertBreak = () => {\n        insertBreak2()\n        fixList(editor)\n    }\n    editor.insertText = (text: string) => {\n        const {selection} = editor\n        if ((text !== ' ') || !selection || !Range.isCollapsed(selection)) {\n            insertText(text)\n            return\n        }\n\n        const {anchor} = selection\n        const block = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n        })\n        const path = block ? block[1] : []\n        const start = Editor.start(editor, path)\n        const range = {anchor, focus: start}\n        let beforeText = Editor.string(editor, range)\n        let tabs = 0\n        for (let c of beforeText) {\n            if (c === '\\t') {\n                tabs++\n            }\n        }\n        beforeText = beforeText.substr(tabs)\n        const blockType = block![0].type as string\n        let inList = typeof blockType === 'string' ? blockType === 'list-item' : false\n\n        if (text === ' ') {\n\n            let type = SHORTCUTS[beforeText]\n\n            if (!type && /^[1-9]\\d*\\./.test(beforeText)) {\n                type = 'ol-item'\n            }\n            let list\n            switch (type) {\n                case 'ul-item':\n                    if (inList) break\n                    Transforms.select(editor, range)\n                    Transforms.delete(editor)\n                    Transforms.setNodes(\n                        editor,\n                        {type: 'list-item'},\n                        {match: n => Editor.isBlock(editor, n)}\n                    )\n                    list = {type: 'bulleted-list', indent: tabs, children: []}\n                    Transforms.wrapNodes(editor, list, {\n                        match: n => n.type === 'list-item',\n                    })\n                    break\n                case 'ol-item':\n                    if (inList) break\n                    const found = beforeText.match(/^([\\t]*)\\d+\\./)\n                    Transforms.select(editor, range)\n                    Transforms.delete(editor)\n                    Transforms.setNodes(\n                        editor,\n                        {type: 'list-item'},\n                        {match: n => Editor.isBlock(editor, n)}\n                    )\n                    list = {type: 'numbered-list', indent: tabs, children: []}\n                    Transforms.wrapNodes(editor, list, {\n                        match: n => n.type === 'list-item',\n                    })\n                    break\n                case 'block-quote':\n                    if (inList || blockType !== 'paragraph') {\n                        insertText(text)\n                        break\n                    }\n                    let parent = Editor.above(editor, {match: n => n.type === 'block-quote'})\n                    if (parent) {\n                        insertText(text)\n                        break\n                    }\n                    Transforms.select(editor, range)\n                    Transforms.delete(editor)\n                    Transforms.wrapNodes(editor, {type: 'block-quote', children: []}, {\n                        match: n => n.type === 'paragraph'\n                    })\n                    break\n                default:\n                    insertText(text)\n            }\n            return\n        }\n\n        insertText(text)\n    }\n\n    const deleteBackward2 = (unit: 'character' | 'word' | 'line' | 'block') => {\n        console.log(\"editor.deleteBackward:\", unit)\n        const {selection} = editor\n\n        if (!selection || Range.isExpanded(selection)) {\n            deleteBackward(unit)\n            return\n        }\n        const match = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n        })\n\n        if (!match || Editor.isEditor(match[0])) {\n            deleteBackward(unit)\n            return\n        }\n        const [block, path] = match as NodeEntry<ListNode>\n        const start = Editor.start(editor, path)\n\n        if (Point.equals(selection.anchor, start)) {\n            if (block.type === 'list-item') {\n                const [listNode] = Editor.parent(editor, path) as NodeEntry<ListNode>\n                if (listNode && (listNode.indent as number > 0)) {\n                    Editor.withoutNormalizing(editor, () => {\n                        Transforms.wrapNodes(editor, {\n                            type: listNode.type,\n                            indent: listNode.indent! - 1,\n                            children: []\n                        }, {at: path})\n                        Transforms.liftNodes(editor, {at: path})\n                    })\n                } else {\n                    Transforms.setNodes(editor, {type: 'paragraph'})\n                    Transforms.unwrapNodes(editor, {\n                        match: n => (typeof n.type === 'string' && n.type.endsWith('-list')),\n                        split: true,\n                    })\n                    // deleteBackward(unit)\n                }\n            } else if (block.type === 'paragraph') {\n                if (block.indent && block.indent > 0) {\n                    Transforms.setNodes(editor, {indent: block.indent - 1}, {at: path})\n                    return\n                } else {\n                    deleteBackward(unit)\n                }\n            } else {\n                Transforms.setNodes(editor, {type: 'paragraph'})\n            }\n            return\n        } // end if at start\n        deleteBackward(unit)\n    }\n\n    editor.deleteBackward = (unit: 'character' | 'word' | 'line' | 'block')=>{\n        deleteBackward2(unit)\n        fixList(editor)\n    }\n    return editor\n}\n\nconst beforeTextInBlock = (editor: Editor): string => {\n    const {selection} = editor\n    if (!selection) {\n        return ''\n    }\n    const block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n    })\n    const path = block ? block[1] : []\n    const start = Editor.start(editor, path)\n    const range = {anchor: Range.start(editor.selection!), focus: start}\n    let beforeText = Editor.string(editor, range)\n    return beforeText\n}"]},"metadata":{},"sourceType":"module"}