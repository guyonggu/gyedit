{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { Path, Editor, Transforms } from 'slate';\nexport var getListStart = function getListStart(editor, path) {\n  var listStart = [];\n\n  var _Editor$node = Editor.node(editor, path),\n      _Editor$node2 = _slicedToArray(_Editor$node, 1),\n      node = _Editor$node2[0];\n\n  if (!isListNode(node)) {\n    return listStart;\n  }\n\n  var curPath = path;\n  var options = {\n    index: 0\n  };\n\n  while (isListNode(node) && options.index >= 0) {\n    computeListStart(listStart, node, options);\n    var pre = Editor.previous(editor, {\n      at: curPath\n    });\n\n    if (!pre) {\n      break;\n    }\n\n    var _pre = _slicedToArray(pre, 2);\n\n    node = _pre[0];\n    curPath = _pre[1];\n  }\n\n  return listStart;\n};\nexport var isListNode = function isListNode(node) {\n  if (!node || !node.type || !node.type.endsWith('-list')) {\n    return false;\n  }\n\n  return true;\n};\n\nvar computeListStart = function computeListStart(listStart, node) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    index: 0\n  };\n  var indent = node.indent || 0;\n  var start = node.start || 1;\n\n  if (listStart.length && indent > options.index) {\n    return;\n  }\n\n  if (!listStart.length) {\n    for (var i = 0; i <= indent; i++) {\n      listStart.push(1);\n    }\n  }\n\n  if (node.type === 'numbered-list') {\n    listStart[indent] = start + node.children.length;\n  }\n\n  options.index = indent - 1;\n};\n\nexport var fixList = function fixList(editor, path) {\n  var entry;\n\n  if (!path) {\n    entry = Editor.above(editor, {\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      }\n    });\n  } else {\n    entry = Editor.node(editor, path);\n  }\n\n  if (!entry) {\n    return;\n  }\n\n  console.log(\"fix:\", entry[0].type);\n\n  if (entry[0].type === 'list-item') {\n    var _ref = Editor.parent(editor, entry[1]),\n        _ref2 = _slicedToArray(_ref, 2),\n        node = _ref2[0],\n        _path = _ref2[1];\n\n    var _ref3 = Editor.previous(editor, {\n      at: _path\n    }) || [undefined, undefined],\n        _ref4 = _slicedToArray(_ref3, 2),\n        preNode = _ref4[0],\n        prePath = _ref4[1];\n\n    var ref = Editor.pathRef(editor, _path); // merge left\n\n    if (isListNode(preNode) && preNode.type === node.type && preNode.indent === node.indent) {\n      Transforms.mergeNodes(editor, {\n        at: _path\n      });\n    } //merge right\n\n\n    var _ref5 = Editor.next(editor, {\n      at: ref.current\n    }) || [undefined, undefined],\n        _ref6 = _slicedToArray(_ref5, 2),\n        nextNode = _ref6[0],\n        nextPath = _ref6[1];\n\n    if (isListNode(nextNode) && nextNode.type === node.type && nextNode.indent === node.indent) {\n      Transforms.mergeNodes(editor, {\n        at: nextPath\n      });\n    }\n\n    var listStart = prePath ? getListStart(editor, prePath) : [];\n    console.log(\"updateListStart:\", listStart);\n    updateListStart(editor, Path.next(ref.unref()), listStart);\n  } else {\n    var next = Editor.next(editor, {\n      at: entry[1]\n    });\n\n    if (next && isListNode(next[0])) {\n      console.log(\"updateListStart:\", []);\n      updateListStart(editor, next[1], []);\n    }\n  }\n};\n\nvar updateListStart = function updateListStart(editor, path, listStart) {\n  var _Editor$node3 = Editor.node(editor, path),\n      _Editor$node4 = _slicedToArray(_Editor$node3, 1),\n      node = _Editor$node4[0];\n\n  while (isListNode(node)) {\n    var indent = node.indent || 0;\n    var start = listStart[indent] || 1;\n\n    if (node.type === 'numbered-list') {\n      Transforms.setNodes(editor, {\n        start: listStart[indent]\n      }, {\n        at: path\n      });\n    }\n\n    listStart.splice(indent + 1);\n\n    if (node.type === 'numbered-list') {\n      listStart[indent] = start + node.children.length;\n    } else {\n      listStart[indent] = 1;\n    } // node.start = listStart[node.indent]\n\n\n    path = Path.next(path);\n\n    var _Editor$node5 = Editor.node(editor, path);\n\n    var _Editor$node6 = _slicedToArray(_Editor$node5, 1);\n\n    node = _Editor$node6[0];\n  }\n};","map":{"version":3,"sources":["/Users/yonggu/WebstormProjects/gyedit/src/util.ts"],"names":["Path","Editor","Transforms","getListStart","editor","path","listStart","node","isListNode","curPath","options","index","computeListStart","pre","previous","at","type","endsWith","indent","start","length","i","push","children","fixList","entry","above","match","n","isBlock","console","log","parent","undefined","preNode","prePath","ref","pathRef","mergeNodes","next","current","nextNode","nextPath","updateListStart","unref","setNodes","splice"],"mappings":"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","sourcesContent":["import {Path, Node, Editor, Transforms, NodeEntry, Ancestor} from 'slate'\nimport {ListNode} from \"./types\";\n\nexport const getListStart = (editor: Editor, path: Path): number[] => {\n    let listStart: number[] = []\n    let [node] = Editor.node(editor, path)\n    if (!isListNode(node)){\n        return listStart\n    }\n    let curPath: Path = path\n    let options = {\n        index: 0\n    }\n    while (isListNode(node) && options.index >= 0) {\n        computeListStart(listStart, node, options)\n        const pre: any = Editor.previous(editor, {at: curPath})\n        if (!pre) {\n            break\n        }\n        [node, curPath] = pre\n    }\n    return listStart\n}\n\nexport const isListNode = (node: Node | undefined): node is ListNode => {\n    if (!node || !node.type || !(node.type as string).endsWith('-list')) {\n        return false\n    }\n    return true\n}\n\nconst computeListStart = (listStart: number[], node: ListNode, options: { index: number } = {index: 0}): void => {\n    let indent = node.indent || 0\n    let start = node.start || 1\n    if (listStart.length && indent > options.index) {\n        return\n    }\n    if (!listStart.length) {\n        for (let i = 0; i <= indent; i++) {\n            listStart.push(1)\n        }\n    }\n    if (node.type === 'numbered-list') {\n        listStart[indent] = start + node.children.length\n    }\n    options.index = indent - 1\n}\n\nexport const fixList = (editor:Editor, path?:Path): void => {\n    let entry:NodeEntry | undefined\n    if (!path){\n        entry = Editor.above(editor, {\n            match: n => Editor.isBlock(editor,n)\n        })\n    }else{\n        entry = Editor.node(editor,path)\n    }\n    if (!entry){\n        return\n    }\n    console.log(\"fix:\",entry[0].type)\n    if (entry[0].type === 'list-item') {\n        const [node, path] = Editor.parent(editor,entry[1]) as NodeEntry<ListNode>\n        const [preNode, prePath] = Editor.previous(editor, {at: path}) || [undefined, undefined]\n        const ref = Editor.pathRef(editor, path)\n        // merge left\n        if (isListNode(preNode) && preNode.type === node.type && preNode.indent === node.indent) {\n            Transforms.mergeNodes(editor, {at: path})\n        }\n        //merge right\n        const [nextNode, nextPath] = Editor.next(editor, {at:ref.current!}) || [undefined, undefined]\n        if (isListNode(nextNode) && nextNode.type === node.type && nextNode.indent === node.indent){\n            Transforms.mergeNodes(editor, {at: nextPath})\n        }\n\n        let listStart: number[] = prePath ? getListStart(editor, prePath) : []\n        console.log(\"updateListStart:\", listStart)\n        updateListStart(editor, Path.next(ref.unref()!), listStart)\n    }else {\n        const next = Editor.next(editor, {at:entry[1]})\n        if (next && isListNode(next[0])){\n            console.log(\"updateListStart:\", [])\n            updateListStart(editor, next[1], [])\n        }\n    }\n}\n\nconst updateListStart = (editor:Editor, path:Path, listStart:number[]):void => {\n    let [node] = Editor.node(editor, path)\n    while (isListNode(node)){\n        const indent = node.indent || 0\n        const start = listStart[indent] || 1\n\n        if (node.type === 'numbered-list') {\n            Transforms.setNodes(editor,{start:listStart[indent]}, {at:path})\n        }\n        listStart.splice(indent+1)\n\n        if (node.type === 'numbered-list'){\n            listStart[indent] = start + node.children.length\n        }else{\n            listStart[indent] = 1\n        }\n\n        // node.start = listStart[node.indent]\n\n        path = Path.next(path);\n        [node] = Editor.node(editor, path)\n    }\n}"]},"metadata":{},"sourceType":"module"}