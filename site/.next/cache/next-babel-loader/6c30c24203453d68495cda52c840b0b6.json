{"ast":null,"code":"import { Path, Node, Editor, Transforms } from 'slate';\nexport const getListStart = (editor, path) => {\n  let listStart = [];\n  let [node] = Editor.node(editor, path);\n\n  if (!isListNode(node)) {\n    return listStart;\n  }\n\n  let curPath = path;\n  let options = {\n    index: 0\n  };\n\n  while (isListNode(node) && options.index >= 0) {\n    computeListStart(listStart, node, options);\n    const pre = Editor.previous(editor, {\n      at: curPath\n    });\n\n    if (!pre) {\n      break;\n    }\n\n    [node, curPath] = pre;\n  }\n\n  return listStart;\n};\nexport const isListNode = node => {\n  if (!node || !node.type || !node.type.endsWith('-list')) {\n    return false;\n  }\n\n  return true;\n};\n\nconst computeListStart = (listStart, node, options = {\n  index: 0\n}) => {\n  let indent = node.indent || 0;\n  let start = node.start || 1;\n\n  if (listStart.length && indent > options.index) {\n    return;\n  }\n\n  if (!listStart.length) {\n    for (let i = 0; i <= indent; i++) {\n      listStart.push(1);\n    }\n  }\n\n  if (node.type === 'numbered-list') {\n    listStart[indent] = start + node.children.length;\n  }\n\n  options.index = indent - 1;\n};\n\nexport const fixList = (editor, path) => {\n  let entry;\n\n  if (!path) {\n    entry = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n)\n    });\n  } else {\n    entry = Editor.node(editor, path);\n  }\n\n  if (!entry) {\n    return;\n  }\n\n  if (entry[0].type === 'list-item') {\n    const [node, path] = Editor.parent(editor, entry[1]);\n    const [preNode, prePath] = Editor.previous(editor, {\n      at: path\n    }) || [undefined, undefined];\n    const ref = Editor.pathRef(editor, path);\n    console.log(\"fix:\", node.type, \"at:\", path); // merge left\n\n    if (isListNode(preNode) && preNode.type === node.type && preNode.indent === node.indent) {\n      Transforms.mergeNodes(editor, {\n        at: path\n      });\n    } //merge right\n\n\n    const [nextNode, nextPath] = Editor.next(editor, {\n      at: ref.current\n    }) || [undefined, undefined];\n\n    if (isListNode(nextNode) && nextNode.type === node.type && nextNode.indent === node.indent) {\n      Transforms.mergeNodes(editor, {\n        at: nextPath\n      });\n    }\n\n    let listStart = [];\n    let updatePath;\n\n    if (prePath && isListNode(preNode)) {\n      listStart = getListStart(editor, prePath);\n      updatePath = Path.next(prePath);\n    } else {\n      updatePath = ref.unref();\n    }\n\n    console.log(\"updateListStart:\", listStart, \"at:\", updatePath);\n    updateListStart(editor, updatePath, listStart);\n  } else {\n    const next = Editor.next(editor, {\n      at: entry[1]\n    });\n\n    if (next && isListNode(next[0])) {\n      console.log(\"updateListStart:\", [], \"at:\", next[1]);\n      updateListStart(editor, next[1], []);\n    }\n  }\n};\n\nconst updateListStart = (editor, path, listStart) => {\n  if (!Node.has(editor, path)) {\n    return;\n  }\n\n  let [node] = Editor.node(editor, path);\n\n  while (isListNode(node)) {\n    const indent = node.indent || 0;\n    const start = listStart[indent] || 1;\n\n    if (node.type === 'numbered-list') {\n      Transforms.setNodes(editor, {\n        start: listStart[indent]\n      }, {\n        at: path\n      });\n    }\n\n    listStart.splice(indent + 1);\n\n    if (node.type === 'numbered-list') {\n      listStart[indent] = start + node.children.length;\n    } else {\n      listStart[indent] = 1;\n    } // node.start = listStart[node.indent]\n\n\n    const entry = Editor.next(editor, {\n      at: path\n    });\n\n    if (!entry) {\n      break;\n    }\n\n    [node, path] = entry;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}