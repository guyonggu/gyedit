{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { Editor, Point, Range, Element, Transforms } from \"slate\";\nimport { fixList, isListNode } from \"./util\";\nvar SHORTCUTS = {\n  '*': 'ul-item',\n  '-': 'ul-item',\n  '+': 'ul-item',\n  '>': 'block-quote',\n  '#': 'heading-one',\n  '##': 'heading-two',\n  '###': 'heading-three',\n  '####': 'heading-four',\n  '#####': 'heading-five',\n  '######': 'heading-six'\n};\nexport var withMarkdown = function withMarkdown(editor) {\n  var deleteBackward = editor.deleteBackward,\n      insertText = editor.insertText,\n      insertBreak = editor.insertBreak,\n      deleteFragment = editor.deleteFragment,\n      normalizeNode = editor.normalizeNode;\n\n  var insertBreak2 = function insertBreak2() {\n    var handled = false;\n    var selection = editor.selection;\n\n    if (!selection || Range.isExpanded(selection)) {\n      insertBreak();\n      return;\n    }\n\n    var block = Editor.above(editor, {\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      }\n    });\n\n    if (!block || Editor.isEditor(block[0])) {\n      insertBreak();\n      return;\n    }\n\n    var parent = Editor.parent(editor, block[1]);\n\n    if (!parent || Editor.isEditor(parent[0])) {\n      insertBreak();\n      return;\n    }\n\n    var text = Editor.string(editor, block[1]);\n\n    if (text) {\n      insertBreak();\n      return;\n    }\n\n    var blockPath = block[1];\n    var indent = 0;\n\n    if (typeof parent[0].indent === \"number\") {\n      indent = parent[0].indent > 1 ? parent[0].indent - 1 : 0;\n    }\n\n    Transforms.setNodes(editor, {\n      type: 'paragraph',\n      indent: indent\n    }, {\n      at: blockPath\n    }); // if it is the last child\n\n    if (blockPath[blockPath.length - 1] === parent[0].children.length - 1) {\n      Transforms.liftNodes(editor, {\n        at: blockPath\n      });\n      return;\n    }\n  };\n\n  editor.insertBreak = function () {\n    Editor.withoutNormalizing(editor, function () {\n      insertBreak2();\n      fixList(editor);\n    });\n  };\n\n  editor.insertText = function (text) {\n    var selection = editor.selection;\n\n    if (text !== ' ' || !selection || !Range.isCollapsed(selection)) {\n      insertText(text);\n      return;\n    }\n\n    var anchor = selection.anchor;\n    var block = Editor.above(editor, {\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      }\n    });\n    var path = block ? block[1] : [];\n    var start = Editor.start(editor, path);\n    var range = {\n      anchor: anchor,\n      focus: start\n    };\n    var beforeText = Editor.string(editor, range);\n    var tabs = 0;\n\n    var _iterator = _createForOfIteratorHelper(beforeText),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var c = _step.value;\n\n        if (c === '\\t') {\n          tabs++;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    beforeText = beforeText.substr(tabs);\n    var blockType = block[0].type;\n    var inList = typeof blockType === 'string' ? blockType === 'list-item' : false;\n    var type = SHORTCUTS[beforeText];\n\n    if (!type && /^[1-9]\\d*\\./.test(beforeText)) {\n      type = 'ol-item';\n    }\n\n    var list;\n\n    switch (type) {\n      case 'ul-item':\n        if (inList) {\n          insertText(text);\n          break;\n        }\n\n        Transforms.select(editor, range);\n        Transforms[\"delete\"](editor);\n        Transforms.setNodes(editor, {\n          type: 'list-item'\n        }, {\n          match: function match(n) {\n            return Editor.isBlock(editor, n);\n          }\n        });\n        list = {\n          type: 'bulleted-list',\n          indent: tabs,\n          children: []\n        };\n        Transforms.wrapNodes(editor, list, {\n          match: function match(n) {\n            return n.type === 'list-item';\n          }\n        });\n        fixList(editor);\n        break;\n\n      case 'ol-item':\n        if (inList) {\n          insertText(text);\n          break;\n        }\n\n        var found = beforeText.match(/^([\\t]*)\\d+\\./);\n        Transforms.select(editor, range);\n        Transforms[\"delete\"](editor);\n        Transforms.setNodes(editor, {\n          type: 'list-item'\n        }, {\n          match: function match(n) {\n            return Editor.isBlock(editor, n);\n          }\n        });\n        list = {\n          type: 'numbered-list',\n          indent: tabs,\n          children: []\n        };\n        Transforms.wrapNodes(editor, list, {\n          match: function match(n) {\n            return n.type === 'list-item';\n          }\n        });\n        fixList(editor);\n        break;\n\n      case 'block-quote':\n        if (inList || blockType !== 'paragraph') {\n          insertText(text);\n          break;\n        }\n\n        var parent = Editor.above(editor, {\n          match: function match(n) {\n            return n.type === 'block-quote';\n          }\n        });\n\n        if (parent) {\n          insertText(text);\n          break;\n        }\n\n        Transforms.select(editor, range);\n        Transforms[\"delete\"](editor);\n        Transforms.wrapNodes(editor, {\n          type: 'block-quote',\n          children: []\n        }, {\n          match: function match(n) {\n            return n.type === 'paragraph';\n          }\n        });\n        break;\n\n      default:\n        insertText(text);\n    }\n\n    return;\n  };\n\n  var deleteBackward2 = function deleteBackward2(unit) {\n    console.log(\"editor.deleteBackward:\", unit);\n    var selection = editor.selection;\n\n    if (!selection || Range.isExpanded(selection)) {\n      deleteBackward(unit);\n      return;\n    }\n\n    var match = Editor.above(editor, {\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      }\n    });\n\n    if (!match || Editor.isEditor(match[0])) {\n      deleteBackward(unit);\n      return;\n    }\n\n    var _ref = match,\n        _ref2 = _slicedToArray(_ref, 2),\n        block = _ref2[0],\n        path = _ref2[1];\n\n    var start = Editor.start(editor, path);\n\n    if (Point.equals(selection.anchor, start)) {\n      if (block.type === 'list-item') {\n        var _ref3 = Editor.parent(editor, path),\n            _ref4 = _slicedToArray(_ref3, 1),\n            listNode = _ref4[0];\n\n        if (listNode && listNode.indent > 0) {\n          Editor.withoutNormalizing(editor, function () {\n            Transforms.wrapNodes(editor, {\n              type: listNode.type,\n              indent: listNode.indent - 1,\n              children: []\n            }, {\n              at: path\n            });\n            Transforms.liftNodes(editor, {\n              at: path\n            });\n          });\n        } else {\n          Transforms.setNodes(editor, {\n            type: 'paragraph'\n          });\n          Transforms.unwrapNodes(editor, {\n            match: function match(n) {\n              return typeof n.type === 'string' && n.type.endsWith('-list');\n            },\n            split: true\n          }); // deleteBackward(unit)\n        }\n      } else if (block.type === 'paragraph') {\n        if (block.indent && block.indent > 0) {\n          Transforms.setNodes(editor, {\n            indent: block.indent - 1\n          }, {\n            at: path\n          });\n          return;\n        } else {\n          deleteBackward(unit);\n        }\n      } else {\n        Transforms.setNodes(editor, {\n          type: 'paragraph'\n        });\n      }\n\n      return;\n    } // end if at start\n\n\n    deleteBackward(unit);\n  };\n\n  editor.deleteBackward = function (unit) {\n    Editor.withoutNormalizing(editor, function () {\n      deleteBackward2(unit);\n      fixList(editor);\n    });\n  };\n\n  editor.deleteFragment = function () {\n    // console.log(\"editor.deleteFragment:\")\n    deleteFragment();\n  };\n\n  editor.normalizeNode = function (entry) {\n    if (Element.isElement(entry[0]) && entry[0].type !== 'list-item') {\n      var _ref5 = Editor.parent(editor, entry[1]),\n          _ref6 = _slicedToArray(_ref5, 1),\n          pNode = _ref6[0];\n\n      if (isListNode(pNode)) {\n        Transforms.setNodes(editor, {\n          type: 'list-item'\n        }, {\n          at: entry[1]\n        });\n      }\n    }\n\n    normalizeNode(entry);\n  };\n\n  return editor;\n};\n\nvar beforeTextInBlock = function beforeTextInBlock(editor) {\n  var selection = editor.selection;\n\n  if (!selection) {\n    return '';\n  }\n\n  var block = Editor.above(editor, {\n    match: function match(n) {\n      return Editor.isBlock(editor, n);\n    }\n  });\n  var path = block ? block[1] : [];\n  var start = Editor.start(editor, path);\n  var range = {\n    anchor: Range.start(editor.selection),\n    focus: start\n  };\n  var beforeText = Editor.string(editor, range);\n  return beforeText;\n}; //\n// Transforms.delete =(\n//     editor: Editor,\n//     options: {\n//     at?: Location\n//     distance?: number\n//     unit?: 'character' | 'word' | 'line' | 'block'\n//     reverse?: boolean\n//     hanging?: boolean\n//     voids?: boolean\n// } = {}\n// ):void => {\n//     Editor.withoutNormalizing(editor, () => {\n//         const {\n//             reverse = false,\n//             unit = 'character',\n//             distance = 1,\n//             voids = false,\n//         } = options\n//         let { at = editor.selection, hanging = false } = options\n//\n//         if (!at) {\n//             return\n//         }\n//\n//         if (Range.isRange(at) && Range.isCollapsed(at)) {\n//             at = at.anchor\n//         }\n//\n//         if (Point.isPoint(at)) {\n//             const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n//\n//             if (!voids && furthestVoid) {\n//                 const [, voidPath] = furthestVoid\n//                 at = voidPath\n//             } else {\n//                 const opts = { unit, distance }\n//                 const target = reverse\n//                     ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n//                     : Editor.after(editor, at, opts) || Editor.end(editor, [])\n//                 at = { anchor: at, focus: target }\n//                 hanging = true\n//             }\n//         }\n//\n//         if (Path.isPath(at)) {\n//             Transforms.removeNodes(editor, { at, voids })\n//             return\n//         }\n//\n//         if (Range.isCollapsed(at)) {\n//             return\n//         }\n//\n//         if (!hanging) {\n//             at = Editor.unhangRange(editor, at, { voids })\n//         }\n//\n//         let [start, end] = Range.edges(at)\n//         const startBlock = Editor.above(editor, {\n//             match: n => Editor.isBlock(editor, n),\n//             at: start,\n//             voids,\n//         })\n//         const endBlock = Editor.above(editor, {\n//             match: n => Editor.isBlock(editor, n),\n//             at: end,\n//             voids,\n//         })\n//         const isAcrossBlocks =\n//             startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n//         const isSingleText = Path.equals(start.path, end.path)\n//         const startVoid = voids\n//             ? null\n//             : Editor.void(editor, { at: start, mode: 'highest' })\n//         const endVoid = voids\n//             ? null\n//             : Editor.void(editor, { at: end, mode: 'highest' })\n//\n//         // If the start or end points are inside an inline void, nudge them out.\n//         if (startVoid) {\n//             const before = Editor.before(editor, start)\n//\n//             if (\n//                 before &&\n//                 startBlock &&\n//                 Path.isAncestor(startBlock[1], before.path)\n//             ) {\n//                 start = before\n//             }\n//         }\n//\n//         if (endVoid) {\n//             const after = Editor.after(editor, end)\n//\n//             if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n//                 end = after\n//             }\n//         }\n//\n//         // Get the highest nodes that are completely inside the range, as well as\n//         // the start and end nodes.\n//         const matches: NodeEntry[] = []\n//         let lastPath: Path | undefined\n//\n//         for (const entry of Editor.nodes(editor, { at, voids })) {\n//             const [node, path] = entry\n//\n//             if (lastPath && Path.compare(path, lastPath) === 0) {\n//                 continue\n//             }\n//\n//             if (\n//                 (!voids && Editor.isVoid(editor, node)) ||\n//                 (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n//             ) {\n//                 matches.push(entry)\n//                 lastPath = path\n//             }\n//         }\n//\n//         const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n//         const startRef = Editor.pointRef(editor, start)\n//         const endRef = Editor.pointRef(editor, end)\n//\n//         if (!isSingleText && !startVoid) {\n//             const point = startRef.current!\n//             const [node] = Editor.leaf(editor, point)\n//             const { path } = point\n//             const { offset } = start\n//             const text = node.text.slice(offset)\n//             editor.apply({ type: 'remove_text', path, offset, text })\n//         }\n//\n//         for (const pathRef of pathRefs) {\n//             const path = pathRef.unref()!\n//             console.log(\"remove not at:\", path)\n//             Transforms.removeNodes(editor, { at: path, voids })\n//         }\n//\n//         if (!endVoid) {\n//             const point = endRef.current!\n//             const [node] = Editor.leaf(editor, point)\n//             const { path } = point\n//             const offset = isSingleText ? start.offset : 0\n//             const text = node.text.slice(offset, end.offset)\n//             editor.apply({ type: 'remove_text', path, offset, text })\n//         }\n//\n//         if (\n//             !isSingleText &&\n//             isAcrossBlocks &&\n//             endRef.current &&\n//             startRef.current\n//         ) {\n//             console.log(\"merge node at:\", endRef.current)\n//             Transforms.mergeNodes(editor, {\n//                 at: endRef.current,\n//                 hanging: true,\n//                 voids,\n//             })\n//         }\n//\n//         const point = endRef.unref() || startRef.unref()\n//\n//         if (options.at == null && point) {\n//             Transforms.select(editor, point)\n//         }\n//     })\n// }\n//\n// Transforms.mergeNodes = (\n//     editor: Editor,\n//     options: {\n//     at?: Location\n//     match?: (node: Node) => boolean\n//     mode?: 'highest' | 'lowest'\n//     hanging?: boolean\n//     voids?: boolean\n// } = {}\n// ) => {\n//     Editor.withoutNormalizing(editor, () => {\n//         let { match, at = editor.selection } = options\n//         const { hanging = false, voids = false, mode = 'lowest' } = options\n//\n//         if (!at) {\n//             return\n//         }\n//\n//         if (match == null) {\n//             if (Path.isPath(at)) {\n//                 const [parent] = Editor.parent(editor, at)\n//                 match = n => parent.children.includes(n)\n//             } else {\n//                 match = n => Editor.isBlock(editor, n)\n//             }\n//         }\n//\n//         if (!hanging && Range.isRange(at)) {\n//             at = Editor.unhangRange(editor, at)\n//         }\n//\n//         if (Range.isRange(at)) {\n//             if (Range.isCollapsed(at)) {\n//                 at = at.anchor\n//             } else {\n//                 const [, end] = Range.edges(at)\n//                 const pointRef = Editor.pointRef(editor, end)\n//                 Transforms.delete(editor, { at })\n//                 at = pointRef.unref()!\n//\n//                 if (options.at == null) {\n//                     Transforms.select(editor, at)\n//                 }\n//             }\n//         }\n//\n//         const [current] = Editor.nodes(editor, { at, match, voids, mode })\n//         const prev = Editor.previous(editor, { at, match, voids, mode })\n//\n//         if (!current || !prev) {\n//             return\n//         }\n//\n//         const [node, path] = current\n//         const [prevNode, prevPath] = prev\n//\n//         if (path.length === 0 || prevPath.length === 0) {\n//             return\n//         }\n//\n//         const newPath = Path.next(prevPath)\n//         const commonPath = Path.common(path, prevPath)\n//         const isPreviousSibling = Path.isSibling(path, prevPath)\n//         const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\n//             .slice(commonPath.length)\n//             .slice(0, -1)\n//\n//         // Determine if the merge will leave an ancestor of the path empty as a\n//         // result, in which case we'll want to remove it after merging.\n//         const emptyAncestor = Editor.above(editor, {\n//             at: path,\n//             mode: 'highest',\n//             match: n =>\n//                 levels.includes(n) && Element.isElement(n) && n.children.length === 1,\n//         })\n//\n//         const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n//         let properties\n//         let position\n//\n//         // Ensure that the nodes are equivalent, and figure out what the position\n//         // and extra properties of the merge will be.\n//         if (Text.isText(node) && Text.isText(prevNode)) {\n//             const { text, ...rest } = node\n//             position = prevNode.text.length\n//             properties = rest as Partial<Text>\n//         } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n//             const { children, ...rest } = node\n//             position = prevNode.children.length\n//             properties = rest as Partial<Element>\n//         } else {\n//             throw new Error(\n//                 `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n//                     node\n//                 )} ${JSON.stringify(prevNode)}`\n//             )\n//         }\n//\n//         // If the node isn't already the next sibling of the previous node, move\n//         // it so that it is before merging.\n//         if (!isPreviousSibling) {\n//             console.log(\"In merge, movNodes from \", path, \"to\", newPath)\n//             Transforms.moveNodes(editor, { at: path, to: newPath, voids })\n//         }\n//\n//         // If there was going to be an empty ancestor of the node that was merged,\n//         // we remove it from the tree.\n//         if (emptyRef) {\n//             console.log(\"In merge, remove node at:\", emptyRef.current)\n//             Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\n//         }\n//\n//         // If the target node that we're merging with is empty, remove it instead\n//         // of merging the two. This is a common rich text editor behavior to\n//         // prevent losing formatting when deleting entire nodes when you have a\n//         // hanging selection.\n//         if (\n//             (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n//             (Text.isText(prevNode) && prevNode.text === '')\n//         ) {\n//             console.log(\"In merge, remove2\", prevNode.type, \"node at:\", prevPath)\n//             Transforms.removeNodes(editor, { at: prevPath, voids })\n//         } else {\n//             editor.apply({\n//                 type: 'merge_node',\n//                 path: newPath,\n//                 position,\n//                 properties,\n//             })\n//         }\n//\n//         if (emptyRef) {\n//             emptyRef.unref()\n//         }\n//     })\n// }","map":null,"metadata":{},"sourceType":"module"}