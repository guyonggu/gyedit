{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { Editor, Path, Point, Range, Transforms } from \"slate\";\nimport { fixList } from \"./util\";\nvar SHORTCUTS = {\n  '*': 'ul-item',\n  '-': 'ul-item',\n  '+': 'ul-item',\n  '>': 'block-quote',\n  '#': 'heading-one',\n  '##': 'heading-two',\n  '###': 'heading-three',\n  '####': 'heading-four',\n  '#####': 'heading-five',\n  '######': 'heading-six'\n};\nexport var withMarkdown = function withMarkdown(editor) {\n  var deleteBackward = editor.deleteBackward,\n      insertText = editor.insertText,\n      insertBreak = editor.insertBreak,\n      deleteFragment = editor.deleteFragment;\n\n  var insertBreak2 = function insertBreak2() {\n    var handled = false;\n    var selection = editor.selection;\n\n    if (!selection || Range.isExpanded(selection)) {\n      insertBreak();\n      return;\n    }\n\n    var block = Editor.above(editor, {\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      }\n    });\n\n    if (!block || Editor.isEditor(block[0])) {\n      insertBreak();\n      return;\n    }\n\n    var parent = Editor.parent(editor, block[1]);\n\n    if (!parent || Editor.isEditor(parent[0])) {\n      insertBreak();\n      return;\n    }\n\n    var text = Editor.string(editor, block[1]);\n\n    if (text) {\n      insertBreak();\n      return;\n    }\n\n    var blockPath = block[1];\n    var indent = 0;\n\n    if (typeof parent[0].indent === \"number\") {\n      indent = parent[0].indent > 1 ? parent[0].indent - 1 : 0;\n    }\n\n    Transforms.setNodes(editor, {\n      type: 'paragraph',\n      indent: indent\n    }, {\n      at: blockPath\n    }); // if it is the last child\n\n    if (blockPath[blockPath.length - 1] === parent[0].children.length - 1) {\n      Transforms.liftNodes(editor, {\n        at: blockPath\n      });\n      return;\n    }\n  };\n\n  editor.insertBreak = function () {\n    insertBreak2();\n    fixList(editor);\n  };\n\n  editor.insertText = function (text) {\n    var selection = editor.selection;\n\n    if (text !== ' ' || !selection || !Range.isCollapsed(selection)) {\n      insertText(text);\n      return;\n    }\n\n    var anchor = selection.anchor;\n    var block = Editor.above(editor, {\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      }\n    });\n    var path = block ? block[1] : [];\n    var start = Editor.start(editor, path);\n    var range = {\n      anchor: anchor,\n      focus: start\n    };\n    var beforeText = Editor.string(editor, range);\n    var tabs = 0;\n\n    var _iterator = _createForOfIteratorHelper(beforeText),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var c = _step.value;\n\n        if (c === '\\t') {\n          tabs++;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    beforeText = beforeText.substr(tabs);\n    var blockType = block[0].type;\n    var inList = typeof blockType === 'string' ? blockType === 'list-item' : false;\n    var type = SHORTCUTS[beforeText];\n\n    if (!type && /^[1-9]\\d*\\./.test(beforeText)) {\n      type = 'ol-item';\n    }\n\n    var list;\n\n    switch (type) {\n      case 'ul-item':\n        if (inList) {\n          insertText(text);\n          break;\n        }\n\n        Transforms.select(editor, range);\n        Transforms[\"delete\"](editor);\n        Transforms.setNodes(editor, {\n          type: 'list-item'\n        }, {\n          match: function match(n) {\n            return Editor.isBlock(editor, n);\n          }\n        });\n        list = {\n          type: 'bulleted-list',\n          indent: tabs,\n          children: []\n        };\n        Transforms.wrapNodes(editor, list, {\n          match: function match(n) {\n            return n.type === 'list-item';\n          }\n        });\n        fixList(editor);\n        break;\n\n      case 'ol-item':\n        if (inList) {\n          insertText(text);\n          break;\n        }\n\n        var found = beforeText.match(/^([\\t]*)\\d+\\./);\n        Transforms.select(editor, range);\n        Transforms[\"delete\"](editor);\n        Transforms.setNodes(editor, {\n          type: 'list-item'\n        }, {\n          match: function match(n) {\n            return Editor.isBlock(editor, n);\n          }\n        });\n        list = {\n          type: 'numbered-list',\n          indent: tabs,\n          children: []\n        };\n        Transforms.wrapNodes(editor, list, {\n          match: function match(n) {\n            return n.type === 'list-item';\n          }\n        });\n        fixList(editor);\n        break;\n\n      case 'block-quote':\n        if (inList || blockType !== 'paragraph') {\n          insertText(text);\n          break;\n        }\n\n        var parent = Editor.above(editor, {\n          match: function match(n) {\n            return n.type === 'block-quote';\n          }\n        });\n\n        if (parent) {\n          insertText(text);\n          break;\n        }\n\n        Transforms.select(editor, range);\n        Transforms[\"delete\"](editor);\n        Transforms.wrapNodes(editor, {\n          type: 'block-quote',\n          children: []\n        }, {\n          match: function match(n) {\n            return n.type === 'paragraph';\n          }\n        });\n        break;\n\n      default:\n        insertText(text);\n    }\n\n    return;\n  };\n\n  var deleteBackward2 = function deleteBackward2(unit) {\n    console.log(\"editor.deleteBackward:\", unit);\n    var selection = editor.selection;\n\n    if (!selection || Range.isExpanded(selection)) {\n      deleteBackward(unit);\n      return;\n    }\n\n    var match = Editor.above(editor, {\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      }\n    });\n\n    if (!match || Editor.isEditor(match[0])) {\n      deleteBackward(unit);\n      return;\n    }\n\n    var _ref = match,\n        _ref2 = _slicedToArray(_ref, 2),\n        block = _ref2[0],\n        path = _ref2[1];\n\n    var start = Editor.start(editor, path);\n\n    if (Point.equals(selection.anchor, start)) {\n      if (block.type === 'list-item') {\n        var _ref3 = Editor.parent(editor, path),\n            _ref4 = _slicedToArray(_ref3, 1),\n            listNode = _ref4[0];\n\n        if (listNode && listNode.indent > 0) {\n          Editor.withoutNormalizing(editor, function () {\n            Transforms.wrapNodes(editor, {\n              type: listNode.type,\n              indent: listNode.indent - 1,\n              children: []\n            }, {\n              at: path\n            });\n            Transforms.liftNodes(editor, {\n              at: path\n            });\n          });\n        } else {\n          Transforms.setNodes(editor, {\n            type: 'paragraph'\n          });\n          Transforms.unwrapNodes(editor, {\n            match: function match(n) {\n              return typeof n.type === 'string' && n.type.endsWith('-list');\n            },\n            split: true\n          }); // deleteBackward(unit)\n        }\n      } else if (block.type === 'paragraph') {\n        if (block.indent && block.indent > 0) {\n          Transforms.setNodes(editor, {\n            indent: block.indent - 1\n          }, {\n            at: path\n          });\n          return;\n        } else {\n          deleteBackward(unit);\n        }\n      } else {\n        Transforms.setNodes(editor, {\n          type: 'paragraph'\n        });\n      }\n\n      return;\n    } // end if at start\n\n\n    deleteBackward(unit);\n  };\n\n  editor.deleteBackward = function (unit) {\n    console.log(\"editor.deleteBackward:\", unit);\n    deleteBackward2(unit);\n    fixList(editor);\n  };\n\n  editor.deleteFragment = function () {\n    console.log(\"editor.deleteFragment:\");\n    deleteFragment();\n  };\n\n  return editor;\n};\n\nvar beforeTextInBlock = function beforeTextInBlock(editor) {\n  var selection = editor.selection;\n\n  if (!selection) {\n    return '';\n  }\n\n  var block = Editor.above(editor, {\n    match: function match(n) {\n      return Editor.isBlock(editor, n);\n    }\n  });\n  var path = block ? block[1] : [];\n  var start = Editor.start(editor, path);\n  var range = {\n    anchor: Range.start(editor.selection),\n    focus: start\n  };\n  var beforeText = Editor.string(editor, range);\n  return beforeText;\n};\n\nTransforms[\"delete\"] = function (editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse,\n        _options$unit = options.unit,\n        unit = _options$unit === void 0 ? 'character' : _options$unit,\n        _options$distance = options.distance,\n        distance = _options$distance === void 0 ? 1 : _options$distance,\n        _options$voids = options.voids,\n        voids = _options$voids === void 0 ? false : _options$voids;\n    var _options$at = options.at,\n        at = _options$at === void 0 ? editor.selection : _options$at,\n        _options$hanging = options.hanging,\n        hanging = _options$hanging === void 0 ? false : _options$hanging;\n\n    if (!at) {\n      return;\n    }\n\n    if (Range.isRange(at) && Range.isCollapsed(at)) {\n      at = at.anchor;\n    }\n\n    if (Point.isPoint(at)) {\n      var furthestVoid = Editor[\"void\"](editor, {\n        at: at,\n        mode: 'highest'\n      });\n\n      if (!voids && furthestVoid) {\n        var _furthestVoid = _slicedToArray(furthestVoid, 2),\n            voidPath = _furthestVoid[1];\n\n        at = voidPath;\n      } else {\n        var opts = {\n          unit: unit,\n          distance: distance\n        };\n        var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n        at = {\n          anchor: at,\n          focus: target\n        };\n        hanging = true;\n      }\n    }\n\n    if (Path.isPath(at)) {\n      Transforms.removeNodes(editor, {\n        at: at,\n        voids: voids\n      });\n      return;\n    }\n\n    if (Range.isCollapsed(at)) {\n      return;\n    }\n\n    if (!hanging) {\n      at = Editor.unhangRange(editor, at, {\n        voids: voids\n      });\n    }\n\n    var _Range$edges = Range.edges(at),\n        _Range$edges2 = _slicedToArray(_Range$edges, 2),\n        start = _Range$edges2[0],\n        end = _Range$edges2[1];\n\n    var startBlock = Editor.above(editor, {\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      },\n      at: start,\n      voids: voids\n    });\n    var endBlock = Editor.above(editor, {\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      },\n      at: end,\n      voids: voids\n    });\n    var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n    var isSingleText = Path.equals(start.path, end.path);\n    var startVoid = voids ? null : Editor[\"void\"](editor, {\n      at: start,\n      mode: 'highest'\n    });\n    var endVoid = voids ? null : Editor[\"void\"](editor, {\n      at: end,\n      mode: 'highest'\n    }); // If the start or end points are inside an inline void, nudge them out.\n\n    if (startVoid) {\n      var before = Editor.before(editor, start);\n\n      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n        start = before;\n      }\n    }\n\n    if (endVoid) {\n      var after = Editor.after(editor, end);\n\n      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    } // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n\n\n    var matches = [];\n    var lastPath;\n\n    var _iterator2 = _createForOfIteratorHelper(Editor.nodes(editor, {\n      at: at,\n      voids: voids\n    })),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var entry = _step2.value;\n\n        var _entry = _slicedToArray(entry, 2),\n            _node2 = _entry[0],\n            _path3 = _entry[1];\n\n        if (lastPath && Path.compare(_path3, lastPath) === 0) {\n          continue;\n        }\n\n        if (!voids && Editor.isVoid(editor, _node2) || !Path.isCommon(_path3, start.path) && !Path.isCommon(_path3, end.path)) {\n          matches.push(entry);\n          lastPath = _path3;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    var pathRefs = Array.from(matches, function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          p = _ref6[1];\n\n      return Editor.pathRef(editor, p);\n    });\n    var startRef = Editor.pointRef(editor, start);\n    var endRef = Editor.pointRef(editor, end);\n\n    if (!isSingleText && !startVoid) {\n      var _point = startRef.current;\n\n      var _Editor$leaf = Editor.leaf(editor, _point),\n          _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1),\n          node = _Editor$leaf2[0];\n\n      var path = _point.path;\n      var _start = start,\n          offset = _start.offset;\n      var text = node.text.slice(offset);\n      editor.apply({\n        type: 'remove_text',\n        path: path,\n        offset: offset,\n        text: text\n      });\n    }\n\n    for (var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++) {\n      var pathRef = _pathRefs[_i];\n\n      var _path = pathRef.unref();\n\n      console.log(\"remove not at:\", _path);\n      Transforms.removeNodes(editor, {\n        at: _path,\n        voids: voids\n      });\n    }\n\n    if (!endVoid) {\n      var _point2 = endRef.current;\n\n      var _Editor$leaf3 = Editor.leaf(editor, _point2),\n          _Editor$leaf4 = _slicedToArray(_Editor$leaf3, 1),\n          _node = _Editor$leaf4[0];\n\n      var _path2 = _point2.path;\n\n      var _offset = isSingleText ? start.offset : 0;\n\n      var _text = _node.text.slice(_offset, end.offset);\n\n      editor.apply({\n        type: 'remove_text',\n        path: _path2,\n        offset: _offset,\n        text: _text\n      });\n    }\n\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      Transforms.mergeNodes(editor, {\n        at: endRef.current,\n        hanging: true,\n        voids: voids\n      });\n    }\n\n    var point = endRef.unref() || startRef.unref();\n\n    if (options.at == null && point) {\n      Transforms.select(editor, point);\n    }\n  });\n};","map":{"version":3,"sources":["/Users/yonggu/WebstormProjects/gyedit/src/withMarkdown.ts"],"names":["Editor","Path","Point","Range","Transforms","fixList","SHORTCUTS","withMarkdown","editor","deleteBackward","insertText","insertBreak","deleteFragment","insertBreak2","handled","selection","isExpanded","block","above","match","n","isBlock","isEditor","parent","text","string","blockPath","indent","setNodes","type","at","length","children","liftNodes","isCollapsed","anchor","path","start","range","focus","beforeText","tabs","c","substr","blockType","inList","test","list","select","wrapNodes","found","deleteBackward2","unit","console","log","equals","listNode","withoutNormalizing","unwrapNodes","endsWith","split","beforeTextInBlock","options","reverse","distance","voids","hanging","isRange","isPoint","furthestVoid","mode","voidPath","opts","target","before","after","end","isPath","removeNodes","unhangRange","edges","startBlock","endBlock","isAcrossBlocks","isSingleText","startVoid","endVoid","isAncestor","matches","lastPath","nodes","entry","node","compare","isVoid","isCommon","push","pathRefs","Array","from","p","pathRef","startRef","pointRef","endRef","point","current","leaf","offset","slice","apply","unref","mergeNodes"],"mappings":"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","sourcesContent":["import {Editor, Path, Point, Range, Transforms, NodeEntry} from \"slate\";\nimport {ListNode} from './types'\nimport {fixList} from \"./util\";\n\nconst SHORTCUTS = {\n    '*': 'ul-item',\n    '-': 'ul-item',\n    '+': 'ul-item',\n    '>': 'block-quote',\n    '#': 'heading-one',\n    '##': 'heading-two',\n    '###': 'heading-three',\n    '####': 'heading-four',\n    '#####': 'heading-five',\n    '######': 'heading-six',\n}\n\nexport const withMarkdown = (editor: Editor) => {\n    const {deleteBackward, insertText, insertBreak, deleteFragment} = editor\n\n    const insertBreak2 = () => {\n        let handled = false\n        const {selection} = editor\n\n        if (!selection || Range.isExpanded(selection)) {\n            insertBreak()\n            return\n        }\n        const block = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n        })\n        if (!block || Editor.isEditor(block[0])) {\n            insertBreak()\n            return\n        }\n        const parent = Editor.parent(editor, block[1])\n        if (!parent || Editor.isEditor(parent[0])) {\n            insertBreak()\n            return\n        }\n        const text = Editor.string(editor, block[1])\n        if (text) {\n            insertBreak()\n            return\n        }\n        const blockPath: Path = block[1]\n        let indent = 0\n        if (typeof parent[0].indent === \"number\") {\n            indent = parent[0].indent > 1 ? parent[0].indent - 1 : 0\n        }\n        Transforms.setNodes(editor, {type: 'paragraph', indent}, {at: blockPath})\n        // if it is the last child\n        if (blockPath[blockPath.length - 1] === parent[0].children.length - 1) {\n            Transforms.liftNodes(editor, {at: blockPath})\n            return\n        }\n    }\n    editor.insertBreak = () => {\n        insertBreak2()\n        fixList(editor)\n    }\n    editor.insertText = (text: string) => {\n        const {selection} = editor\n        if ((text !== ' ') || !selection || !Range.isCollapsed(selection)) {\n            insertText(text)\n            return\n        }\n\n        const {anchor} = selection\n        const block = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n        })\n        const path = block ? block[1] : []\n        const start = Editor.start(editor, path)\n        const range = {anchor, focus: start}\n        let beforeText = Editor.string(editor, range)\n        let tabs = 0\n        for (let c of beforeText) {\n            if (c === '\\t') {\n                tabs++\n            }\n        }\n        beforeText = beforeText.substr(tabs)\n        const blockType = block![0].type as string\n        let inList = typeof blockType === 'string' ? blockType === 'list-item' : false\n\n\n        let type = SHORTCUTS[beforeText]\n\n        if (!type && /^[1-9]\\d*\\./.test(beforeText)) {\n            type = 'ol-item'\n        }\n        let list\n        switch (type) {\n            case 'ul-item':\n                if (inList) {\n                    insertText(text)\n                    break\n                }\n                Transforms.select(editor, range)\n                Transforms.delete(editor)\n                Transforms.setNodes(\n                    editor,\n                    {type: 'list-item'},\n                    {match: n => Editor.isBlock(editor, n)}\n                )\n                list = {type: 'bulleted-list', indent: tabs, children: []}\n                Transforms.wrapNodes(editor, list, {\n                    match: n => n.type === 'list-item',\n                })\n                fixList(editor)\n                break\n            case 'ol-item':\n                if (inList) {\n                    insertText(text)\n                    break\n                }\n                const found = beforeText.match(/^([\\t]*)\\d+\\./)\n                Transforms.select(editor, range)\n                Transforms.delete(editor)\n                Transforms.setNodes(\n                    editor,\n                    {type: 'list-item'},\n                    {match: n => Editor.isBlock(editor, n)}\n                )\n                list = {type: 'numbered-list', indent: tabs, children: []}\n                Transforms.wrapNodes(editor, list, {\n                    match: n => n.type === 'list-item',\n                })\n                fixList(editor)\n                break\n            case 'block-quote':\n                if (inList || blockType !== 'paragraph') {\n                    insertText(text)\n                    break\n                }\n                let parent = Editor.above(editor, {match: n => n.type === 'block-quote'})\n                if (parent) {\n                    insertText(text)\n                    break\n                }\n                Transforms.select(editor, range)\n                Transforms.delete(editor)\n                Transforms.wrapNodes(editor, {type: 'block-quote', children: []}, {\n                    match: n => n.type === 'paragraph'\n                })\n                break\n            default:\n                insertText(text)\n        }\n        return\n    }\n\n    const deleteBackward2 = (unit: 'character' | 'word' | 'line' | 'block') => {\n        console.log(\"editor.deleteBackward:\", unit)\n        const {selection} = editor\n\n        if (!selection || Range.isExpanded(selection)) {\n            deleteBackward(unit)\n            return\n        }\n        const match = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n        })\n\n        if (!match || Editor.isEditor(match[0])) {\n            deleteBackward(unit)\n            return\n        }\n        const [block, path] = match as NodeEntry<ListNode>\n        const start = Editor.start(editor, path)\n\n        if (Point.equals(selection.anchor, start)) {\n            if (block.type === 'list-item') {\n                const [listNode] = Editor.parent(editor, path) as NodeEntry<ListNode>\n                if (listNode && (listNode.indent as number > 0)) {\n                    Editor.withoutNormalizing(editor, () => {\n                        Transforms.wrapNodes(editor, {\n                            type: listNode.type,\n                            indent: listNode.indent! - 1,\n                            children: []\n                        }, {at: path})\n                        Transforms.liftNodes(editor, {at: path})\n                    })\n                } else {\n                    Transforms.setNodes(editor, {type: 'paragraph'})\n                    Transforms.unwrapNodes(editor, {\n                        match: n => (typeof n.type === 'string' && n.type.endsWith('-list')),\n                        split: true,\n                    })\n                    // deleteBackward(unit)\n                }\n            } else if (block.type === 'paragraph') {\n                if (block.indent && block.indent > 0) {\n                    Transforms.setNodes(editor, {indent: block.indent - 1}, {at: path})\n                    return\n                } else {\n                    deleteBackward(unit)\n                }\n            } else {\n                Transforms.setNodes(editor, {type: 'paragraph'})\n            }\n            return\n        } // end if at start\n        deleteBackward(unit)\n    }\n\n    editor.deleteBackward = (unit: 'character' | 'word' | 'line' | 'block') => {\n        console.log(\"editor.deleteBackward:\", unit)\n        deleteBackward2(unit)\n        fixList(editor)\n    }\n\n    editor.deleteFragment = ()=>{\n        console.log(\"editor.deleteFragment:\")\n        deleteFragment()\n    }\n\n    return editor\n}\n\nconst beforeTextInBlock = (editor: Editor): string => {\n    const {selection} = editor\n    if (!selection) {\n        return ''\n    }\n    const block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n    })\n    const path = block ? block[1] : []\n    const start = Editor.start(editor, path)\n    const range = {anchor: Range.start(editor.selection!), focus: start}\n    let beforeText = Editor.string(editor, range)\n    return beforeText\n}\n\nTransforms.delete =(\n    editor: Editor,\n    options: {\n    at?: Location\n    distance?: number\n    unit?: 'character' | 'word' | 'line' | 'block'\n    reverse?: boolean\n    hanging?: boolean\n    voids?: boolean\n} = {}\n):void => {\n    Editor.withoutNormalizing(editor, () => {\n        const {\n            reverse = false,\n            unit = 'character',\n            distance = 1,\n            voids = false,\n        } = options\n        let { at = editor.selection, hanging = false } = options\n\n        if (!at) {\n            return\n        }\n\n        if (Range.isRange(at) && Range.isCollapsed(at)) {\n            at = at.anchor\n        }\n\n        if (Point.isPoint(at)) {\n            const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n\n            if (!voids && furthestVoid) {\n                const [, voidPath] = furthestVoid\n                at = voidPath\n            } else {\n                const opts = { unit, distance }\n                const target = reverse\n                    ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n                    : Editor.after(editor, at, opts) || Editor.end(editor, [])\n                at = { anchor: at, focus: target }\n                hanging = true\n            }\n        }\n\n        if (Path.isPath(at)) {\n            Transforms.removeNodes(editor, { at, voids })\n            return\n        }\n\n        if (Range.isCollapsed(at)) {\n            return\n        }\n\n        if (!hanging) {\n            at = Editor.unhangRange(editor, at, { voids })\n        }\n\n        let [start, end] = Range.edges(at)\n        const startBlock = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n            at: start,\n            voids,\n        })\n        const endBlock = Editor.above(editor, {\n            match: n => Editor.isBlock(editor, n),\n            at: end,\n            voids,\n        })\n        const isAcrossBlocks =\n            startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n        const isSingleText = Path.equals(start.path, end.path)\n        const startVoid = voids\n            ? null\n            : Editor.void(editor, { at: start, mode: 'highest' })\n        const endVoid = voids\n            ? null\n            : Editor.void(editor, { at: end, mode: 'highest' })\n\n        // If the start or end points are inside an inline void, nudge them out.\n        if (startVoid) {\n            const before = Editor.before(editor, start)\n\n            if (\n                before &&\n                startBlock &&\n                Path.isAncestor(startBlock[1], before.path)\n            ) {\n                start = before\n            }\n        }\n\n        if (endVoid) {\n            const after = Editor.after(editor, end)\n\n            if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n                end = after\n            }\n        }\n\n        // Get the highest nodes that are completely inside the range, as well as\n        // the start and end nodes.\n        const matches: NodeEntry[] = []\n        let lastPath: Path | undefined\n\n        for (const entry of Editor.nodes(editor, { at, voids })) {\n            const [node, path] = entry\n\n            if (lastPath && Path.compare(path, lastPath) === 0) {\n                continue\n            }\n\n            if (\n                (!voids && Editor.isVoid(editor, node)) ||\n                (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n            ) {\n                matches.push(entry)\n                lastPath = path\n            }\n        }\n\n        const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n        const startRef = Editor.pointRef(editor, start)\n        const endRef = Editor.pointRef(editor, end)\n\n        if (!isSingleText && !startVoid) {\n            const point = startRef.current!\n            const [node] = Editor.leaf(editor, point)\n            const { path } = point\n            const { offset } = start\n            const text = node.text.slice(offset)\n            editor.apply({ type: 'remove_text', path, offset, text })\n        }\n\n        for (const pathRef of pathRefs) {\n            const path = pathRef.unref()!\n            console.log(\"remove not at:\", path)\n            Transforms.removeNodes(editor, { at: path, voids })\n        }\n\n        if (!endVoid) {\n            const point = endRef.current!\n            const [node] = Editor.leaf(editor, point)\n            const { path } = point\n            const offset = isSingleText ? start.offset : 0\n            const text = node.text.slice(offset, end.offset)\n            editor.apply({ type: 'remove_text', path, offset, text })\n        }\n\n        if (\n            !isSingleText &&\n            isAcrossBlocks &&\n            endRef.current &&\n            startRef.current\n        ) {\n            Transforms.mergeNodes(editor, {\n                at: endRef.current,\n                hanging: true,\n                voids,\n            })\n        }\n\n        const point = endRef.unref() || startRef.unref()\n\n        if (options.at == null && point) {\n            Transforms.select(editor, point)\n        }\n    })\n}"]},"metadata":{},"sourceType":"module"}