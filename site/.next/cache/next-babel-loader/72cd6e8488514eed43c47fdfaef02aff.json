{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React, { useState, useMemo } from 'react';\nimport { Transforms, createEditor } from 'slate';\nimport { Slate, Editable, useEditor, withReact } from 'slate-react';\nimport { withHistory } from 'slate-history';\nimport { css } from 'emotion';\nimport RichTextEditor from './richtext';\nimport { Button, Icon, Toolbar } from '../components';\n\nconst EditableVoidsExample = () => {\n  const {\n    0: value,\n    1: setValue\n  } = useState(initialValue);\n  const editor = useMemo(() => withEditableVoids(withHistory(withReact(createEditor()))), []);\n  return __jsx(Slate, {\n    editor: editor,\n    value: value,\n    onChange: setValue\n  }, __jsx(Toolbar, null, __jsx(InsertEditableVoidButton, null)), __jsx(Editable, {\n    renderElement: props => __jsx(Element, props),\n    placeholder: \"Enter some text...\"\n  }));\n};\n\nconst withEditableVoids = editor => {\n  const {\n    isVoid\n  } = editor;\n\n  editor.isVoid = element => {\n    return element.type === 'editable-void' ? true : isVoid(element);\n  };\n\n  return editor;\n};\n\nconst insertEditableVoid = editor => {\n  const text = {\n    text: ''\n  };\n  const voidNode = {\n    type: 'editable-void',\n    children: [text]\n  };\n  Transforms.insertNodes(editor, voidNode);\n};\n\nconst Element = props => {\n  const {\n    attributes,\n    children,\n    element\n  } = props;\n\n  switch (element.type) {\n    case 'editable-void':\n      return __jsx(EditableVoidElement, props);\n\n    default:\n      return __jsx(\"p\", attributes, children);\n  }\n};\n\nconst unsetWidthStyle = css`\n  width: unset;\n`;\n\nconst EditableVoidElement = ({\n  attributes,\n  children,\n  element\n}) => {\n  const {\n    0: inputValue,\n    1: setInputValue\n  } = useState('');\n  return (// Need contentEditable=false or Firefox has issues with certain input types.\n    __jsx(\"div\", _extends({}, attributes, {\n      contentEditable: false\n    }), __jsx(\"div\", {\n      className: css`\n          box-shadow: 0 0 0 3px #ddd;\n          padding: 8px;\n        `\n    }, __jsx(\"h4\", null, \"Name:\"), __jsx(\"input\", {\n      className: css`\n            margin: 8px 0;\n          `,\n      type: \"text\",\n      value: inputValue,\n      onChange: e => {\n        setInputValue(e.target.value);\n      }\n    }), __jsx(\"h4\", null, \"Left or right handed:\"), __jsx(\"input\", {\n      className: unsetWidthStyle,\n      type: \"radio\",\n      name: \"handedness\",\n      value: \"left\"\n    }), ' ', \"Left\", __jsx(\"br\", null), __jsx(\"input\", {\n      className: unsetWidthStyle,\n      type: \"radio\",\n      name: \"handedness\",\n      value: \"right\"\n    }), ' ', \"Right\", __jsx(\"h4\", null, \"Tell us about yourself:\"), __jsx(\"div\", {\n      className: css`\n            padding: 20px;\n            border: 2px solid #ddd;\n          `\n    }, __jsx(RichTextEditor, null))), children)\n  );\n};\n\nconst InsertEditableVoidButton = () => {\n  const editor = useEditor();\n  return __jsx(Button, {\n    onMouseDown: event => {\n      event.preventDefault();\n      insertEditableVoid(editor);\n    }\n  }, __jsx(Icon, null, \"add\"));\n};\n\nconst initialValue = [{\n  type: 'paragraph',\n  children: [{\n    text: 'In addition to nodes that contain editable text, you can insert void nodes, which can also contain editable elements, inputs, or an entire other Slate editor.'\n  }]\n}, {\n  type: 'editable-void',\n  children: [{\n    text: ''\n  }]\n}, {\n  type: 'paragraph',\n  children: [{\n    text: ''\n  }]\n}];\nexport default EditableVoidsExample;","map":null,"metadata":{},"sourceType":"module"}