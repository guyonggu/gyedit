webpackHotUpdate_N_E("pages/examples/[example]",{

/***/ "../src/withMarkdown.ts":
/*!******************************!*\
  !*** ../src/withMarkdown.ts ***!
  \******************************/
/*! exports provided: withMarkdown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"withMarkdown\", function() { return withMarkdown; });\n/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ \"../node_modules/@babel/runtime/helpers/esm/slicedToArray.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ \"../node_modules/slate/dist/index.es.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"../src/util.ts\");\n\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\nvar SHORTCUTS = {\n  '*': 'ul-item',\n  '-': 'ul-item',\n  '+': 'ul-item',\n  '>': 'block-quote',\n  '#': 'heading-one',\n  '##': 'heading-two',\n  '###': 'heading-three',\n  '####': 'heading-four',\n  '#####': 'heading-five',\n  '######': 'heading-six'\n};\nvar withMarkdown = function withMarkdown(editor) {\n  var deleteBackward = editor.deleteBackward,\n      insertText = editor.insertText,\n      insertBreak = editor.insertBreak,\n      deleteFragment = editor.deleteFragment,\n      normalizeNode = editor.normalizeNode;\n\n  var insertBreak2 = function insertBreak2() {\n    var handled = false;\n    var selection = editor.selection;\n\n    if (!selection || slate__WEBPACK_IMPORTED_MODULE_1__[\"Range\"].isExpanded(selection)) {\n      insertBreak();\n      return;\n    }\n\n    var block = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].above(editor, {\n      match: function match(n) {\n        return slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isBlock(editor, n);\n      }\n    });\n\n    if (!block || slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isEditor(block[0])) {\n      insertBreak();\n      return;\n    }\n\n    var parent = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].parent(editor, block[1]);\n\n    if (!parent || slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isEditor(parent[0])) {\n      insertBreak();\n      return;\n    }\n\n    var text = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].string(editor, block[1]);\n\n    if (text) {\n      insertBreak();\n      return;\n    }\n\n    var blockPath = block[1];\n    var indent = 0;\n\n    if (typeof parent[0].indent === \"number\") {\n      indent = parent[0].indent > 1 ? parent[0].indent - 1 : 0;\n    }\n\n    slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].setNodes(editor, {\n      type: 'paragraph',\n      indent: indent\n    }, {\n      at: blockPath\n    }); // if it is the last child\n\n    if (blockPath[blockPath.length - 1] === parent[0].children.length - 1) {\n      slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].liftNodes(editor, {\n        at: blockPath\n      });\n      return;\n    }\n  };\n\n  editor.insertBreak = function () {\n    insertBreak2();\n    Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"fixList\"])(editor);\n  };\n\n  editor.insertText = function (text) {\n    var selection = editor.selection;\n\n    if (text !== ' ' || !selection || !slate__WEBPACK_IMPORTED_MODULE_1__[\"Range\"].isCollapsed(selection)) {\n      insertText(text);\n      return;\n    }\n\n    var anchor = selection.anchor;\n    var block = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].above(editor, {\n      match: function match(n) {\n        return slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isBlock(editor, n);\n      }\n    });\n    var path = block ? block[1] : [];\n    var start = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].start(editor, path);\n    var range = {\n      anchor: anchor,\n      focus: start\n    };\n    var beforeText = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].string(editor, range);\n    var tabs = 0;\n\n    var _iterator = _createForOfIteratorHelper(beforeText),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var c = _step.value;\n\n        if (c === '\\t') {\n          tabs++;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    beforeText = beforeText.substr(tabs);\n    var blockType = block[0].type;\n    var inList = typeof blockType === 'string' ? blockType === 'list-item' : false;\n    var type = SHORTCUTS[beforeText];\n\n    if (!type && /^[1-9]\\d*\\./.test(beforeText)) {\n      type = 'ol-item';\n    }\n\n    var list;\n\n    switch (type) {\n      case 'ul-item':\n        if (inList) {\n          insertText(text);\n          break;\n        }\n\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].select(editor, range);\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"][\"delete\"](editor);\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].setNodes(editor, {\n          type: 'list-item'\n        }, {\n          match: function match(n) {\n            return slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isBlock(editor, n);\n          }\n        });\n        list = {\n          type: 'bulleted-list',\n          indent: tabs,\n          children: []\n        };\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].wrapNodes(editor, list, {\n          match: function match(n) {\n            return n.type === 'list-item';\n          }\n        });\n        Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"fixList\"])(editor);\n        break;\n\n      case 'ol-item':\n        if (inList) {\n          insertText(text);\n          break;\n        }\n\n        var found = beforeText.match(/^([\\t]*)\\d+\\./);\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].select(editor, range);\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"][\"delete\"](editor);\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].setNodes(editor, {\n          type: 'list-item'\n        }, {\n          match: function match(n) {\n            return slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isBlock(editor, n);\n          }\n        });\n        list = {\n          type: 'numbered-list',\n          indent: tabs,\n          children: []\n        };\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].wrapNodes(editor, list, {\n          match: function match(n) {\n            return n.type === 'list-item';\n          }\n        });\n        Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"fixList\"])(editor);\n        break;\n\n      case 'block-quote':\n        if (inList || blockType !== 'paragraph') {\n          insertText(text);\n          break;\n        }\n\n        var parent = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].above(editor, {\n          match: function match(n) {\n            return n.type === 'block-quote';\n          }\n        });\n\n        if (parent) {\n          insertText(text);\n          break;\n        }\n\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].select(editor, range);\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"][\"delete\"](editor);\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].wrapNodes(editor, {\n          type: 'block-quote',\n          children: []\n        }, {\n          match: function match(n) {\n            return n.type === 'paragraph';\n          }\n        });\n        break;\n\n      default:\n        insertText(text);\n    }\n\n    return;\n  };\n\n  var deleteBackward2 = function deleteBackward2(unit) {\n    console.log(\"editor.deleteBackward:\", unit);\n    var selection = editor.selection;\n\n    if (!selection || slate__WEBPACK_IMPORTED_MODULE_1__[\"Range\"].isExpanded(selection)) {\n      deleteBackward(unit);\n      return;\n    }\n\n    var match = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].above(editor, {\n      match: function match(n) {\n        return slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isBlock(editor, n);\n      }\n    });\n\n    if (!match || slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isEditor(match[0])) {\n      deleteBackward(unit);\n      return;\n    }\n\n    var _ref = match,\n        _ref2 = Object(_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_ref, 2),\n        block = _ref2[0],\n        path = _ref2[1];\n\n    var start = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].start(editor, path);\n\n    if (slate__WEBPACK_IMPORTED_MODULE_1__[\"Point\"].equals(selection.anchor, start)) {\n      if (block.type === 'list-item') {\n        var _ref3 = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].parent(editor, path),\n            _ref4 = Object(_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_ref3, 1),\n            listNode = _ref4[0];\n\n        if (listNode && listNode.indent > 0) {\n          slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].withoutNormalizing(editor, function () {\n            slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].wrapNodes(editor, {\n              type: listNode.type,\n              indent: listNode.indent - 1,\n              children: []\n            }, {\n              at: path\n            });\n            slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].liftNodes(editor, {\n              at: path\n            });\n          });\n        } else {\n          slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].setNodes(editor, {\n            type: 'paragraph'\n          });\n          slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].unwrapNodes(editor, {\n            match: function match(n) {\n              return typeof n.type === 'string' && n.type.endsWith('-list');\n            },\n            split: true\n          }); // deleteBackward(unit)\n        }\n      } else if (block.type === 'paragraph') {\n        if (block.indent && block.indent > 0) {\n          slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].setNodes(editor, {\n            indent: block.indent - 1\n          }, {\n            at: path\n          });\n          return;\n        } else {\n          deleteBackward(unit);\n        }\n      } else {\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].setNodes(editor, {\n          type: 'paragraph'\n        });\n      }\n\n      return;\n    } // end if at start\n\n\n    deleteBackward(unit);\n  };\n\n  editor.deleteBackward = function (unit) {\n    console.log(\"editor.deleteBackward:\", unit);\n    deleteBackward2(unit);\n    Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"fixList\"])(editor);\n  };\n\n  editor.deleteFragment = function () {\n    console.log(\"editor.deleteFragment:\");\n    deleteFragment();\n  };\n\n  editor.normalizeNode = function (entry) {\n    if (slate__WEBPACK_IMPORTED_MODULE_1__[\"Element\"].isElement(entry[0]) && entry[0].type !== 'list-item') {\n      var _ref5 = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].parent(editor, entry[1]),\n          _ref6 = Object(_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_ref5, 1),\n          pNode = _ref6[0];\n\n      if (Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"isListNode\"])(pNode)) {\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].setNodes(editor, {\n          type: 'list-item'\n        }, {\n          at: entry[1]\n        });\n      }\n    }\n\n    normalizeNode(entry);\n  };\n\n  return editor;\n};\n\nvar beforeTextInBlock = function beforeTextInBlock(editor) {\n  var selection = editor.selection;\n\n  if (!selection) {\n    return '';\n  }\n\n  var block = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].above(editor, {\n    match: function match(n) {\n      return slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isBlock(editor, n);\n    }\n  });\n  var path = block ? block[1] : [];\n  var start = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].start(editor, path);\n  var range = {\n    anchor: slate__WEBPACK_IMPORTED_MODULE_1__[\"Range\"].start(editor.selection),\n    focus: start\n  };\n  var beforeText = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].string(editor, range);\n  return beforeText;\n}; //\n// Transforms.delete =(\n//     editor: Editor,\n//     options: {\n//     at?: Location\n//     distance?: number\n//     unit?: 'character' | 'word' | 'line' | 'block'\n//     reverse?: boolean\n//     hanging?: boolean\n//     voids?: boolean\n// } = {}\n// ):void => {\n//     Editor.withoutNormalizing(editor, () => {\n//         const {\n//             reverse = false,\n//             unit = 'character',\n//             distance = 1,\n//             voids = false,\n//         } = options\n//         let { at = editor.selection, hanging = false } = options\n//\n//         if (!at) {\n//             return\n//         }\n//\n//         if (Range.isRange(at) && Range.isCollapsed(at)) {\n//             at = at.anchor\n//         }\n//\n//         if (Point.isPoint(at)) {\n//             const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n//\n//             if (!voids && furthestVoid) {\n//                 const [, voidPath] = furthestVoid\n//                 at = voidPath\n//             } else {\n//                 const opts = { unit, distance }\n//                 const target = reverse\n//                     ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n//                     : Editor.after(editor, at, opts) || Editor.end(editor, [])\n//                 at = { anchor: at, focus: target }\n//                 hanging = true\n//             }\n//         }\n//\n//         if (Path.isPath(at)) {\n//             Transforms.removeNodes(editor, { at, voids })\n//             return\n//         }\n//\n//         if (Range.isCollapsed(at)) {\n//             return\n//         }\n//\n//         if (!hanging) {\n//             at = Editor.unhangRange(editor, at, { voids })\n//         }\n//\n//         let [start, end] = Range.edges(at)\n//         const startBlock = Editor.above(editor, {\n//             match: n => Editor.isBlock(editor, n),\n//             at: start,\n//             voids,\n//         })\n//         const endBlock = Editor.above(editor, {\n//             match: n => Editor.isBlock(editor, n),\n//             at: end,\n//             voids,\n//         })\n//         const isAcrossBlocks =\n//             startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n//         const isSingleText = Path.equals(start.path, end.path)\n//         const startVoid = voids\n//             ? null\n//             : Editor.void(editor, { at: start, mode: 'highest' })\n//         const endVoid = voids\n//             ? null\n//             : Editor.void(editor, { at: end, mode: 'highest' })\n//\n//         // If the start or end points are inside an inline void, nudge them out.\n//         if (startVoid) {\n//             const before = Editor.before(editor, start)\n//\n//             if (\n//                 before &&\n//                 startBlock &&\n//                 Path.isAncestor(startBlock[1], before.path)\n//             ) {\n//                 start = before\n//             }\n//         }\n//\n//         if (endVoid) {\n//             const after = Editor.after(editor, end)\n//\n//             if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n//                 end = after\n//             }\n//         }\n//\n//         // Get the highest nodes that are completely inside the range, as well as\n//         // the start and end nodes.\n//         const matches: NodeEntry[] = []\n//         let lastPath: Path | undefined\n//\n//         for (const entry of Editor.nodes(editor, { at, voids })) {\n//             const [node, path] = entry\n//\n//             if (lastPath && Path.compare(path, lastPath) === 0) {\n//                 continue\n//             }\n//\n//             if (\n//                 (!voids && Editor.isVoid(editor, node)) ||\n//                 (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n//             ) {\n//                 matches.push(entry)\n//                 lastPath = path\n//             }\n//         }\n//\n//         const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n//         const startRef = Editor.pointRef(editor, start)\n//         const endRef = Editor.pointRef(editor, end)\n//\n//         if (!isSingleText && !startVoid) {\n//             const point = startRef.current!\n//             const [node] = Editor.leaf(editor, point)\n//             const { path } = point\n//             const { offset } = start\n//             const text = node.text.slice(offset)\n//             editor.apply({ type: 'remove_text', path, offset, text })\n//         }\n//\n//         for (const pathRef of pathRefs) {\n//             const path = pathRef.unref()!\n//             console.log(\"remove not at:\", path)\n//             Transforms.removeNodes(editor, { at: path, voids })\n//         }\n//\n//         if (!endVoid) {\n//             const point = endRef.current!\n//             const [node] = Editor.leaf(editor, point)\n//             const { path } = point\n//             const offset = isSingleText ? start.offset : 0\n//             const text = node.text.slice(offset, end.offset)\n//             editor.apply({ type: 'remove_text', path, offset, text })\n//         }\n//\n//         if (\n//             !isSingleText &&\n//             isAcrossBlocks &&\n//             endRef.current &&\n//             startRef.current\n//         ) {\n//             console.log(\"merge node at:\", endRef.current)\n//             Transforms.mergeNodes(editor, {\n//                 at: endRef.current,\n//                 hanging: true,\n//                 voids,\n//             })\n//         }\n//\n//         const point = endRef.unref() || startRef.unref()\n//\n//         if (options.at == null && point) {\n//             Transforms.select(editor, point)\n//         }\n//     })\n// }\n//\n// Transforms.mergeNodes = (\n//     editor: Editor,\n//     options: {\n//     at?: Location\n//     match?: (node: Node) => boolean\n//     mode?: 'highest' | 'lowest'\n//     hanging?: boolean\n//     voids?: boolean\n// } = {}\n// ) => {\n//     Editor.withoutNormalizing(editor, () => {\n//         let { match, at = editor.selection } = options\n//         const { hanging = false, voids = false, mode = 'lowest' } = options\n//\n//         if (!at) {\n//             return\n//         }\n//\n//         if (match == null) {\n//             if (Path.isPath(at)) {\n//                 const [parent] = Editor.parent(editor, at)\n//                 match = n => parent.children.includes(n)\n//             } else {\n//                 match = n => Editor.isBlock(editor, n)\n//             }\n//         }\n//\n//         if (!hanging && Range.isRange(at)) {\n//             at = Editor.unhangRange(editor, at)\n//         }\n//\n//         if (Range.isRange(at)) {\n//             if (Range.isCollapsed(at)) {\n//                 at = at.anchor\n//             } else {\n//                 const [, end] = Range.edges(at)\n//                 const pointRef = Editor.pointRef(editor, end)\n//                 Transforms.delete(editor, { at })\n//                 at = pointRef.unref()!\n//\n//                 if (options.at == null) {\n//                     Transforms.select(editor, at)\n//                 }\n//             }\n//         }\n//\n//         const [current] = Editor.nodes(editor, { at, match, voids, mode })\n//         const prev = Editor.previous(editor, { at, match, voids, mode })\n//\n//         if (!current || !prev) {\n//             return\n//         }\n//\n//         const [node, path] = current\n//         const [prevNode, prevPath] = prev\n//\n//         if (path.length === 0 || prevPath.length === 0) {\n//             return\n//         }\n//\n//         const newPath = Path.next(prevPath)\n//         const commonPath = Path.common(path, prevPath)\n//         const isPreviousSibling = Path.isSibling(path, prevPath)\n//         const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\n//             .slice(commonPath.length)\n//             .slice(0, -1)\n//\n//         // Determine if the merge will leave an ancestor of the path empty as a\n//         // result, in which case we'll want to remove it after merging.\n//         const emptyAncestor = Editor.above(editor, {\n//             at: path,\n//             mode: 'highest',\n//             match: n =>\n//                 levels.includes(n) && Element.isElement(n) && n.children.length === 1,\n//         })\n//\n//         const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n//         let properties\n//         let position\n//\n//         // Ensure that the nodes are equivalent, and figure out what the position\n//         // and extra properties of the merge will be.\n//         if (Text.isText(node) && Text.isText(prevNode)) {\n//             const { text, ...rest } = node\n//             position = prevNode.text.length\n//             properties = rest as Partial<Text>\n//         } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n//             const { children, ...rest } = node\n//             position = prevNode.children.length\n//             properties = rest as Partial<Element>\n//         } else {\n//             throw new Error(\n//                 `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n//                     node\n//                 )} ${JSON.stringify(prevNode)}`\n//             )\n//         }\n//\n//         // If the node isn't already the next sibling of the previous node, move\n//         // it so that it is before merging.\n//         if (!isPreviousSibling) {\n//             console.log(\"In merge, movNodes from \", path, \"to\", newPath)\n//             Transforms.moveNodes(editor, { at: path, to: newPath, voids })\n//         }\n//\n//         // If there was going to be an empty ancestor of the node that was merged,\n//         // we remove it from the tree.\n//         if (emptyRef) {\n//             console.log(\"In merge, remove node at:\", emptyRef.current)\n//             Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\n//         }\n//\n//         // If the target node that we're merging with is empty, remove it instead\n//         // of merging the two. This is a common rich text editor behavior to\n//         // prevent losing formatting when deleting entire nodes when you have a\n//         // hanging selection.\n//         if (\n//             (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n//             (Text.isText(prevNode) && prevNode.text === '')\n//         ) {\n//             console.log(\"In merge, remove2\", prevNode.type, \"node at:\", prevPath)\n//             Transforms.removeNodes(editor, { at: prevPath, voids })\n//         } else {\n//             editor.apply({\n//                 type: 'merge_node',\n//                 path: newPath,\n//                 position,\n//                 properties,\n//             })\n//         }\n//\n//         if (emptyRef) {\n//             emptyRef.unref()\n//         }\n//     })\n// }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy93aXRoTWFya2Rvd24udHM/MzRiNiJdLCJuYW1lcyI6WyJTSE9SVENVVFMiLCJ3aXRoTWFya2Rvd24iLCJlZGl0b3IiLCJkZWxldGVCYWNrd2FyZCIsImluc2VydFRleHQiLCJpbnNlcnRCcmVhayIsImRlbGV0ZUZyYWdtZW50Iiwibm9ybWFsaXplTm9kZSIsImluc2VydEJyZWFrMiIsImhhbmRsZWQiLCJzZWxlY3Rpb24iLCJSYW5nZSIsImlzRXhwYW5kZWQiLCJibG9jayIsIkVkaXRvciIsImFib3ZlIiwibWF0Y2giLCJuIiwiaXNCbG9jayIsImlzRWRpdG9yIiwicGFyZW50IiwidGV4dCIsInN0cmluZyIsImJsb2NrUGF0aCIsImluZGVudCIsIlRyYW5zZm9ybXMiLCJzZXROb2RlcyIsInR5cGUiLCJhdCIsImxlbmd0aCIsImNoaWxkcmVuIiwibGlmdE5vZGVzIiwiZml4TGlzdCIsImlzQ29sbGFwc2VkIiwiYW5jaG9yIiwicGF0aCIsInN0YXJ0IiwicmFuZ2UiLCJmb2N1cyIsImJlZm9yZVRleHQiLCJ0YWJzIiwiYyIsInN1YnN0ciIsImJsb2NrVHlwZSIsImluTGlzdCIsInRlc3QiLCJsaXN0Iiwic2VsZWN0Iiwid3JhcE5vZGVzIiwiZm91bmQiLCJkZWxldGVCYWNrd2FyZDIiLCJ1bml0IiwiY29uc29sZSIsImxvZyIsIlBvaW50IiwiZXF1YWxzIiwibGlzdE5vZGUiLCJ3aXRob3V0Tm9ybWFsaXppbmciLCJ1bndyYXBOb2RlcyIsImVuZHNXaXRoIiwic3BsaXQiLCJlbnRyeSIsIkVsZW1lbnQiLCJpc0VsZW1lbnQiLCJwTm9kZSIsImlzTGlzdE5vZGUiLCJiZWZvcmVUZXh0SW5CbG9jayJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBRUE7QUFFQSxJQUFNQSxTQUFTLEdBQUc7QUFDZCxPQUFLLFNBRFM7QUFFZCxPQUFLLFNBRlM7QUFHZCxPQUFLLFNBSFM7QUFJZCxPQUFLLGFBSlM7QUFLZCxP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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vc3JjL3dpdGhNYXJrZG93bi50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RWRpdG9yLCBQYXRoLCBQb2ludCwgUmFuZ2UsIEVsZW1lbnQsIFRleHQsIFRyYW5zZm9ybXMsIE5vZGVFbnRyeX0gZnJvbSBcInNsYXRlXCI7XG5pbXBvcnQge0xpc3ROb2RlfSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHtmaXhMaXN0LCBpc0xpc3ROb2RlfSBmcm9tIFwiLi91dGlsXCI7XG5cbmNvbnN0IFNIT1JUQ1VUUyA9IHtcbiAgICAnKic6ICd1bC1pdGVtJyxcbiAgICAnLSc6ICd1bC1pdGVtJyxcbiAgICAnKyc6ICd1bC1pdGVtJyxcbiAgICAnPic6ICdibG9jay1xdW90ZScsXG4gICAgJyMnOiAnaGVhZGluZy1vbmUnLFxuICAgICcjIyc6ICdoZWFkaW5nLXR3bycsXG4gICAgJyMjIyc6ICdoZWFkaW5nLXRocmVlJyxcbiAgICAnIyMjIyc6ICdoZWFkaW5nLWZvdXInLFxuICAgICcjIyMjIyc6ICdoZWFkaW5nLWZpdmUnLFxuICAgICcjIyMjIyMnOiAnaGVhZGluZy1zaXgnLFxufVxuXG5leHBvcnQgY29uc3Qgd2l0aE1hcmtkb3duID0gKGVkaXRvcjogRWRpdG9yKSA9PiB7XG4gICAgY29uc3Qge2RlbGV0ZUJhY2t3YXJkLCBpbnNlcnRUZXh0LCBpbnNlcnRCcmVhaywgZGVsZXRlRnJhZ21lbnQsIG5vcm1hbGl6ZU5vZGV9ID0gZWRpdG9yXG5cbiAgICBjb25zdCBpbnNlcnRCcmVhazIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBoYW5kbGVkID0gZmFsc2VcbiAgICAgICAgY29uc3Qge3NlbGVjdGlvbn0gPSBlZGl0b3JcblxuICAgICAgICBpZiAoIXNlbGVjdGlvbiB8fCBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGluc2VydEJyZWFrKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgICAgfSlcbiAgICAgICAgaWYgKCFibG9jayB8fCBFZGl0b3IuaXNFZGl0b3IoYmxvY2tbMF0pKSB7XG4gICAgICAgICAgICBpbnNlcnRCcmVhaygpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnQgPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYmxvY2tbMV0pXG4gICAgICAgIGlmICghcGFyZW50IHx8IEVkaXRvci5pc0VkaXRvcihwYXJlbnRbMF0pKSB7XG4gICAgICAgICAgICBpbnNlcnRCcmVhaygpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0ID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIGJsb2NrWzFdKVxuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgaW5zZXJ0QnJlYWsoKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2tQYXRoOiBQYXRoID0gYmxvY2tbMV1cbiAgICAgICAgbGV0IGluZGVudCA9IDBcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJlbnRbMF0uaW5kZW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpbmRlbnQgPSBwYXJlbnRbMF0uaW5kZW50ID4gMSA/IHBhcmVudFswXS5pbmRlbnQgLSAxIDogMFxuICAgICAgICB9XG4gICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7dHlwZTogJ3BhcmFncmFwaCcsIGluZGVudH0sIHthdDogYmxvY2tQYXRofSlcbiAgICAgICAgLy8gaWYgaXQgaXMgdGhlIGxhc3QgY2hpbGRcbiAgICAgICAgaWYgKGJsb2NrUGF0aFtibG9ja1BhdGgubGVuZ3RoIC0gMV0gPT09IHBhcmVudFswXS5jaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmxpZnROb2RlcyhlZGl0b3IsIHthdDogYmxvY2tQYXRofSlcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgfVxuICAgIGVkaXRvci5pbnNlcnRCcmVhayA9ICgpID0+IHtcbiAgICAgICAgaW5zZXJ0QnJlYWsyKClcbiAgICAgICAgZml4TGlzdChlZGl0b3IpXG4gICAgfVxuICAgIGVkaXRvci5pbnNlcnRUZXh0ID0gKHRleHQ6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCB7c2VsZWN0aW9ufSA9IGVkaXRvclxuICAgICAgICBpZiAoKHRleHQgIT09ICcgJykgfHwgIXNlbGVjdGlvbiB8fCAhUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgaW5zZXJ0VGV4dCh0ZXh0KVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7YW5jaG9yfSA9IHNlbGVjdGlvblxuICAgICAgICBjb25zdCBibG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IHBhdGggPSBibG9jayA/IGJsb2NrWzFdIDogW11cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKVxuICAgICAgICBjb25zdCByYW5nZSA9IHthbmNob3IsIGZvY3VzOiBzdGFydH1cbiAgICAgICAgbGV0IGJlZm9yZVRleHQgPSBFZGl0b3Iuc3RyaW5nKGVkaXRvciwgcmFuZ2UpXG4gICAgICAgIGxldCB0YWJzID0gMFxuICAgICAgICBmb3IgKGxldCBjIG9mIGJlZm9yZVRleHQpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgIHRhYnMrK1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJlZm9yZVRleHQgPSBiZWZvcmVUZXh0LnN1YnN0cih0YWJzKVxuICAgICAgICBjb25zdCBibG9ja1R5cGUgPSBibG9jayFbMF0udHlwZSBhcyBzdHJpbmdcbiAgICAgICAgbGV0IGluTGlzdCA9IHR5cGVvZiBibG9ja1R5cGUgPT09ICdzdHJpbmcnID8gYmxvY2tUeXBlID09PSAnbGlzdC1pdGVtJyA6IGZhbHNlXG5cblxuICAgICAgICBsZXQgdHlwZSA9IFNIT1JUQ1VUU1tiZWZvcmVUZXh0XVxuXG4gICAgICAgIGlmICghdHlwZSAmJiAvXlsxLTldXFxkKlxcLi8udGVzdChiZWZvcmVUZXh0KSkge1xuICAgICAgICAgICAgdHlwZSA9ICdvbC1pdGVtJ1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaXN0XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAndWwtaXRlbSc6XG4gICAgICAgICAgICAgICAgaWYgKGluTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0KHRleHQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpXG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yKVxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAge3R5cGU6ICdsaXN0LWl0ZW0nfSxcbiAgICAgICAgICAgICAgICAgICAge21hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbil9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGxpc3QgPSB7dHlwZTogJ2J1bGxldGVkLWxpc3QnLCBpbmRlbnQ6IHRhYnMsIGNoaWxkcmVuOiBbXX1cbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLndyYXBOb2RlcyhlZGl0b3IsIGxpc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2g6IG4gPT4gbi50eXBlID09PSAnbGlzdC1pdGVtJyxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIGZpeExpc3QoZWRpdG9yKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdvbC1pdGVtJzpcbiAgICAgICAgICAgICAgICBpZiAoaW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQodGV4dClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSBiZWZvcmVUZXh0Lm1hdGNoKC9eKFtcXHRdKilcXGQrXFwuLylcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKVxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvcilcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKFxuICAgICAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgIHt0eXBlOiAnbGlzdC1pdGVtJ30sXG4gICAgICAgICAgICAgICAgICAgIHttYXRjaDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBsaXN0ID0ge3R5cGU6ICdudW1iZXJlZC1saXN0JywgaW5kZW50OiB0YWJzLCBjaGlsZHJlbjogW119XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCBsaXN0LCB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoOiBuID0+IG4udHlwZSA9PT0gJ2xpc3QtaXRlbScsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBmaXhMaXN0KGVkaXRvcilcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stcXVvdGUnOlxuICAgICAgICAgICAgICAgIGlmIChpbkxpc3QgfHwgYmxvY2tUeXBlICE9PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0KHRleHQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7bWF0Y2g6IG4gPT4gbi50eXBlID09PSAnYmxvY2stcXVvdGUnfSlcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQodGV4dClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSlcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IpXG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCB7dHlwZTogJ2Jsb2NrLXF1b3RlJywgY2hpbGRyZW46IFtdfSwge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaDogbiA9PiBuLnR5cGUgPT09ICdwYXJhZ3JhcGgnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0KHRleHQpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZGVsZXRlQmFja3dhcmQyID0gKHVuaXQ6ICdjaGFyYWN0ZXInIHwgJ3dvcmQnIHwgJ2xpbmUnIHwgJ2Jsb2NrJykgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcImVkaXRvci5kZWxldGVCYWNrd2FyZDpcIiwgdW5pdClcbiAgICAgICAgY29uc3Qge3NlbGVjdGlvbn0gPSBlZGl0b3JcblxuICAgICAgICBpZiAoIXNlbGVjdGlvbiB8fCBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGRlbGV0ZUJhY2t3YXJkKHVuaXQpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFtYXRjaCB8fCBFZGl0b3IuaXNFZGl0b3IobWF0Y2hbMF0pKSB7XG4gICAgICAgICAgICBkZWxldGVCYWNrd2FyZCh1bml0KVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2Jsb2NrLCBwYXRoXSA9IG1hdGNoIGFzIE5vZGVFbnRyeTxMaXN0Tm9kZT5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKVxuXG4gICAgICAgIGlmIChQb2ludC5lcXVhbHMoc2VsZWN0aW9uLmFuY2hvciwgc3RhcnQpKSB7XG4gICAgICAgICAgICBpZiAoYmxvY2sudHlwZSA9PT0gJ2xpc3QtaXRlbScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbbGlzdE5vZGVdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpIGFzIE5vZGVFbnRyeTxMaXN0Tm9kZT5cbiAgICAgICAgICAgICAgICBpZiAobGlzdE5vZGUgJiYgKGxpc3ROb2RlLmluZGVudCBhcyBudW1iZXIgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbGlzdE5vZGUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IGxpc3ROb2RlLmluZGVudCEgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge2F0OiBwYXRofSlcbiAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMubGlmdE5vZGVzKGVkaXRvciwge2F0OiBwYXRofSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge3R5cGU6ICdwYXJhZ3JhcGgnfSlcbiAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoOiBuID0+ICh0eXBlb2Ygbi50eXBlID09PSAnc3RyaW5nJyAmJiBuLnR5cGUuZW5kc1dpdGgoJy1saXN0JykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZUJhY2t3YXJkKHVuaXQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChibG9jay50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgIGlmIChibG9jay5pbmRlbnQgJiYgYmxvY2suaW5kZW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge2luZGVudDogYmxvY2suaW5kZW50IC0gMX0sIHthdDogcGF0aH0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUJhY2t3YXJkKHVuaXQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge3R5cGU6ICdwYXJhZ3JhcGgnfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9IC8vIGVuZCBpZiBhdCBzdGFydFxuICAgICAgICBkZWxldGVCYWNrd2FyZCh1bml0KVxuICAgIH1cblxuICAgIGVkaXRvci5kZWxldGVCYWNrd2FyZCA9ICh1bml0OiAnY2hhcmFjdGVyJyB8ICd3b3JkJyB8ICdsaW5lJyB8ICdibG9jaycpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJlZGl0b3IuZGVsZXRlQmFja3dhcmQ6XCIsIHVuaXQpXG4gICAgICAgIGRlbGV0ZUJhY2t3YXJkMih1bml0KVxuICAgICAgICBmaXhMaXN0KGVkaXRvcilcbiAgICB9XG5cbiAgICBlZGl0b3IuZGVsZXRlRnJhZ21lbnQgPSAoKT0+e1xuICAgICAgICBjb25zb2xlLmxvZyhcImVkaXRvci5kZWxldGVGcmFnbWVudDpcIilcbiAgICAgICAgZGVsZXRlRnJhZ21lbnQoKVxuICAgIH1cbiAgICBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChlbnRyeTpOb2RlRW50cnkpPT57XG4gICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChlbnRyeVswXSkgJiYgZW50cnlbMF0udHlwZSAhPT0gJ2xpc3QtaXRlbScpIHtcbiAgICAgICAgICAgIGNvbnN0IFtwTm9kZV0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgZW50cnlbMV0pIVxuICAgICAgICAgICAgaWYgKGlzTGlzdE5vZGUocE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHt0eXBlOidsaXN0LWl0ZW0nfSwge2F0OmVudHJ5WzFdfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVOb2RlKGVudHJ5KVxuICAgIH1cblxuICAgIHJldHVybiBlZGl0b3Jcbn1cblxuY29uc3QgYmVmb3JlVGV4dEluQmxvY2sgPSAoZWRpdG9yOiBFZGl0b3IpOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IHtzZWxlY3Rpb259ID0gZWRpdG9yXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICcnXG4gICAgfVxuICAgIGNvbnN0IGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgIH0pXG4gICAgY29uc3QgcGF0aCA9IGJsb2NrID8gYmxvY2tbMV0gOiBbXVxuICAgIGNvbnN0IHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aClcbiAgICBjb25zdCByYW5nZSA9IHthbmNob3I6IFJhbmdlLnN0YXJ0KGVkaXRvci5zZWxlY3Rpb24hKSwgZm9jdXM6IHN0YXJ0fVxuICAgIGxldCBiZWZvcmVUZXh0ID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIHJhbmdlKVxuICAgIHJldHVybiBiZWZvcmVUZXh0XG59XG4vL1xuLy8gVHJhbnNmb3Jtcy5kZWxldGUgPShcbi8vICAgICBlZGl0b3I6IEVkaXRvcixcbi8vICAgICBvcHRpb25zOiB7XG4vLyAgICAgYXQ/OiBMb2NhdGlvblxuLy8gICAgIGRpc3RhbmNlPzogbnVtYmVyXG4vLyAgICAgdW5pdD86ICdjaGFyYWN0ZXInIHwgJ3dvcmQnIHwgJ2xpbmUnIHwgJ2Jsb2NrJ1xuLy8gICAgIHJldmVyc2U/OiBib29sZWFuXG4vLyAgICAgaGFuZ2luZz86IGJvb2xlYW5cbi8vICAgICB2b2lkcz86IGJvb2xlYW5cbi8vIH0gPSB7fVxuLy8gKTp2b2lkID0+IHtcbi8vICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuLy8gICAgICAgICBjb25zdCB7XG4vLyAgICAgICAgICAgICByZXZlcnNlID0gZmFsc2UsXG4vLyAgICAgICAgICAgICB1bml0ID0gJ2NoYXJhY3RlcicsXG4vLyAgICAgICAgICAgICBkaXN0YW5jZSA9IDEsXG4vLyAgICAgICAgICAgICB2b2lkcyA9IGZhbHNlLFxuLy8gICAgICAgICB9ID0gb3B0aW9uc1xuLy8gICAgICAgICBsZXQgeyBhdCA9IGVkaXRvci5zZWxlY3Rpb24sIGhhbmdpbmcgPSBmYWxzZSB9ID0gb3B0aW9uc1xuLy9cbi8vICAgICAgICAgaWYgKCFhdCkge1xuLy8gICAgICAgICAgICAgcmV0dXJuXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSAmJiBSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbi8vICAgICAgICAgICAgIGF0ID0gYXQuYW5jaG9yXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuLy8gICAgICAgICAgICAgY29uc3QgZnVydGhlc3RWb2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7IGF0LCBtb2RlOiAnaGlnaGVzdCcgfSlcbi8vXG4vLyAgICAgICAgICAgICBpZiAoIXZvaWRzICYmIGZ1cnRoZXN0Vm9pZCkge1xuLy8gICAgICAgICAgICAgICAgIGNvbnN0IFssIHZvaWRQYXRoXSA9IGZ1cnRoZXN0Vm9pZFxuLy8gICAgICAgICAgICAgICAgIGF0ID0gdm9pZFBhdGhcbi8vICAgICAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgY29uc3Qgb3B0cyA9IHsgdW5pdCwgZGlzdGFuY2UgfVxuLy8gICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHJldmVyc2Vcbi8vICAgICAgICAgICAgICAgICAgICAgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKVxuLy8gICAgICAgICAgICAgICAgICAgICA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pXG4vLyAgICAgICAgICAgICAgICAgYXQgPSB7IGFuY2hvcjogYXQsIGZvY3VzOiB0YXJnZXQgfVxuLy8gICAgICAgICAgICAgICAgIGhhbmdpbmcgPSB0cnVlXG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbi8vICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7IGF0LCB2b2lkcyB9KVxuLy8gICAgICAgICAgICAgcmV0dXJuXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbi8vICAgICAgICAgICAgIHJldHVyblxuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICBpZiAoIWhhbmdpbmcpIHtcbi8vICAgICAgICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHsgdm9pZHMgfSlcbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgbGV0IFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KVxuLy8gICAgICAgICBjb25zdCBzdGFydEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuLy8gICAgICAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbi8vICAgICAgICAgICAgIGF0OiBzdGFydCxcbi8vICAgICAgICAgICAgIHZvaWRzLFxuLy8gICAgICAgICB9KVxuLy8gICAgICAgICBjb25zdCBlbmRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbi8vICAgICAgICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4vLyAgICAgICAgICAgICBhdDogZW5kLFxuLy8gICAgICAgICAgICAgdm9pZHMsXG4vLyAgICAgICAgIH0pXG4vLyAgICAgICAgIGNvbnN0IGlzQWNyb3NzQmxvY2tzID1cbi8vICAgICAgICAgICAgIHN0YXJ0QmxvY2sgJiYgZW5kQmxvY2sgJiYgIVBhdGguZXF1YWxzKHN0YXJ0QmxvY2tbMV0sIGVuZEJsb2NrWzFdKVxuLy8gICAgICAgICBjb25zdCBpc1NpbmdsZVRleHQgPSBQYXRoLmVxdWFscyhzdGFydC5wYXRoLCBlbmQucGF0aClcbi8vICAgICAgICAgY29uc3Qgc3RhcnRWb2lkID0gdm9pZHNcbi8vICAgICAgICAgICAgID8gbnVsbFxuLy8gICAgICAgICAgICAgOiBFZGl0b3Iudm9pZChlZGl0b3IsIHsgYXQ6IHN0YXJ0LCBtb2RlOiAnaGlnaGVzdCcgfSlcbi8vICAgICAgICAgY29uc3QgZW5kVm9pZCA9IHZvaWRzXG4vLyAgICAgICAgICAgICA/IG51bGxcbi8vICAgICAgICAgICAgIDogRWRpdG9yLnZvaWQoZWRpdG9yLCB7IGF0OiBlbmQsIG1vZGU6ICdoaWdoZXN0JyB9KVxuLy9cbi8vICAgICAgICAgLy8gSWYgdGhlIHN0YXJ0IG9yIGVuZCBwb2ludHMgYXJlIGluc2lkZSBhbiBpbmxpbmUgdm9pZCwgbnVkZ2UgdGhlbSBvdXQuXG4vLyAgICAgICAgIGlmIChzdGFydFZvaWQpIHtcbi8vICAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBzdGFydClcbi8vXG4vLyAgICAgICAgICAgICBpZiAoXG4vLyAgICAgICAgICAgICAgICAgYmVmb3JlICYmXG4vLyAgICAgICAgICAgICAgICAgc3RhcnRCbG9jayAmJlxuLy8gICAgICAgICAgICAgICAgIFBhdGguaXNBbmNlc3RvcihzdGFydEJsb2NrWzFdLCBiZWZvcmUucGF0aClcbi8vICAgICAgICAgICAgICkge1xuLy8gICAgICAgICAgICAgICAgIHN0YXJ0ID0gYmVmb3JlXG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGlmIChlbmRWb2lkKSB7XG4vLyAgICAgICAgICAgICBjb25zdCBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGVuZClcbi8vXG4vLyAgICAgICAgICAgICBpZiAoYWZ0ZXIgJiYgZW5kQmxvY2sgJiYgUGF0aC5pc0FuY2VzdG9yKGVuZEJsb2NrWzFdLCBhZnRlci5wYXRoKSkge1xuLy8gICAgICAgICAgICAgICAgIGVuZCA9IGFmdGVyXG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIC8vIEdldCB0aGUgaGlnaGVzdCBub2RlcyB0aGF0IGFyZSBjb21wbGV0ZWx5IGluc2lkZSB0aGUgcmFuZ2UsIGFzIHdlbGwgYXNcbi8vICAgICAgICAgLy8gdGhlIHN0YXJ0IGFuZCBlbmQgbm9kZXMuXG4vLyAgICAgICAgIGNvbnN0IG1hdGNoZXM6IE5vZGVFbnRyeVtdID0gW11cbi8vICAgICAgICAgbGV0IGxhc3RQYXRoOiBQYXRoIHwgdW5kZWZpbmVkXG4vL1xuLy8gICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHsgYXQsIHZvaWRzIH0pKSB7XG4vLyAgICAgICAgICAgICBjb25zdCBbbm9kZSwgcGF0aF0gPSBlbnRyeVxuLy9cbi8vICAgICAgICAgICAgIGlmIChsYXN0UGF0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgbGFzdFBhdGgpID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgY29udGludWVcbi8vICAgICAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgICAgICBpZiAoXG4vLyAgICAgICAgICAgICAgICAgKCF2b2lkcyAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHx8XG4vLyAgICAgICAgICAgICAgICAgKCFQYXRoLmlzQ29tbW9uKHBhdGgsIHN0YXJ0LnBhdGgpICYmICFQYXRoLmlzQ29tbW9uKHBhdGgsIGVuZC5wYXRoKSlcbi8vICAgICAgICAgICAgICkge1xuLy8gICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSlcbi8vICAgICAgICAgICAgICAgICBsYXN0UGF0aCA9IHBhdGhcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgY29uc3QgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIChbLCBwXSkgPT4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKSlcbi8vICAgICAgICAgY29uc3Qgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydClcbi8vICAgICAgICAgY29uc3QgZW5kUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKVxuLy9cbi8vICAgICAgICAgaWYgKCFpc1NpbmdsZVRleHQgJiYgIXN0YXJ0Vm9pZCkge1xuLy8gICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBzdGFydFJlZi5jdXJyZW50IVxuLy8gICAgICAgICAgICAgY29uc3QgW25vZGVdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBwb2ludClcbi8vICAgICAgICAgICAgIGNvbnN0IHsgcGF0aCB9ID0gcG9pbnRcbi8vICAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0IH0gPSBzdGFydFxuLy8gICAgICAgICAgICAgY29uc3QgdGV4dCA9IG5vZGUudGV4dC5zbGljZShvZmZzZXQpXG4vLyAgICAgICAgICAgICBlZGl0b3IuYXBwbHkoeyB0eXBlOiAncmVtb3ZlX3RleHQnLCBwYXRoLCBvZmZzZXQsIHRleHQgfSlcbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgZm9yIChjb25zdCBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4vLyAgICAgICAgICAgICBjb25zdCBwYXRoID0gcGF0aFJlZi51bnJlZigpIVxuLy8gICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZW1vdmUgbm90IGF0OlwiLCBwYXRoKVxuLy8gICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHsgYXQ6IHBhdGgsIHZvaWRzIH0pXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGlmICghZW5kVm9pZCkge1xuLy8gICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBlbmRSZWYuY3VycmVudCFcbi8vICAgICAgICAgICAgIGNvbnN0IFtub2RlXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgcG9pbnQpXG4vLyAgICAgICAgICAgICBjb25zdCB7IHBhdGggfSA9IHBvaW50XG4vLyAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpc1NpbmdsZVRleHQgPyBzdGFydC5vZmZzZXQgOiAwXG4vLyAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gbm9kZS50ZXh0LnNsaWNlKG9mZnNldCwgZW5kLm9mZnNldClcbi8vICAgICAgICAgICAgIGVkaXRvci5hcHBseSh7IHR5cGU6ICdyZW1vdmVfdGV4dCcsIHBhdGgsIG9mZnNldCwgdGV4dCB9KVxuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICBpZiAoXG4vLyAgICAgICAgICAgICAhaXNTaW5nbGVUZXh0ICYmXG4vLyAgICAgICAgICAgICBpc0Fjcm9zc0Jsb2NrcyAmJlxuLy8gICAgICAgICAgICAgZW5kUmVmLmN1cnJlbnQgJiZcbi8vICAgICAgICAgICAgIHN0YXJ0UmVmLmN1cnJlbnRcbi8vICAgICAgICAgKSB7XG4vLyAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm1lcmdlIG5vZGUgYXQ6XCIsIGVuZFJlZi5jdXJyZW50KVxuLy8gICAgICAgICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuLy8gICAgICAgICAgICAgICAgIGF0OiBlbmRSZWYuY3VycmVudCxcbi8vICAgICAgICAgICAgICAgICBoYW5naW5nOiB0cnVlLFxuLy8gICAgICAgICAgICAgICAgIHZvaWRzLFxuLy8gICAgICAgICAgICAgfSlcbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgY29uc3QgcG9pbnQgPSBlbmRSZWYudW5yZWYoKSB8fCBzdGFydFJlZi51bnJlZigpXG4vL1xuLy8gICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsICYmIHBvaW50KSB7XG4vLyAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHBvaW50KVxuLy8gICAgICAgICB9XG4vLyAgICAgfSlcbi8vIH1cbi8vXG4vLyBUcmFuc2Zvcm1zLm1lcmdlTm9kZXMgPSAoXG4vLyAgICAgZWRpdG9yOiBFZGl0b3IsXG4vLyAgICAgb3B0aW9uczoge1xuLy8gICAgIGF0PzogTG9jYXRpb25cbi8vICAgICBtYXRjaD86IChub2RlOiBOb2RlKSA9PiBib29sZWFuXG4vLyAgICAgbW9kZT86ICdoaWdoZXN0JyB8ICdsb3dlc3QnXG4vLyAgICAgaGFuZ2luZz86IGJvb2xlYW5cbi8vICAgICB2b2lkcz86IGJvb2xlYW5cbi8vIH0gPSB7fVxuLy8gKSA9PiB7XG4vLyAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbi8vICAgICAgICAgbGV0IHsgbWF0Y2gsIGF0ID0gZWRpdG9yLnNlbGVjdGlvbiB9ID0gb3B0aW9uc1xuLy8gICAgICAgICBjb25zdCB7IGhhbmdpbmcgPSBmYWxzZSwgdm9pZHMgPSBmYWxzZSwgbW9kZSA9ICdsb3dlc3QnIH0gPSBvcHRpb25zXG4vL1xuLy8gICAgICAgICBpZiAoIWF0KSB7XG4vLyAgICAgICAgICAgICByZXR1cm5cbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbi8vICAgICAgICAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbi8vICAgICAgICAgICAgICAgICBjb25zdCBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdClcbi8vICAgICAgICAgICAgICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pXG4vLyAgICAgICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgIG1hdGNoID0gbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pXG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuLy8gICAgICAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdClcbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4vLyAgICAgICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4vLyAgICAgICAgICAgICAgICAgYXQgPSBhdC5hbmNob3Jcbi8vICAgICAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgY29uc3QgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KVxuLy8gICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKVxuLy8gICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwgeyBhdCB9KVxuLy8gICAgICAgICAgICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKSFcbi8vXG4vLyAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KVxuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgY29uc3QgW2N1cnJlbnRdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwgeyBhdCwgbWF0Y2gsIHZvaWRzLCBtb2RlIH0pXG4vLyAgICAgICAgIGNvbnN0IHByZXYgPSBFZGl0b3IucHJldmlvdXMoZWRpdG9yLCB7IGF0LCBtYXRjaCwgdm9pZHMsIG1vZGUgfSlcbi8vXG4vLyAgICAgICAgIGlmICghY3VycmVudCB8fCAhcHJldikge1xuLy8gICAgICAgICAgICAgcmV0dXJuXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IGN1cnJlbnRcbi8vICAgICAgICAgY29uc3QgW3ByZXZOb2RlLCBwcmV2UGF0aF0gPSBwcmV2XG4vL1xuLy8gICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDAgfHwgcHJldlBhdGgubGVuZ3RoID09PSAwKSB7XG4vLyAgICAgICAgICAgICByZXR1cm5cbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgY29uc3QgbmV3UGF0aCA9IFBhdGgubmV4dChwcmV2UGF0aClcbi8vICAgICAgICAgY29uc3QgY29tbW9uUGF0aCA9IFBhdGguY29tbW9uKHBhdGgsIHByZXZQYXRoKVxuLy8gICAgICAgICBjb25zdCBpc1ByZXZpb3VzU2libGluZyA9IFBhdGguaXNTaWJsaW5nKHBhdGgsIHByZXZQYXRoKVxuLy8gICAgICAgICBjb25zdCBsZXZlbHMgPSBBcnJheS5mcm9tKEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7IGF0OiBwYXRoIH0pLCAoW25dKSA9PiBuKVxuLy8gICAgICAgICAgICAgLnNsaWNlKGNvbW1vblBhdGgubGVuZ3RoKVxuLy8gICAgICAgICAgICAgLnNsaWNlKDAsIC0xKVxuLy9cbi8vICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBtZXJnZSB3aWxsIGxlYXZlIGFuIGFuY2VzdG9yIG9mIHRoZSBwYXRoIGVtcHR5IGFzIGFcbi8vICAgICAgICAgLy8gcmVzdWx0LCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gcmVtb3ZlIGl0IGFmdGVyIG1lcmdpbmcuXG4vLyAgICAgICAgIGNvbnN0IGVtcHR5QW5jZXN0b3IgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4vLyAgICAgICAgICAgICBhdDogcGF0aCxcbi8vICAgICAgICAgICAgIG1vZGU6ICdoaWdoZXN0Jyxcbi8vICAgICAgICAgICAgIG1hdGNoOiBuID0+XG4vLyAgICAgICAgICAgICAgICAgbGV2ZWxzLmluY2x1ZGVzKG4pICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIG4uY2hpbGRyZW4ubGVuZ3RoID09PSAxLFxuLy8gICAgICAgICB9KVxuLy9cbi8vICAgICAgICAgY29uc3QgZW1wdHlSZWYgPSBlbXB0eUFuY2VzdG9yICYmIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgZW1wdHlBbmNlc3RvclsxXSlcbi8vICAgICAgICAgbGV0IHByb3BlcnRpZXNcbi8vICAgICAgICAgbGV0IHBvc2l0aW9uXG4vL1xuLy8gICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgbm9kZXMgYXJlIGVxdWl2YWxlbnQsIGFuZCBmaWd1cmUgb3V0IHdoYXQgdGhlIHBvc2l0aW9uXG4vLyAgICAgICAgIC8vIGFuZCBleHRyYSBwcm9wZXJ0aWVzIG9mIHRoZSBtZXJnZSB3aWxsIGJlLlxuLy8gICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHQocHJldk5vZGUpKSB7XG4vLyAgICAgICAgICAgICBjb25zdCB7IHRleHQsIC4uLnJlc3QgfSA9IG5vZGVcbi8vICAgICAgICAgICAgIHBvc2l0aW9uID0gcHJldk5vZGUudGV4dC5sZW5ndGhcbi8vICAgICAgICAgICAgIHByb3BlcnRpZXMgPSByZXN0IGFzIFBhcnRpYWw8VGV4dD5cbi8vICAgICAgICAgfSBlbHNlIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkpIHtcbi8vICAgICAgICAgICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnJlc3QgfSA9IG5vZGVcbi8vICAgICAgICAgICAgIHBvc2l0aW9uID0gcHJldk5vZGUuY2hpbGRyZW4ubGVuZ3RoXG4vLyAgICAgICAgICAgICBwcm9wZXJ0aWVzID0gcmVzdCBhcyBQYXJ0aWFsPEVsZW1lbnQ+XG4vLyAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4vLyAgICAgICAgICAgICAgICAgYENhbm5vdCBtZXJnZSB0aGUgbm9kZSBhdCBwYXRoIFske3BhdGh9XSB3aXRoIHRoZSBwcmV2aW91cyBzaWJsaW5nIGJlY2F1c2UgaXQgaXMgbm90IHRoZSBzYW1lIGtpbmQ6ICR7SlNPTi5zdHJpbmdpZnkoXG4vLyAgICAgICAgICAgICAgICAgICAgIG5vZGVcbi8vICAgICAgICAgICAgICAgICApfSAke0pTT04uc3RyaW5naWZ5KHByZXZOb2RlKX1gXG4vLyAgICAgICAgICAgICApXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIC8vIElmIHRoZSBub2RlIGlzbid0IGFscmVhZHkgdGhlIG5leHQgc2libGluZyBvZiB0aGUgcHJldmlvdXMgbm9kZSwgbW92ZVxuLy8gICAgICAgICAvLyBpdCBzbyB0aGF0IGl0IGlzIGJlZm9yZSBtZXJnaW5nLlxuLy8gICAgICAgICBpZiAoIWlzUHJldmlvdXNTaWJsaW5nKSB7XG4vLyAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluIG1lcmdlLCBtb3ZOb2RlcyBmcm9tIFwiLCBwYXRoLCBcInRvXCIsIG5ld1BhdGgpXG4vLyAgICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHsgYXQ6IHBhdGgsIHRvOiBuZXdQYXRoLCB2b2lkcyB9KVxuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICAvLyBJZiB0aGVyZSB3YXMgZ29pbmcgdG8gYmUgYW4gZW1wdHkgYW5jZXN0b3Igb2YgdGhlIG5vZGUgdGhhdCB3YXMgbWVyZ2VkLFxuLy8gICAgICAgICAvLyB3ZSByZW1vdmUgaXQgZnJvbSB0aGUgdHJlZS5cbi8vICAgICAgICAgaWYgKGVtcHR5UmVmKSB7XG4vLyAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluIG1lcmdlLCByZW1vdmUgbm9kZSBhdDpcIiwgZW1wdHlSZWYuY3VycmVudClcbi8vICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7IGF0OiBlbXB0eVJlZi5jdXJyZW50ISwgdm9pZHMgfSlcbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBub2RlIHRoYXQgd2UncmUgbWVyZ2luZyB3aXRoIGlzIGVtcHR5LCByZW1vdmUgaXQgaW5zdGVhZFxuLy8gICAgICAgICAvLyBvZiBtZXJnaW5nIHRoZSB0d28uIFRoaXMgaXMgYSBjb21tb24gcmljaCB0ZXh0IGVkaXRvciBiZWhhdmlvciB0b1xuLy8gICAgICAgICAvLyBwcmV2ZW50IGxvc2luZyBmb3JtYXR0aW5nIHdoZW4gZGVsZXRpbmcgZW50aXJlIG5vZGVzIHdoZW4geW91IGhhdmUgYVxuLy8gICAgICAgICAvLyBoYW5naW5nIHNlbGVjdGlvbi5cbi8vICAgICAgICAgaWYgKFxuLy8gICAgICAgICAgICAgKEVsZW1lbnQuaXNFbGVtZW50KHByZXZOb2RlKSAmJiBFZGl0b3IuaXNFbXB0eShlZGl0b3IsIHByZXZOb2RlKSkgfHxcbi8vICAgICAgICAgICAgIChUZXh0LmlzVGV4dChwcmV2Tm9kZSkgJiYgcHJldk5vZGUudGV4dCA9PT0gJycpXG4vLyAgICAgICAgICkge1xuLy8gICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbiBtZXJnZSwgcmVtb3ZlMlwiLCBwcmV2Tm9kZS50eXBlLCBcIm5vZGUgYXQ6XCIsIHByZXZQYXRoKVxuLy8gICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHsgYXQ6IHByZXZQYXRoLCB2b2lkcyB9KVxuLy8gICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbi8vICAgICAgICAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4vLyAgICAgICAgICAgICAgICAgcGF0aDogbmV3UGF0aCxcbi8vICAgICAgICAgICAgICAgICBwb3NpdGlvbixcbi8vICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLFxuLy8gICAgICAgICAgICAgfSlcbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgaWYgKGVtcHR5UmVmKSB7XG4vLyAgICAgICAgICAgICBlbXB0eVJlZi51bnJlZigpXG4vLyAgICAgICAgIH1cbi8vICAgICB9KVxuLy8gfSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../src/withMarkdown.ts\n");

/***/ })

})