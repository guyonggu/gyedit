webpackHotUpdate_N_E("pages/examples/[example]",{

/***/ "../src/withMarkdown.ts":
/*!******************************!*\
  !*** ../src/withMarkdown.ts ***!
  \******************************/
/*! exports provided: withMarkdown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"withMarkdown\", function() { return withMarkdown; });\n/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ \"../node_modules/@babel/runtime/helpers/esm/slicedToArray.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ \"../node_modules/slate/dist/index.es.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"../src/util.ts\");\n\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\nvar SHORTCUTS = {\n  '*': 'ul-item',\n  '-': 'ul-item',\n  '+': 'ul-item',\n  '>': 'block-quote',\n  '#': 'heading-one',\n  '##': 'heading-two',\n  '###': 'heading-three',\n  '####': 'heading-four',\n  '#####': 'heading-five',\n  '######': 'heading-six'\n};\nvar withMarkdown = function withMarkdown(editor) {\n  var deleteBackward = editor.deleteBackward,\n      insertText = editor.insertText,\n      insertBreak = editor.insertBreak,\n      deleteFragment = editor.deleteFragment,\n      normalizeNode = editor.normalizeNode;\n\n  var insertBreak2 = function insertBreak2() {\n    var handled = false;\n    var selection = editor.selection;\n\n    if (!selection || slate__WEBPACK_IMPORTED_MODULE_1__[\"Range\"].isExpanded(selection)) {\n      insertBreak();\n      return;\n    }\n\n    var block = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].above(editor, {\n      match: function match(n) {\n        return slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isBlock(editor, n);\n      }\n    });\n\n    if (!block || slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isEditor(block[0])) {\n      insertBreak();\n      return;\n    }\n\n    var parent = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].parent(editor, block[1]);\n\n    if (!parent || slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isEditor(parent[0])) {\n      insertBreak();\n      return;\n    }\n\n    var text = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].string(editor, block[1]);\n\n    if (text) {\n      insertBreak();\n      return;\n    }\n\n    var blockPath = block[1];\n    var indent = 0;\n\n    if (typeof parent[0].indent === \"number\") {\n      indent = parent[0].indent > 1 ? parent[0].indent - 1 : 0;\n    }\n\n    slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].setNodes(editor, {\n      type: 'paragraph',\n      indent: indent\n    }, {\n      at: blockPath\n    }); // if it is the last child\n\n    if (blockPath[blockPath.length - 1] === parent[0].children.length - 1) {\n      slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].liftNodes(editor, {\n        at: blockPath\n      });\n      return;\n    }\n  };\n\n  editor.insertBreak = function () {\n    insertBreak2();\n    Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"fixList\"])(editor);\n  };\n\n  editor.insertText = function (text) {\n    var selection = editor.selection;\n\n    if (text !== ' ' || !selection || !slate__WEBPACK_IMPORTED_MODULE_1__[\"Range\"].isCollapsed(selection)) {\n      insertText(text);\n      return;\n    }\n\n    var anchor = selection.anchor;\n    var block = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].above(editor, {\n      match: function match(n) {\n        return slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isBlock(editor, n);\n      }\n    });\n    var path = block ? block[1] : [];\n    var start = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].start(editor, path);\n    var range = {\n      anchor: anchor,\n      focus: start\n    };\n    var beforeText = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].string(editor, range);\n    var tabs = 0;\n\n    var _iterator = _createForOfIteratorHelper(beforeText),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var c = _step.value;\n\n        if (c === '\\t') {\n          tabs++;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    beforeText = beforeText.substr(tabs);\n    var blockType = block[0].type;\n    var inList = typeof blockType === 'string' ? blockType === 'list-item' : false;\n    var type = SHORTCUTS[beforeText];\n\n    if (!type && /^[1-9]\\d*\\./.test(beforeText)) {\n      type = 'ol-item';\n    }\n\n    var list;\n\n    switch (type) {\n      case 'ul-item':\n        if (inList) {\n          insertText(text);\n          break;\n        }\n\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].select(editor, range);\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"][\"delete\"](editor);\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].setNodes(editor, {\n          type: 'list-item'\n        }, {\n          match: function match(n) {\n            return slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isBlock(editor, n);\n          }\n        });\n        list = {\n          type: 'bulleted-list',\n          indent: tabs,\n          children: []\n        };\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].wrapNodes(editor, list, {\n          match: function match(n) {\n            return n.type === 'list-item';\n          }\n        });\n        Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"fixList\"])(editor);\n        break;\n\n      case 'ol-item':\n        if (inList) {\n          insertText(text);\n          break;\n        }\n\n        var found = beforeText.match(/^([\\t]*)\\d+\\./);\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].select(editor, range);\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"][\"delete\"](editor);\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].setNodes(editor, {\n          type: 'list-item'\n        }, {\n          match: function match(n) {\n            return slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isBlock(editor, n);\n          }\n        });\n        list = {\n          type: 'numbered-list',\n          indent: tabs,\n          children: []\n        };\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].wrapNodes(editor, list, {\n          match: function match(n) {\n            return n.type === 'list-item';\n          }\n        });\n        Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"fixList\"])(editor);\n        break;\n\n      case 'block-quote':\n        if (inList || blockType !== 'paragraph') {\n          insertText(text);\n          break;\n        }\n\n        var parent = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].above(editor, {\n          match: function match(n) {\n            return n.type === 'block-quote';\n          }\n        });\n\n        if (parent) {\n          insertText(text);\n          break;\n        }\n\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].select(editor, range);\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"][\"delete\"](editor);\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].wrapNodes(editor, {\n          type: 'block-quote',\n          children: []\n        }, {\n          match: function match(n) {\n            return n.type === 'paragraph';\n          }\n        });\n        break;\n\n      default:\n        insertText(text);\n    }\n\n    return;\n  };\n\n  var deleteBackward2 = function deleteBackward2(unit) {\n    console.log(\"editor.deleteBackward:\", unit);\n    var selection = editor.selection;\n\n    if (!selection || slate__WEBPACK_IMPORTED_MODULE_1__[\"Range\"].isExpanded(selection)) {\n      deleteBackward(unit);\n      return;\n    }\n\n    var match = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].above(editor, {\n      match: function match(n) {\n        return slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isBlock(editor, n);\n      }\n    });\n\n    if (!match || slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isEditor(match[0])) {\n      deleteBackward(unit);\n      return;\n    }\n\n    var _ref = match,\n        _ref2 = Object(_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_ref, 2),\n        block = _ref2[0],\n        path = _ref2[1];\n\n    var start = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].start(editor, path);\n\n    if (slate__WEBPACK_IMPORTED_MODULE_1__[\"Point\"].equals(selection.anchor, start)) {\n      if (block.type === 'list-item') {\n        var _ref3 = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].parent(editor, path),\n            _ref4 = Object(_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_ref3, 1),\n            listNode = _ref4[0];\n\n        if (listNode && listNode.indent > 0) {\n          slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].withoutNormalizing(editor, function () {\n            slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].wrapNodes(editor, {\n              type: listNode.type,\n              indent: listNode.indent - 1,\n              children: []\n            }, {\n              at: path\n            });\n            slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].liftNodes(editor, {\n              at: path\n            });\n          });\n        } else {\n          slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].setNodes(editor, {\n            type: 'paragraph'\n          });\n          slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].unwrapNodes(editor, {\n            match: function match(n) {\n              return typeof n.type === 'string' && n.type.endsWith('-list');\n            },\n            split: true\n          }); // deleteBackward(unit)\n        }\n      } else if (block.type === 'paragraph') {\n        if (block.indent && block.indent > 0) {\n          slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].setNodes(editor, {\n            indent: block.indent - 1\n          }, {\n            at: path\n          });\n          return;\n        } else {\n          deleteBackward(unit);\n        }\n      } else {\n        slate__WEBPACK_IMPORTED_MODULE_1__[\"Transforms\"].setNodes(editor, {\n          type: 'paragraph'\n        });\n      }\n\n      return;\n    } // end if at start\n\n\n    deleteBackward(unit);\n  };\n\n  editor.deleteBackward = function (unit) {\n    console.log(\"editor.deleteBackward:\", unit);\n    deleteBackward2(unit);\n    Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"fixList\"])(editor);\n  };\n\n  editor.deleteFragment = function () {\n    console.log(\"editor.deleteFragment:\");\n    deleteFragment();\n  };\n\n  editor.normalizeNode = function (entry) {};\n\n  return editor;\n};\n\nvar beforeTextInBlock = function beforeTextInBlock(editor) {\n  var selection = editor.selection;\n\n  if (!selection) {\n    return '';\n  }\n\n  var block = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].above(editor, {\n    match: function match(n) {\n      return slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].isBlock(editor, n);\n    }\n  });\n  var path = block ? block[1] : [];\n  var start = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].start(editor, path);\n  var range = {\n    anchor: slate__WEBPACK_IMPORTED_MODULE_1__[\"Range\"].start(editor.selection),\n    focus: start\n  };\n  var beforeText = slate__WEBPACK_IMPORTED_MODULE_1__[\"Editor\"].string(editor, range);\n  return beforeText;\n}; //\n// Transforms.delete =(\n//     editor: Editor,\n//     options: {\n//     at?: Location\n//     distance?: number\n//     unit?: 'character' | 'word' | 'line' | 'block'\n//     reverse?: boolean\n//     hanging?: boolean\n//     voids?: boolean\n// } = {}\n// ):void => {\n//     Editor.withoutNormalizing(editor, () => {\n//         const {\n//             reverse = false,\n//             unit = 'character',\n//             distance = 1,\n//             voids = false,\n//         } = options\n//         let { at = editor.selection, hanging = false } = options\n//\n//         if (!at) {\n//             return\n//         }\n//\n//         if (Range.isRange(at) && Range.isCollapsed(at)) {\n//             at = at.anchor\n//         }\n//\n//         if (Point.isPoint(at)) {\n//             const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n//\n//             if (!voids && furthestVoid) {\n//                 const [, voidPath] = furthestVoid\n//                 at = voidPath\n//             } else {\n//                 const opts = { unit, distance }\n//                 const target = reverse\n//                     ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n//                     : Editor.after(editor, at, opts) || Editor.end(editor, [])\n//                 at = { anchor: at, focus: target }\n//                 hanging = true\n//             }\n//         }\n//\n//         if (Path.isPath(at)) {\n//             Transforms.removeNodes(editor, { at, voids })\n//             return\n//         }\n//\n//         if (Range.isCollapsed(at)) {\n//             return\n//         }\n//\n//         if (!hanging) {\n//             at = Editor.unhangRange(editor, at, { voids })\n//         }\n//\n//         let [start, end] = Range.edges(at)\n//         const startBlock = Editor.above(editor, {\n//             match: n => Editor.isBlock(editor, n),\n//             at: start,\n//             voids,\n//         })\n//         const endBlock = Editor.above(editor, {\n//             match: n => Editor.isBlock(editor, n),\n//             at: end,\n//             voids,\n//         })\n//         const isAcrossBlocks =\n//             startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n//         const isSingleText = Path.equals(start.path, end.path)\n//         const startVoid = voids\n//             ? null\n//             : Editor.void(editor, { at: start, mode: 'highest' })\n//         const endVoid = voids\n//             ? null\n//             : Editor.void(editor, { at: end, mode: 'highest' })\n//\n//         // If the start or end points are inside an inline void, nudge them out.\n//         if (startVoid) {\n//             const before = Editor.before(editor, start)\n//\n//             if (\n//                 before &&\n//                 startBlock &&\n//                 Path.isAncestor(startBlock[1], before.path)\n//             ) {\n//                 start = before\n//             }\n//         }\n//\n//         if (endVoid) {\n//             const after = Editor.after(editor, end)\n//\n//             if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n//                 end = after\n//             }\n//         }\n//\n//         // Get the highest nodes that are completely inside the range, as well as\n//         // the start and end nodes.\n//         const matches: NodeEntry[] = []\n//         let lastPath: Path | undefined\n//\n//         for (const entry of Editor.nodes(editor, { at, voids })) {\n//             const [node, path] = entry\n//\n//             if (lastPath && Path.compare(path, lastPath) === 0) {\n//                 continue\n//             }\n//\n//             if (\n//                 (!voids && Editor.isVoid(editor, node)) ||\n//                 (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n//             ) {\n//                 matches.push(entry)\n//                 lastPath = path\n//             }\n//         }\n//\n//         const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n//         const startRef = Editor.pointRef(editor, start)\n//         const endRef = Editor.pointRef(editor, end)\n//\n//         if (!isSingleText && !startVoid) {\n//             const point = startRef.current!\n//             const [node] = Editor.leaf(editor, point)\n//             const { path } = point\n//             const { offset } = start\n//             const text = node.text.slice(offset)\n//             editor.apply({ type: 'remove_text', path, offset, text })\n//         }\n//\n//         for (const pathRef of pathRefs) {\n//             const path = pathRef.unref()!\n//             console.log(\"remove not at:\", path)\n//             Transforms.removeNodes(editor, { at: path, voids })\n//         }\n//\n//         if (!endVoid) {\n//             const point = endRef.current!\n//             const [node] = Editor.leaf(editor, point)\n//             const { path } = point\n//             const offset = isSingleText ? start.offset : 0\n//             const text = node.text.slice(offset, end.offset)\n//             editor.apply({ type: 'remove_text', path, offset, text })\n//         }\n//\n//         if (\n//             !isSingleText &&\n//             isAcrossBlocks &&\n//             endRef.current &&\n//             startRef.current\n//         ) {\n//             console.log(\"merge node at:\", endRef.current)\n//             Transforms.mergeNodes(editor, {\n//                 at: endRef.current,\n//                 hanging: true,\n//                 voids,\n//             })\n//         }\n//\n//         const point = endRef.unref() || startRef.unref()\n//\n//         if (options.at == null && point) {\n//             Transforms.select(editor, point)\n//         }\n//     })\n// }\n//\n// Transforms.mergeNodes = (\n//     editor: Editor,\n//     options: {\n//     at?: Location\n//     match?: (node: Node) => boolean\n//     mode?: 'highest' | 'lowest'\n//     hanging?: boolean\n//     voids?: boolean\n// } = {}\n// ) => {\n//     Editor.withoutNormalizing(editor, () => {\n//         let { match, at = editor.selection } = options\n//         const { hanging = false, voids = false, mode = 'lowest' } = options\n//\n//         if (!at) {\n//             return\n//         }\n//\n//         if (match == null) {\n//             if (Path.isPath(at)) {\n//                 const [parent] = Editor.parent(editor, at)\n//                 match = n => parent.children.includes(n)\n//             } else {\n//                 match = n => Editor.isBlock(editor, n)\n//             }\n//         }\n//\n//         if (!hanging && Range.isRange(at)) {\n//             at = Editor.unhangRange(editor, at)\n//         }\n//\n//         if (Range.isRange(at)) {\n//             if (Range.isCollapsed(at)) {\n//                 at = at.anchor\n//             } else {\n//                 const [, end] = Range.edges(at)\n//                 const pointRef = Editor.pointRef(editor, end)\n//                 Transforms.delete(editor, { at })\n//                 at = pointRef.unref()!\n//\n//                 if (options.at == null) {\n//                     Transforms.select(editor, at)\n//                 }\n//             }\n//         }\n//\n//         const [current] = Editor.nodes(editor, { at, match, voids, mode })\n//         const prev = Editor.previous(editor, { at, match, voids, mode })\n//\n//         if (!current || !prev) {\n//             return\n//         }\n//\n//         const [node, path] = current\n//         const [prevNode, prevPath] = prev\n//\n//         if (path.length === 0 || prevPath.length === 0) {\n//             return\n//         }\n//\n//         const newPath = Path.next(prevPath)\n//         const commonPath = Path.common(path, prevPath)\n//         const isPreviousSibling = Path.isSibling(path, prevPath)\n//         const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\n//             .slice(commonPath.length)\n//             .slice(0, -1)\n//\n//         // Determine if the merge will leave an ancestor of the path empty as a\n//         // result, in which case we'll want to remove it after merging.\n//         const emptyAncestor = Editor.above(editor, {\n//             at: path,\n//             mode: 'highest',\n//             match: n =>\n//                 levels.includes(n) && Element.isElement(n) && n.children.length === 1,\n//         })\n//\n//         const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n//         let properties\n//         let position\n//\n//         // Ensure that the nodes are equivalent, and figure out what the position\n//         // and extra properties of the merge will be.\n//         if (Text.isText(node) && Text.isText(prevNode)) {\n//             const { text, ...rest } = node\n//             position = prevNode.text.length\n//             properties = rest as Partial<Text>\n//         } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n//             const { children, ...rest } = node\n//             position = prevNode.children.length\n//             properties = rest as Partial<Element>\n//         } else {\n//             throw new Error(\n//                 `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n//                     node\n//                 )} ${JSON.stringify(prevNode)}`\n//             )\n//         }\n//\n//         // If the node isn't already the next sibling of the previous node, move\n//         // it so that it is before merging.\n//         if (!isPreviousSibling) {\n//             console.log(\"In merge, movNodes from \", path, \"to\", newPath)\n//             Transforms.moveNodes(editor, { at: path, to: newPath, voids })\n//         }\n//\n//         // If there was going to be an empty ancestor of the node that was merged,\n//         // we remove it from the tree.\n//         if (emptyRef) {\n//             console.log(\"In merge, remove node at:\", emptyRef.current)\n//             Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\n//         }\n//\n//         // If the target node that we're merging with is empty, remove it instead\n//         // of merging the two. This is a common rich text editor behavior to\n//         // prevent losing formatting when deleting entire nodes when you have a\n//         // hanging selection.\n//         if (\n//             (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n//             (Text.isText(prevNode) && prevNode.text === '')\n//         ) {\n//             console.log(\"In merge, remove2\", prevNode.type, \"node at:\", prevPath)\n//             Transforms.removeNodes(editor, { at: prevPath, voids })\n//         } else {\n//             editor.apply({\n//                 type: 'merge_node',\n//                 path: newPath,\n//                 position,\n//                 properties,\n//             })\n//         }\n//\n//         if (emptyRef) {\n//             emptyRef.unref()\n//         }\n//     })\n// }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy93aXRoTWFya2Rvd24udHM/MzRiNiJdLCJuYW1lcyI6WyJTSE9SVENVVFMiLCJ3aXRoTWFya2Rvd24iLCJlZGl0b3IiLCJkZWxldGVCYWNrd2FyZCIsImluc2VydFRleHQiLCJpbnNlcnRCcmVhayIsImRlbGV0ZUZyYWdtZW50Iiwibm9ybWFsaXplTm9kZSIsImluc2VydEJyZWFrMiIsImhhbmRsZWQiLCJzZWxlY3Rpb24iLCJSYW5nZSIsImlzRXhwYW5kZWQiLCJibG9jayIsIkVkaXRvciIsImFib3ZlIiwibWF0Y2giLCJuIiwiaXNCbG9jayIsImlzRWRpdG9yIiwicGFyZW50IiwidGV4dCIsInN0cmluZyIsImJsb2NrUGF0aCIsImluZGVudCIsIlRyYW5zZm9ybXMiLCJzZXROb2RlcyIsInR5cGUiLCJhdCIsImxlbmd0aCIsImNoaWxkcmVuIiwibGlmdE5vZGVzIiwiZml4TGlzdCIsImlzQ29sbGFwc2VkIiwiYW5jaG9yIiwicGF0aCIsInN0YXJ0IiwicmFuZ2UiLCJmb2N1cyIsImJlZm9yZVRleHQiLCJ0YWJzIiwiYyIsInN1YnN0ciIsImJsb2NrVHlwZSIsImluTGlzdCIsInRlc3QiLCJsaXN0Iiwic2VsZWN0Iiwid3JhcE5vZGVzIiwiZm91bmQiLCJkZWxldGVCYWNrd2FyZDIiLCJ1bml0IiwiY29uc29sZSIsImxvZyIsIlBvaW50IiwiZXF1YWxzIiwibGlzdE5vZGUiLCJ3aXRob3V0Tm9ybWFsaXppbmciLCJ1bndyYXBOb2RlcyIsImVuZHNXaXRoIiwic3BsaXQiLCJlbnRyeSIsImJlZm9yZVRleHRJbkJsb2NrIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFFQTtBQUVBLElBQU1BLFNBQVMsR0FBRztBQUNkLE9BQUssU0FEUztBQUVkLE9BQUssU0FGUztBQUdkLE9BQUssU0FIUztBQUlkLE9BQUssYUFKUztBQUtkLE9BQUssYUFMUztBQU1kLFFBQU0sYUFOUTtBQU9kLFNBQU8sZUFQTztBQVFk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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uL3NyYy93aXRoTWFya2Rvd24udHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0VkaXRvciwgUGF0aCwgUG9pbnQsIFJhbmdlLCBFbGVtZW50LCBUZXh0LCBUcmFuc2Zvcm1zLCBOb2RlRW50cnl9IGZyb20gXCJzbGF0ZVwiO1xuaW1wb3J0IHtMaXN0Tm9kZX0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7Zml4TGlzdH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5jb25zdCBTSE9SVENVVFMgPSB7XG4gICAgJyonOiAndWwtaXRlbScsXG4gICAgJy0nOiAndWwtaXRlbScsXG4gICAgJysnOiAndWwtaXRlbScsXG4gICAgJz4nOiAnYmxvY2stcXVvdGUnLFxuICAgICcjJzogJ2hlYWRpbmctb25lJyxcbiAgICAnIyMnOiAnaGVhZGluZy10d28nLFxuICAgICcjIyMnOiAnaGVhZGluZy10aHJlZScsXG4gICAgJyMjIyMnOiAnaGVhZGluZy1mb3VyJyxcbiAgICAnIyMjIyMnOiAnaGVhZGluZy1maXZlJyxcbiAgICAnIyMjIyMjJzogJ2hlYWRpbmctc2l4Jyxcbn1cblxuZXhwb3J0IGNvbnN0IHdpdGhNYXJrZG93biA9IChlZGl0b3I6IEVkaXRvcikgPT4ge1xuICAgIGNvbnN0IHtkZWxldGVCYWNrd2FyZCwgaW5zZXJ0VGV4dCwgaW5zZXJ0QnJlYWssIGRlbGV0ZUZyYWdtZW50LCBub3JtYWxpemVOb2RlfSA9IGVkaXRvclxuXG4gICAgY29uc3QgaW5zZXJ0QnJlYWsyID0gKCkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlXG4gICAgICAgIGNvbnN0IHtzZWxlY3Rpb259ID0gZWRpdG9yXG5cbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBpbnNlcnRCcmVhaygpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIH0pXG4gICAgICAgIGlmICghYmxvY2sgfHwgRWRpdG9yLmlzRWRpdG9yKGJsb2NrWzBdKSkge1xuICAgICAgICAgICAgaW5zZXJ0QnJlYWsoKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGJsb2NrWzFdKVxuICAgICAgICBpZiAoIXBhcmVudCB8fCBFZGl0b3IuaXNFZGl0b3IocGFyZW50WzBdKSkge1xuICAgICAgICAgICAgaW5zZXJ0QnJlYWsoKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCBibG9ja1sxXSlcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIGluc2VydEJyZWFrKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrUGF0aDogUGF0aCA9IGJsb2NrWzFdXG4gICAgICAgIGxldCBpbmRlbnQgPSAwXG4gICAgICAgIGlmICh0eXBlb2YgcGFyZW50WzBdLmluZGVudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaW5kZW50ID0gcGFyZW50WzBdLmluZGVudCA+IDEgPyBwYXJlbnRbMF0uaW5kZW50IC0gMSA6IDBcbiAgICAgICAgfVxuICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge3R5cGU6ICdwYXJhZ3JhcGgnLCBpbmRlbnR9LCB7YXQ6IGJsb2NrUGF0aH0pXG4gICAgICAgIC8vIGlmIGl0IGlzIHRoZSBsYXN0IGNoaWxkXG4gICAgICAgIGlmIChibG9ja1BhdGhbYmxvY2tQYXRoLmxlbmd0aCAtIDFdID09PSBwYXJlbnRbMF0uY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5saWZ0Tm9kZXMoZWRpdG9yLCB7YXQ6IGJsb2NrUGF0aH0pXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgIH1cbiAgICBlZGl0b3IuaW5zZXJ0QnJlYWsgPSAoKSA9PiB7XG4gICAgICAgIGluc2VydEJyZWFrMigpXG4gICAgICAgIGZpeExpc3QoZWRpdG9yKVxuICAgIH1cbiAgICBlZGl0b3IuaW5zZXJ0VGV4dCA9ICh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3Qge3NlbGVjdGlvbn0gPSBlZGl0b3JcbiAgICAgICAgaWYgKCh0ZXh0ICE9PSAnICcpIHx8ICFzZWxlY3Rpb24gfHwgIVJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGluc2VydFRleHQodGV4dClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge2FuY2hvcn0gPSBzZWxlY3Rpb25cbiAgICAgICAgY29uc3QgYmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICBtYXRjaDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgICB9KVxuICAgICAgICBjb25zdCBwYXRoID0gYmxvY2sgPyBibG9ja1sxXSA6IFtdXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aClcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB7YW5jaG9yLCBmb2N1czogc3RhcnR9XG4gICAgICAgIGxldCBiZWZvcmVUZXh0ID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIHJhbmdlKVxuICAgICAgICBsZXQgdGFicyA9IDBcbiAgICAgICAgZm9yIChsZXQgYyBvZiBiZWZvcmVUZXh0KSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgICAgICB0YWJzKytcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBiZWZvcmVUZXh0ID0gYmVmb3JlVGV4dC5zdWJzdHIodGFicylcbiAgICAgICAgY29uc3QgYmxvY2tUeXBlID0gYmxvY2shWzBdLnR5cGUgYXMgc3RyaW5nXG4gICAgICAgIGxldCBpbkxpc3QgPSB0eXBlb2YgYmxvY2tUeXBlID09PSAnc3RyaW5nJyA/IGJsb2NrVHlwZSA9PT0gJ2xpc3QtaXRlbScgOiBmYWxzZVxuXG5cbiAgICAgICAgbGV0IHR5cGUgPSBTSE9SVENVVFNbYmVmb3JlVGV4dF1cblxuICAgICAgICBpZiAoIXR5cGUgJiYgL15bMS05XVxcZCpcXC4vLnRlc3QoYmVmb3JlVGV4dCkpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnb2wtaXRlbSdcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGlzdFxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3VsLWl0ZW0nOlxuICAgICAgICAgICAgICAgIGlmIChpbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dCh0ZXh0KVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKVxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvcilcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKFxuICAgICAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgIHt0eXBlOiAnbGlzdC1pdGVtJ30sXG4gICAgICAgICAgICAgICAgICAgIHttYXRjaDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBsaXN0ID0ge3R5cGU6ICdidWxsZXRlZC1saXN0JywgaW5kZW50OiB0YWJzLCBjaGlsZHJlbjogW119XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCBsaXN0LCB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoOiBuID0+IG4udHlwZSA9PT0gJ2xpc3QtaXRlbScsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBmaXhMaXN0KGVkaXRvcilcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnb2wtaXRlbSc6XG4gICAgICAgICAgICAgICAgaWYgKGluTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0KHRleHQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gYmVmb3JlVGV4dC5tYXRjaCgvXihbXFx0XSopXFxkK1xcLi8pXG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSlcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IpXG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICB7dHlwZTogJ2xpc3QtaXRlbSd9LFxuICAgICAgICAgICAgICAgICAgICB7bWF0Y2g6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKX1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgbGlzdCA9IHt0eXBlOiAnbnVtYmVyZWQtbGlzdCcsIGluZGVudDogdGFicywgY2hpbGRyZW46IFtdfVxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwgbGlzdCwge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaDogbiA9PiBuLnR5cGUgPT09ICdsaXN0LWl0ZW0nLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgZml4TGlzdChlZGl0b3IpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXF1b3RlJzpcbiAgICAgICAgICAgICAgICBpZiAoaW5MaXN0IHx8IGJsb2NrVHlwZSAhPT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dCh0ZXh0KVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge21hdGNoOiBuID0+IG4udHlwZSA9PT0gJ2Jsb2NrLXF1b3RlJ30pXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0KHRleHQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpXG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yKVxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwge3R5cGU6ICdibG9jay1xdW90ZScsIGNoaWxkcmVuOiBbXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2g6IG4gPT4gbi50eXBlID09PSAncGFyYWdyYXBoJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dCh0ZXh0KVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGRlbGV0ZUJhY2t3YXJkMiA9ICh1bml0OiAnY2hhcmFjdGVyJyB8ICd3b3JkJyB8ICdsaW5lJyB8ICdibG9jaycpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJlZGl0b3IuZGVsZXRlQmFja3dhcmQ6XCIsIHVuaXQpXG4gICAgICAgIGNvbnN0IHtzZWxlY3Rpb259ID0gZWRpdG9yXG5cbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBkZWxldGVCYWNrd2FyZCh1bml0KVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2ggPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICBtYXRjaDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghbWF0Y2ggfHwgRWRpdG9yLmlzRWRpdG9yKG1hdGNoWzBdKSkge1xuICAgICAgICAgICAgZGVsZXRlQmFja3dhcmQodW5pdClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtibG9jaywgcGF0aF0gPSBtYXRjaCBhcyBOb2RlRW50cnk8TGlzdE5vZGU+XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aClcblxuICAgICAgICBpZiAoUG9pbnQuZXF1YWxzKHNlbGVjdGlvbi5hbmNob3IsIHN0YXJ0KSkge1xuICAgICAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT09ICdsaXN0LWl0ZW0nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2xpc3ROb2RlXSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKSBhcyBOb2RlRW50cnk8TGlzdE5vZGU+XG4gICAgICAgICAgICAgICAgaWYgKGxpc3ROb2RlICYmIChsaXN0Tm9kZS5pbmRlbnQgYXMgbnVtYmVyID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGxpc3ROb2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiBsaXN0Tm9kZS5pbmRlbnQhIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHthdDogcGF0aH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmxpZnROb2RlcyhlZGl0b3IsIHthdDogcGF0aH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHt0eXBlOiAncGFyYWdyYXBoJ30pXG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaDogbiA9PiAodHlwZW9mIG4udHlwZSA9PT0gJ3N0cmluZycgJiYgbi50eXBlLmVuZHNXaXRoKCctbGlzdCcpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGVCYWNrd2FyZCh1bml0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmxvY2sudHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2suaW5kZW50ICYmIGJsb2NrLmluZGVudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtpbmRlbnQ6IGJsb2NrLmluZGVudCAtIDF9LCB7YXQ6IHBhdGh9KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVCYWNrd2FyZCh1bml0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHt0eXBlOiAncGFyYWdyYXBoJ30pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSAvLyBlbmQgaWYgYXQgc3RhcnRcbiAgICAgICAgZGVsZXRlQmFja3dhcmQodW5pdClcbiAgICB9XG5cbiAgICBlZGl0b3IuZGVsZXRlQmFja3dhcmQgPSAodW5pdDogJ2NoYXJhY3RlcicgfCAnd29yZCcgfCAnbGluZScgfCAnYmxvY2snKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZWRpdG9yLmRlbGV0ZUJhY2t3YXJkOlwiLCB1bml0KVxuICAgICAgICBkZWxldGVCYWNrd2FyZDIodW5pdClcbiAgICAgICAgZml4TGlzdChlZGl0b3IpXG4gICAgfVxuXG4gICAgZWRpdG9yLmRlbGV0ZUZyYWdtZW50ID0gKCk9PntcbiAgICAgICAgY29uc29sZS5sb2coXCJlZGl0b3IuZGVsZXRlRnJhZ21lbnQ6XCIpXG4gICAgICAgIGRlbGV0ZUZyYWdtZW50KClcbiAgICB9XG4gICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAoZW50cnk6Tm9kZUVudHJ5KT0+e1xuICAgICAgICBcbiAgICB9XG5cbiAgICByZXR1cm4gZWRpdG9yXG59XG5cbmNvbnN0IGJlZm9yZVRleHRJbkJsb2NrID0gKGVkaXRvcjogRWRpdG9yKTogc3RyaW5nID0+IHtcbiAgICBjb25zdCB7c2VsZWN0aW9ufSA9IGVkaXRvclxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAnJ1xuICAgIH1cbiAgICBjb25zdCBibG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICB9KVxuICAgIGNvbnN0IHBhdGggPSBibG9jayA/IGJsb2NrWzFdIDogW11cbiAgICBjb25zdCBzdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpXG4gICAgY29uc3QgcmFuZ2UgPSB7YW5jaG9yOiBSYW5nZS5zdGFydChlZGl0b3Iuc2VsZWN0aW9uISksIGZvY3VzOiBzdGFydH1cbiAgICBsZXQgYmVmb3JlVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCByYW5nZSlcbiAgICByZXR1cm4gYmVmb3JlVGV4dFxufVxuLy9cbi8vIFRyYW5zZm9ybXMuZGVsZXRlID0oXG4vLyAgICAgZWRpdG9yOiBFZGl0b3IsXG4vLyAgICAgb3B0aW9uczoge1xuLy8gICAgIGF0PzogTG9jYXRpb25cbi8vICAgICBkaXN0YW5jZT86IG51bWJlclxuLy8gICAgIHVuaXQ/OiAnY2hhcmFjdGVyJyB8ICd3b3JkJyB8ICdsaW5lJyB8ICdibG9jaydcbi8vICAgICByZXZlcnNlPzogYm9vbGVhblxuLy8gICAgIGhhbmdpbmc/OiBib29sZWFuXG4vLyAgICAgdm9pZHM/OiBib29sZWFuXG4vLyB9ID0ge31cbi8vICk6dm9pZCA9PiB7XG4vLyAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbi8vICAgICAgICAgY29uc3Qge1xuLy8gICAgICAgICAgICAgcmV2ZXJzZSA9IGZhbHNlLFxuLy8gICAgICAgICAgICAgdW5pdCA9ICdjaGFyYWN0ZXInLFxuLy8gICAgICAgICAgICAgZGlzdGFuY2UgPSAxLFxuLy8gICAgICAgICAgICAgdm9pZHMgPSBmYWxzZSxcbi8vICAgICAgICAgfSA9IG9wdGlvbnNcbi8vICAgICAgICAgbGV0IHsgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLCBoYW5naW5nID0gZmFsc2UgfSA9IG9wdGlvbnNcbi8vXG4vLyAgICAgICAgIGlmICghYXQpIHtcbi8vICAgICAgICAgICAgIHJldHVyblxuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkgJiYgUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4vLyAgICAgICAgICAgICBhdCA9IGF0LmFuY2hvclxuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbi8vICAgICAgICAgICAgIGNvbnN0IGZ1cnRoZXN0Vm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwgeyBhdCwgbW9kZTogJ2hpZ2hlc3QnIH0pXG4vL1xuLy8gICAgICAgICAgICAgaWYgKCF2b2lkcyAmJiBmdXJ0aGVzdFZvaWQpIHtcbi8vICAgICAgICAgICAgICAgICBjb25zdCBbLCB2b2lkUGF0aF0gPSBmdXJ0aGVzdFZvaWRcbi8vICAgICAgICAgICAgICAgICBhdCA9IHZvaWRQYXRoXG4vLyAgICAgICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgIGNvbnN0IG9wdHMgPSB7IHVuaXQsIGRpc3RhbmNlIH1cbi8vICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSByZXZlcnNlXG4vLyAgICAgICAgICAgICAgICAgICAgID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSlcbi8vICAgICAgICAgICAgICAgICAgICAgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhdCwgb3B0cykgfHwgRWRpdG9yLmVuZChlZGl0b3IsIFtdKVxuLy8gICAgICAgICAgICAgICAgIGF0ID0geyBhbmNob3I6IGF0LCBmb2N1czogdGFyZ2V0IH1cbi8vICAgICAgICAgICAgICAgICBoYW5naW5nID0gdHJ1ZVxuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4vLyAgICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwgeyBhdCwgdm9pZHMgfSlcbi8vICAgICAgICAgICAgIHJldHVyblxuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4vLyAgICAgICAgICAgICByZXR1cm5cbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgaWYgKCFoYW5naW5nKSB7XG4vLyAgICAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7IHZvaWRzIH0pXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGxldCBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdClcbi8vICAgICAgICAgY29uc3Qgc3RhcnRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbi8vICAgICAgICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4vLyAgICAgICAgICAgICBhdDogc3RhcnQsXG4vLyAgICAgICAgICAgICB2b2lkcyxcbi8vICAgICAgICAgfSlcbi8vICAgICAgICAgY29uc3QgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4vLyAgICAgICAgICAgICBtYXRjaDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuLy8gICAgICAgICAgICAgYXQ6IGVuZCxcbi8vICAgICAgICAgICAgIHZvaWRzLFxuLy8gICAgICAgICB9KVxuLy8gICAgICAgICBjb25zdCBpc0Fjcm9zc0Jsb2NrcyA9XG4vLyAgICAgICAgICAgICBzdGFydEJsb2NrICYmIGVuZEJsb2NrICYmICFQYXRoLmVxdWFscyhzdGFydEJsb2NrWzFdLCBlbmRCbG9ja1sxXSlcbi8vICAgICAgICAgY29uc3QgaXNTaW5nbGVUZXh0ID0gUGF0aC5lcXVhbHMoc3RhcnQucGF0aCwgZW5kLnBhdGgpXG4vLyAgICAgICAgIGNvbnN0IHN0YXJ0Vm9pZCA9IHZvaWRzXG4vLyAgICAgICAgICAgICA/IG51bGxcbi8vICAgICAgICAgICAgIDogRWRpdG9yLnZvaWQoZWRpdG9yLCB7IGF0OiBzdGFydCwgbW9kZTogJ2hpZ2hlc3QnIH0pXG4vLyAgICAgICAgIGNvbnN0IGVuZFZvaWQgPSB2b2lkc1xuLy8gICAgICAgICAgICAgPyBudWxsXG4vLyAgICAgICAgICAgICA6IEVkaXRvci52b2lkKGVkaXRvciwgeyBhdDogZW5kLCBtb2RlOiAnaGlnaGVzdCcgfSlcbi8vXG4vLyAgICAgICAgIC8vIElmIHRoZSBzdGFydCBvciBlbmQgcG9pbnRzIGFyZSBpbnNpZGUgYW4gaW5saW5lIHZvaWQsIG51ZGdlIHRoZW0gb3V0LlxuLy8gICAgICAgICBpZiAoc3RhcnRWb2lkKSB7XG4vLyAgICAgICAgICAgICBjb25zdCBiZWZvcmUgPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgc3RhcnQpXG4vL1xuLy8gICAgICAgICAgICAgaWYgKFxuLy8gICAgICAgICAgICAgICAgIGJlZm9yZSAmJlxuLy8gICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2sgJiZcbi8vICAgICAgICAgICAgICAgICBQYXRoLmlzQW5jZXN0b3Ioc3RhcnRCbG9ja1sxXSwgYmVmb3JlLnBhdGgpXG4vLyAgICAgICAgICAgICApIHtcbi8vICAgICAgICAgICAgICAgICBzdGFydCA9IGJlZm9yZVxuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICBpZiAoZW5kVm9pZCkge1xuLy8gICAgICAgICAgICAgY29uc3QgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBlbmQpXG4vL1xuLy8gICAgICAgICAgICAgaWYgKGFmdGVyICYmIGVuZEJsb2NrICYmIFBhdGguaXNBbmNlc3RvcihlbmRCbG9ja1sxXSwgYWZ0ZXIucGF0aCkpIHtcbi8vICAgICAgICAgICAgICAgICBlbmQgPSBhZnRlclxuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICAvLyBHZXQgdGhlIGhpZ2hlc3Qgbm9kZXMgdGhhdCBhcmUgY29tcGxldGVseSBpbnNpZGUgdGhlIHJhbmdlLCBhcyB3ZWxsIGFzXG4vLyAgICAgICAgIC8vIHRoZSBzdGFydCBhbmQgZW5kIG5vZGVzLlxuLy8gICAgICAgICBjb25zdCBtYXRjaGVzOiBOb2RlRW50cnlbXSA9IFtdXG4vLyAgICAgICAgIGxldCBsYXN0UGF0aDogUGF0aCB8IHVuZGVmaW5lZFxuLy9cbi8vICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7IGF0LCB2b2lkcyB9KSkge1xuLy8gICAgICAgICAgICAgY29uc3QgW25vZGUsIHBhdGhdID0gZW50cnlcbi8vXG4vLyAgICAgICAgICAgICBpZiAobGFzdFBhdGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGxhc3RQYXRoKSA9PT0gMCkge1xuLy8gICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4vLyAgICAgICAgICAgICB9XG4vL1xuLy8gICAgICAgICAgICAgaWYgKFxuLy8gICAgICAgICAgICAgICAgICghdm9pZHMgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB8fFxuLy8gICAgICAgICAgICAgICAgICghUGF0aC5pc0NvbW1vbihwYXRoLCBzdGFydC5wYXRoKSAmJiAhUGF0aC5pc0NvbW1vbihwYXRoLCBlbmQucGF0aCkpXG4vLyAgICAgICAgICAgICApIHtcbi8vICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goZW50cnkpXG4vLyAgICAgICAgICAgICAgICAgbGFzdFBhdGggPSBwYXRoXG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGNvbnN0IHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCAoWywgcF0pID0+IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCkpXG4vLyAgICAgICAgIGNvbnN0IHN0YXJ0UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgc3RhcnQpXG4vLyAgICAgICAgIGNvbnN0IGVuZFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZClcbi8vXG4vLyAgICAgICAgIGlmICghaXNTaW5nbGVUZXh0ICYmICFzdGFydFZvaWQpIHtcbi8vICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gc3RhcnRSZWYuY3VycmVudCFcbi8vICAgICAgICAgICAgIGNvbnN0IFtub2RlXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgcG9pbnQpXG4vLyAgICAgICAgICAgICBjb25zdCB7IHBhdGggfSA9IHBvaW50XG4vLyAgICAgICAgICAgICBjb25zdCB7IG9mZnNldCB9ID0gc3RhcnRcbi8vICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBub2RlLnRleHQuc2xpY2Uob2Zmc2V0KVxuLy8gICAgICAgICAgICAgZWRpdG9yLmFwcGx5KHsgdHlwZTogJ3JlbW92ZV90ZXh0JywgcGF0aCwgb2Zmc2V0LCB0ZXh0IH0pXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGZvciAoY29uc3QgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuLy8gICAgICAgICAgICAgY29uc3QgcGF0aCA9IHBhdGhSZWYudW5yZWYoKSFcbi8vICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVtb3ZlIG5vdCBhdDpcIiwgcGF0aClcbi8vICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7IGF0OiBwYXRoLCB2b2lkcyB9KVxuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICBpZiAoIWVuZFZvaWQpIHtcbi8vICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gZW5kUmVmLmN1cnJlbnQhXG4vLyAgICAgICAgICAgICBjb25zdCBbbm9kZV0gPSBFZGl0b3IubGVhZihlZGl0b3IsIHBvaW50KVxuLy8gICAgICAgICAgICAgY29uc3QgeyBwYXRoIH0gPSBwb2ludFxuLy8gICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaXNTaW5nbGVUZXh0ID8gc3RhcnQub2Zmc2V0IDogMFxuLy8gICAgICAgICAgICAgY29uc3QgdGV4dCA9IG5vZGUudGV4dC5zbGljZShvZmZzZXQsIGVuZC5vZmZzZXQpXG4vLyAgICAgICAgICAgICBlZGl0b3IuYXBwbHkoeyB0eXBlOiAncmVtb3ZlX3RleHQnLCBwYXRoLCBvZmZzZXQsIHRleHQgfSlcbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgaWYgKFxuLy8gICAgICAgICAgICAgIWlzU2luZ2xlVGV4dCAmJlxuLy8gICAgICAgICAgICAgaXNBY3Jvc3NCbG9ja3MgJiZcbi8vICAgICAgICAgICAgIGVuZFJlZi5jdXJyZW50ICYmXG4vLyAgICAgICAgICAgICBzdGFydFJlZi5jdXJyZW50XG4vLyAgICAgICAgICkge1xuLy8gICAgICAgICAgICAgY29uc29sZS5sb2coXCJtZXJnZSBub2RlIGF0OlwiLCBlbmRSZWYuY3VycmVudClcbi8vICAgICAgICAgICAgIFRyYW5zZm9ybXMubWVyZ2VOb2RlcyhlZGl0b3IsIHtcbi8vICAgICAgICAgICAgICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4vLyAgICAgICAgICAgICAgICAgaGFuZ2luZzogdHJ1ZSxcbi8vICAgICAgICAgICAgICAgICB2b2lkcyxcbi8vICAgICAgICAgICAgIH0pXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGNvbnN0IHBvaW50ID0gZW5kUmVmLnVucmVmKCkgfHwgc3RhcnRSZWYudW5yZWYoKVxuLy9cbi8vICAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCAmJiBwb2ludCkge1xuLy8gICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBwb2ludClcbi8vICAgICAgICAgfVxuLy8gICAgIH0pXG4vLyB9XG4vL1xuLy8gVHJhbnNmb3Jtcy5tZXJnZU5vZGVzID0gKFxuLy8gICAgIGVkaXRvcjogRWRpdG9yLFxuLy8gICAgIG9wdGlvbnM6IHtcbi8vICAgICBhdD86IExvY2F0aW9uXG4vLyAgICAgbWF0Y2g/OiAobm9kZTogTm9kZSkgPT4gYm9vbGVhblxuLy8gICAgIG1vZGU/OiAnaGlnaGVzdCcgfCAnbG93ZXN0J1xuLy8gICAgIGhhbmdpbmc/OiBib29sZWFuXG4vLyAgICAgdm9pZHM/OiBib29sZWFuXG4vLyB9ID0ge31cbi8vICkgPT4ge1xuLy8gICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4vLyAgICAgICAgIGxldCB7IG1hdGNoLCBhdCA9IGVkaXRvci5zZWxlY3Rpb24gfSA9IG9wdGlvbnNcbi8vICAgICAgICAgY29uc3QgeyBoYW5naW5nID0gZmFsc2UsIHZvaWRzID0gZmFsc2UsIG1vZGUgPSAnbG93ZXN0JyB9ID0gb3B0aW9uc1xuLy9cbi8vICAgICAgICAgaWYgKCFhdCkge1xuLy8gICAgICAgICAgICAgcmV0dXJuXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4vLyAgICAgICAgICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4vLyAgICAgICAgICAgICAgICAgY29uc3QgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpXG4vLyAgICAgICAgICAgICAgICAgbWF0Y2ggPSBuID0+IHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKVxuLy8gICAgICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICBtYXRjaCA9IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKVxuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbi8vICAgICAgICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQpXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuLy8gICAgICAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuLy8gICAgICAgICAgICAgICAgIGF0ID0gYXQuYW5jaG9yXG4vLyAgICAgICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgIGNvbnN0IFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdClcbi8vICAgICAgICAgICAgICAgICBjb25zdCBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZClcbi8vICAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHsgYXQgfSlcbi8vICAgICAgICAgICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCkhXG4vL1xuLy8gICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdClcbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGNvbnN0IFtjdXJyZW50XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHsgYXQsIG1hdGNoLCB2b2lkcywgbW9kZSB9KVxuLy8gICAgICAgICBjb25zdCBwcmV2ID0gRWRpdG9yLnByZXZpb3VzKGVkaXRvciwgeyBhdCwgbWF0Y2gsIHZvaWRzLCBtb2RlIH0pXG4vL1xuLy8gICAgICAgICBpZiAoIWN1cnJlbnQgfHwgIXByZXYpIHtcbi8vICAgICAgICAgICAgIHJldHVyblxuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICBjb25zdCBbbm9kZSwgcGF0aF0gPSBjdXJyZW50XG4vLyAgICAgICAgIGNvbnN0IFtwcmV2Tm9kZSwgcHJldlBhdGhdID0gcHJldlxuLy9cbi8vICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwIHx8IHByZXZQYXRoLmxlbmd0aCA9PT0gMCkge1xuLy8gICAgICAgICAgICAgcmV0dXJuXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGNvbnN0IG5ld1BhdGggPSBQYXRoLm5leHQocHJldlBhdGgpXG4vLyAgICAgICAgIGNvbnN0IGNvbW1vblBhdGggPSBQYXRoLmNvbW1vbihwYXRoLCBwcmV2UGF0aClcbi8vICAgICAgICAgY29uc3QgaXNQcmV2aW91c1NpYmxpbmcgPSBQYXRoLmlzU2libGluZyhwYXRoLCBwcmV2UGF0aClcbi8vICAgICAgICAgY29uc3QgbGV2ZWxzID0gQXJyYXkuZnJvbShFZGl0b3IubGV2ZWxzKGVkaXRvciwgeyBhdDogcGF0aCB9KSwgKFtuXSkgPT4gbilcbi8vICAgICAgICAgICAgIC5zbGljZShjb21tb25QYXRoLmxlbmd0aClcbi8vICAgICAgICAgICAgIC5zbGljZSgwLCAtMSlcbi8vXG4vLyAgICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgbWVyZ2Ugd2lsbCBsZWF2ZSBhbiBhbmNlc3RvciBvZiB0aGUgcGF0aCBlbXB0eSBhcyBhXG4vLyAgICAgICAgIC8vIHJlc3VsdCwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHJlbW92ZSBpdCBhZnRlciBtZXJnaW5nLlxuLy8gICAgICAgICBjb25zdCBlbXB0eUFuY2VzdG9yID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuLy8gICAgICAgICAgICAgYXQ6IHBhdGgsXG4vLyAgICAgICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4vLyAgICAgICAgICAgICBtYXRjaDogbiA9PlxuLy8gICAgICAgICAgICAgICAgIGxldmVscy5pbmNsdWRlcyhuKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBuLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSxcbi8vICAgICAgICAgfSlcbi8vXG4vLyAgICAgICAgIGNvbnN0IGVtcHR5UmVmID0gZW1wdHlBbmNlc3RvciAmJiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGVtcHR5QW5jZXN0b3JbMV0pXG4vLyAgICAgICAgIGxldCBwcm9wZXJ0aWVzXG4vLyAgICAgICAgIGxldCBwb3NpdGlvblxuLy9cbi8vICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIG5vZGVzIGFyZSBlcXVpdmFsZW50LCBhbmQgZmlndXJlIG91dCB3aGF0IHRoZSBwb3NpdGlvblxuLy8gICAgICAgICAvLyBhbmQgZXh0cmEgcHJvcGVydGllcyBvZiB0aGUgbWVyZ2Ugd2lsbCBiZS5cbi8vICAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0KHByZXZOb2RlKSkge1xuLy8gICAgICAgICAgICAgY29uc3QgeyB0ZXh0LCAuLi5yZXN0IH0gPSBub2RlXG4vLyAgICAgICAgICAgICBwb3NpdGlvbiA9IHByZXZOb2RlLnRleHQubGVuZ3RoXG4vLyAgICAgICAgICAgICBwcm9wZXJ0aWVzID0gcmVzdCBhcyBQYXJ0aWFsPFRleHQ+XG4vLyAgICAgICAgIH0gZWxzZSBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWxlbWVudC5pc0VsZW1lbnQocHJldk5vZGUpKSB7XG4vLyAgICAgICAgICAgICBjb25zdCB7IGNoaWxkcmVuLCAuLi5yZXN0IH0gPSBub2RlXG4vLyAgICAgICAgICAgICBwb3NpdGlvbiA9IHByZXZOb2RlLmNoaWxkcmVuLmxlbmd0aFxuLy8gICAgICAgICAgICAgcHJvcGVydGllcyA9IHJlc3QgYXMgUGFydGlhbDxFbGVtZW50PlxuLy8gICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuLy8gICAgICAgICAgICAgICAgIGBDYW5ub3QgbWVyZ2UgdGhlIG5vZGUgYXQgcGF0aCBbJHtwYXRofV0gd2l0aCB0aGUgcHJldmlvdXMgc2libGluZyBiZWNhdXNlIGl0IGlzIG5vdCB0aGUgc2FtZSBraW5kOiAke0pTT04uc3RyaW5naWZ5KFxuLy8gICAgICAgICAgICAgICAgICAgICBub2RlXG4vLyAgICAgICAgICAgICAgICAgKX0gJHtKU09OLnN0cmluZ2lmeShwcmV2Tm9kZSl9YFxuLy8gICAgICAgICAgICAgKVxuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICAvLyBJZiB0aGUgbm9kZSBpc24ndCBhbHJlYWR5IHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIHByZXZpb3VzIG5vZGUsIG1vdmVcbi8vICAgICAgICAgLy8gaXQgc28gdGhhdCBpdCBpcyBiZWZvcmUgbWVyZ2luZy5cbi8vICAgICAgICAgaWYgKCFpc1ByZXZpb3VzU2libGluZykge1xuLy8gICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbiBtZXJnZSwgbW92Tm9kZXMgZnJvbSBcIiwgcGF0aCwgXCJ0b1wiLCBuZXdQYXRoKVxuLy8gICAgICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7IGF0OiBwYXRoLCB0bzogbmV3UGF0aCwgdm9pZHMgfSlcbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGdvaW5nIHRvIGJlIGFuIGVtcHR5IGFuY2VzdG9yIG9mIHRoZSBub2RlIHRoYXQgd2FzIG1lcmdlZCxcbi8vICAgICAgICAgLy8gd2UgcmVtb3ZlIGl0IGZyb20gdGhlIHRyZWUuXG4vLyAgICAgICAgIGlmIChlbXB0eVJlZikge1xuLy8gICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbiBtZXJnZSwgcmVtb3ZlIG5vZGUgYXQ6XCIsIGVtcHR5UmVmLmN1cnJlbnQpXG4vLyAgICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwgeyBhdDogZW1wdHlSZWYuY3VycmVudCEsIHZvaWRzIH0pXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIC8vIElmIHRoZSB0YXJnZXQgbm9kZSB0aGF0IHdlJ3JlIG1lcmdpbmcgd2l0aCBpcyBlbXB0eSwgcmVtb3ZlIGl0IGluc3RlYWRcbi8vICAgICAgICAgLy8gb2YgbWVyZ2luZyB0aGUgdHdvLiBUaGlzIGlzIGEgY29tbW9uIHJpY2ggdGV4dCBlZGl0b3IgYmVoYXZpb3IgdG9cbi8vICAgICAgICAgLy8gcHJldmVudCBsb3NpbmcgZm9ybWF0dGluZyB3aGVuIGRlbGV0aW5nIGVudGlyZSBub2RlcyB3aGVuIHlvdSBoYXZlIGFcbi8vICAgICAgICAgLy8gaGFuZ2luZyBzZWxlY3Rpb24uXG4vLyAgICAgICAgIGlmIChcbi8vICAgICAgICAgICAgIChFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkgJiYgRWRpdG9yLmlzRW1wdHkoZWRpdG9yLCBwcmV2Tm9kZSkpIHx8XG4vLyAgICAgICAgICAgICAoVGV4dC5pc1RleHQocHJldk5vZGUpICYmIHByZXZOb2RlLnRleHQgPT09ICcnKVxuLy8gICAgICAgICApIHtcbi8vICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gbWVyZ2UsIHJlbW92ZTJcIiwgcHJldk5vZGUudHlwZSwgXCJub2RlIGF0OlwiLCBwcmV2UGF0aClcbi8vICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7IGF0OiBwcmV2UGF0aCwgdm9pZHMgfSlcbi8vICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4vLyAgICAgICAgICAgICAgICAgdHlwZTogJ21lcmdlX25vZGUnLFxuLy8gICAgICAgICAgICAgICAgIHBhdGg6IG5ld1BhdGgsXG4vLyAgICAgICAgICAgICAgICAgcG9zaXRpb24sXG4vLyAgICAgICAgICAgICAgICAgcHJvcGVydGllcyxcbi8vICAgICAgICAgICAgIH0pXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIGlmIChlbXB0eVJlZikge1xuLy8gICAgICAgICAgICAgZW1wdHlSZWYudW5yZWYoKVxuLy8gICAgICAgICB9XG4vLyAgICAgfSlcbi8vIH0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../src/withMarkdown.ts\n");

/***/ })

})